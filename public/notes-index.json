{
  "folders": [
    {
      "name": "101-ADVENT OF CODE",
      "path": "101-ADVENT OF CODE",
      "noteCount": 0,
      "notes": []
    },
    {
      "name": "101-ADVENT OF CODE/2023",
      "path": "101-ADVENT OF CODE/2023",
      "noteCount": 10,
      "notes": [
        {
          "id": "101-advent-of-code-2023-day-1-md",
          "slug": "101-advent-of-code/2023/day-1",
          "filepath": "101-ADVENT OF CODE/2023/Day 1.md",
          "folder": "101-ADVENT OF CODE/2023",
          "filename": "Day 1.md",
          "frontmatter": {
            "title": "Day 1",
            "date": "2025-07-24",
            "tags": [
              "adventofcode",
              "aoc2023",
              "programming",
              "challenges",
              "puzzle",
              "coding",
              "algorithms"
            ],
            "category": "101-ADVENT OF CODE/2023",
            "description": "Solutions and notes for Day 1 of the Advent of Code 2023 programming challenge covering both parts of the puzzle."
          },
          "content": "### PART 1\n\n```C\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n        return 1;\n    }\n\n    FILE *fptr;\n    fptr = fopen(argv[1], \"r\");\n    if (fptr == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char line[1028];\n    int sum = 0;\n\n    while (fgets(line, sizeof(line), fptr)) {\n        // Remove trailing newline character if present\n        line[strcspn(line, \"\\n\")] = 0;\n        printf(\"Processing line: %s\\n\", line); // Changed from original printf\n\n        int left = -1;\n        int right = -1;\n\n        for (int i = 0; i < strlen(line); i++) {\n            if (isdigit(line[i])) {\n                if (left == -1) {\n                    left = line[i] - '0'; // Use '0' instead of 0x30 for clarity\n                    right = line[i] - '0';\n                } else {\n                    right = line[i] - '0';\n                }\n            }\n        }\n\n        // Handle lines with no digits\n        if (left != -1) {\n            int digit = left * 10 + right;\n            printf(\"Extracted Digit: %d\\n\", digit);\n            sum += digit;\n        } else {\n            printf(\"No digits found in this line.\\n\");\n        }\n    }\n\n    printf(\"Final Sum: %d \\n\", sum); // Changed from original printf\n\n    fclose(fptr);\n    return 0;\n}\n```\n\n\n### PART 2\n\n```C\n\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char str[10];\n    int i;\n} lookup_t;\n\nlookup_t gTable[] = {\n    {\"zero\", 0},\n    {\"one\", 1},\n    {\"two\", 2},\n    {\"three\", 3},\n    {\"four\", 4},\n    {\"five\", 5},\n    {\"six\", 6},\n    {\"seven\", 7},\n    {\"eight\", 8},\n    {\"nine\", 9}\n};\n\n#define GTABLE_SIZE (sizeof(gTable) / sizeof(gTable[0]))\n\nint match(char *pattern) {\n    for (int i = 0; i < GTABLE_SIZE; i++) {\n        if (!strncmp(gTable[i].str, pattern, strlen(gTable[i].str))) {\n            return gTable[i].i;\n        }\n    }\n    return -1;\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n        return 1;\n    }\n\n    FILE *fptr;\n    fptr = fopen(argv[1], \"r\");\n    if (fptr == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char line[1028];\n    int sum = 0;\n\n    while (fgets(line, sizeof(line), fptr)) {\n        line[strcspn(line, \"\\n\")] = 0;\n        printf(\"Processing line: %s\\n\", line);\n\n        int left = -1;\n        int right = -1;\n\n        for (int i = 0; i < strlen(line); i++) {\n            int current_digit = -1;\n\n            if (isdigit(line[i])) {\n                current_digit = line[i] - '0';\n            } else {\n                int matched_word_value = match(&line[i]);\n                if (matched_word_value != -1) {\n                    current_digit = matched_word_value;\n                }\n            }\n\n            if (current_digit != -1) {\n                if (left == -1) {\n                    left = current_digit;\n                }\n                right = current_digit;\n            }\n        }\n\n        if (left != -1) {\n            int calibration_value = left * 10 + right;\n            printf(\"Extracted Calibration Value: %d\\n\", calibration_value);\n            sum += calibration_value;\n        } else {\n            printf(\"No valid digits (numeric or word) found in this line.\\n\");\n        }\n    }\n\n    printf(\"Final Sum of Calibration Values: %d \\n\", sum);\n\n    fclose(fptr);\n    return 0;\n}\n```\n\n\n",
          "excerpt": "Solutions and notes for Day 1 of the Advent of Code 2023 programming challenge covering both parts of the puzzle.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-07-24T07:13:22.000Z"
        },
        {
          "id": "101-advent-of-code-2023-day-2-md",
          "slug": "101-advent-of-code/2023/day-2",
          "filepath": "101-ADVENT OF CODE/2023/Day 2.md",
          "folder": "101-ADVENT OF CODE/2023",
          "filename": "Day 2.md",
          "frontmatter": {
            "title": "Day 2",
            "date": "2025-08-17",
            "tags": [
              "advent-of-code",
              "aoc-2023",
              "programming-challenge",
              "puzzle-solving",
              "coding",
              "algorithms"
            ],
            "category": "101-ADVENT OF CODE/2023",
            "description": "Progress and solutions for Day 2 of the Advent of Code 2023 programming challenge, covering both Part 1 and Part 2."
          },
          "content": "\n### PART 1\n\n```c\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n// Define a struct to hold the maximum allowed cube counts for the entire game\ntypedef struct {\n  int red;\n  int green;\n  int blue;\n} CubeLimits;\n\n// Define a struct to hold the current cube counts observed within a single set\ntypedef struct {\n  int red;\n  int green;\n  int blue;\n} CurrentSetCubes;\n\nint process_set(char *set_str, const CubeLimits *limits) {\n  char *color_token;\n  char *rest_of_colors_ptr; // For strtok_r state\n\n  // Initialize current cube counts for this set to zero\n  CurrentSetCubes current_cubes = {0, 0, 0};\n\n  // Tokenize the set string by commas to get individual color-count pairs\n  color_token = strtok_r(set_str, \",\", &rest_of_colors_ptr);\n  while (color_token != NULL) {\n    int count = 0;\n    char color_name[10]; // To store \"red\", \"blue\", \"green\"\n\n    // Trim leading whitespace from color_token (e.g., \" 3 blue\" -> \"3 blue\")\n    while (*color_token == ' ') {\n      color_token++;\n    }\n\n    // Parse the count and color name from the token\n    if (sscanf(color_token, \"%d %s\", &count, color_name) == 2) {\n      // Accumulate the counts into the CurrentSetCubes struct\n      if (strcmp(color_name, \"red\") == 0) {\n        current_cubes.red += count;\n      } else if (strcmp(color_name, \"green\") == 0) {\n        current_cubes.green += count;\n      } else if (strcmp(color_name, \"blue\") == 0) {\n        current_cubes.blue += count;\n      }\n      // Note: No 'else' for unrecognized colors, they are ignored as per AoC\n      // problem\n    }\n    // Get the next color-count pair\n    color_token = strtok_r(NULL, \",\", &rest_of_colors_ptr);\n  }\n\n  // After accumulating all counts for this set, check against the limits\n  if (current_cubes.red > limits->red || current_cubes.green > limits->green ||\n      current_cubes.blue > limits->blue) {\n    return 0; // This set is impossible because one or more colors exceed limits\n  }\n\n  return 1; // All accumulated counts in this set are within limits, so the set\n            // is possible\n}\n\nint is_game_possible(char *sets_string, int game_id, const CubeLimits *limits) {\n  char *set_token;\n  char *rest_of_sets_ptr; // For strtok_r state\n  // Tokenize the sets string by semicolons to get individual sets\n  set_token = strtok_r(sets_string, \";\", &rest_of_sets_ptr);\n  while (set_token != NULL) {\n    // Process each set and check if it's possible\n    if (!process_set(set_token, limits)) { // Pass limits to process_set\n      // If any set is impossible, the entire game is impossible\n      return 0;\n    }\n    // Get the next set\n    set_token = strtok_r(NULL, \";\", &rest_of_sets_ptr);\n  }\n  return 1; // All sets in the game are possible, so the game is possible\n}\n\nchar *parse_game_line(char *line_copy, int *game_id_out) {\n  char *token;\n  char *game_id_end_ptr; // For strtok_r state\n  // Extract the \"Game X\" part\n  token = strtok_r(line_copy, \":\", &game_id_end_ptr);\n  if (token == NULL) {\n    return NULL; // Error: No game ID part found\n  }\n\n  // Skip \"Game \" and convert the rest to an integer\n  *game_id_out = atoi(token + strlen(\"Game \"));\n\n  // Get the rest of the string containing the sets\n  // Using an empty string as delimiter for strtok_r effectively gets the rest\n  // of the string\n  return strtok_r(NULL, \"\", &game_id_end_ptr);\n}\n\nint main() {\n  FILE *file;\n  char line[512]; // Assuming a max line length of 511 characters + null\n                  // terminator\n  int sum_of_possible_game_ids = 0;\n\n  // Initialize the CubeLimits struct with the maximum allowed values\n  CubeLimits max_limits = {.red = 12, .green = 13, .blue = 14};\n\n  // Open the input file\n  // Ensure 'input.txt' is in the same directory as your compiled executable\n  file = fopen(\"input.txt\", \"r\");\n  if (file == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  // Read the file line by line\n  while (fgets(line, sizeof(line), file) != NULL) {\n    // Remove trailing newline character if present\n    line[strcspn(line, \"\\n\")] = 0;\n\n    // Create a mutable copy of the line for strtok_r to modify\n    char *line_copy = strdup(line);\n    if (line_copy == NULL) {\n      perror(\"Failed to duplicate line\");\n      fclose(file);\n      return 1;\n    }\n\n    int game_id = 0;\n    char *sets_string = NULL;\n\n    // Parse the game line to get ID and sets string\n    sets_string = parse_game_line(line_copy, &game_id);\n\n    if (sets_string == NULL) {\n      fprintf(stderr, \"Error parsing line: %s\\n\", line);\n      free(line_copy);\n      continue; // Skip to the next line\n    }\n\n    // Check if the entire game is possible based on its sets, passing the\n    // limits\n    if (is_game_possible(sets_string, game_id, &max_limits)) {\n      sum_of_possible_game_ids += game_id;\n    }\n\n    free(line_copy); // Free the duplicated line for the current iteration\n  }\n\n  fclose(file); // Close the file after processing all lines\n\n  printf(\"Sum of IDs of possible games: %d\\n\", sum_of_possible_game_ids);\n\n  return 0;\n}\n\n```\n\n### Part 2\n```c\n\n#include <stdio.h>\n#include <stdlib.h> // For atoi, strdup, free\n#include <string.h>\n\n// Define a struct to hold the cube counts observed within a single set\ntypedef struct {\n  int red;\n  int green;\n  int blue;\n} SetCubes; // Renamed from CurrentSetCubes for clarity in Part B context\n\n// Define a struct to hold the minimum required cube counts for the entire game\n// In Part B, this stores the maximum observed count for each color across all\n// sets\ntypedef struct {\n  int red;\n  int green;\n  int blue;\n} GameMinCubes;\n\n/**\n * @brief Processes a single set of cubes (e.g., \"3 blue, 4 red\") and returns\n * the counts.\n *\n * This function tokenizes the set string by commas to get individual\n * color-count pairs. It accumulates the counts for red, green, and blue into a\n * SetCubes struct.\n *\n * @param set_str The string representing a single set of cubes. This string\n * will be modified.\n * @return A SetCubes struct containing the accumulated counts for this set.\n */\nSetCubes process_set(char *set_str) {\n  char *color_token;\n  char *rest_of_colors_ptr; // For strtok_r state\n\n  // Initialize current cube counts for this set to zero\n  SetCubes current_set_cubes = {0, 0, 0};\n\n  // Tokenize the set string by commas to get individual color-count pairs\n  color_token = strtok_r(set_str, \",\", &rest_of_colors_ptr);\n  while (color_token != NULL) {\n    int count = 0;\n    char color_name[10]; // To store \"red\", \"blue\", \"green\"\n\n    // Trim leading whitespace from color_token (e.g., \" 3 blue\" -> \"3 blue\")\n    while (*color_token == ' ') {\n      color_token++;\n    }\n\n    // Parse the count and color name from the token\n    if (sscanf(color_token, \"%d %s\", &count, color_name) == 2) {\n      // Accumulate the counts into the SetCubes struct\n      if (strcmp(color_name, \"red\") == 0) {\n        current_set_cubes.red += count;\n      } else if (strcmp(color_name, \"green\") == 0) {\n        current_set_cubes.green += count;\n      } else if (strcmp(color_name, \"blue\") == 0) {\n        current_set_cubes.blue += count;\n      }\n      // Note: No 'else' for unrecognized colors, they are ignored as per AoC\n      // problem\n    }\n    // Get the next color-count pair\n    color_token = strtok_r(NULL, \",\", &rest_of_colors_ptr);\n  }\n\n  return current_set_cubes;\n}\n\n/**\n * @brief Calculates the \"power\" of a game for Advent of Code Day 2 Part B.\n *\n * The power is the product of the minimum number of red, green, and blue cubes\n * required for the game to be possible. This means finding the maximum count\n * for each color across all sets in the game.\n *\n * @param sets_string The string containing all sets for a game (e.g., \"3 blue,\n * 4 red; 1 red, ...\").\n * @param game_id The ID of the current game (used for error\n * reporting/debugging).\n * @return The power of the game (min_red * min_green * min_blue).\n */\nlong long calculate_game_power(char *sets_string, int game_id) {\n  char *set_token;\n  char *rest_of_sets_ptr; // For strtok_r state\n\n  // Initialize minimum required cubes for the game to 0\n  // These will store the maximum observed count for each color across all sets\n  GameMinCubes min_required_cubes = {0, 0, 0};\n\n  // Tokenize the sets string by semicolons to get individual sets\n  set_token = strtok_r(sets_string, \";\", &rest_of_sets_ptr);\n  while (set_token != NULL) {\n    // Process each set to get its cube counts\n    SetCubes current_set_cubes = process_set(set_token);\n\n    // Update the minimum required cubes for the game if current set has higher\n    // counts This effectively finds the maximum count of each color across all\n    // sets\n    if (current_set_cubes.red > min_required_cubes.red) {\n      min_required_cubes.red = current_set_cubes.red;\n    }\n    if (current_set_cubes.green > min_required_cubes.green) {\n      min_required_cubes.green = current_set_cubes.green;\n    }\n    if (current_set_cubes.blue > min_required_cubes.blue) {\n      min_required_cubes.blue = current_set_cubes.blue;\n    }\n\n    // Get the next set\n    set_token = strtok_r(NULL, \";\", &rest_of_sets_ptr);\n  }\n\n  // Calculate the power of the game: product of the maximum observed counts\n  return (long long)min_required_cubes.red * min_required_cubes.green *\n         min_required_cubes.blue;\n}\n\n/**\n * @brief Parses a game line to extract the game ID and the sets string.\n *\n * @param line_copy A mutable copy of the full game line. This string will be\n * modified.\n * @param game_id_out Pointer to an integer where the extracted game ID will be\n * stored.\n * @return A pointer to the start of the sets string (after \"Game X:\"), or NULL\n * on error.\n */\nchar *parse_game_line(char *line_copy, int *game_id_out) {\n  char *token;\n  char *game_id_end_ptr; // For strtok_r state\n\n  // Extract the \"Game X\" part\n  token = strtok_r(line_copy, \":\", &game_id_end_ptr);\n  if (token == NULL) {\n    return NULL; // Error: No game ID part found\n  }\n\n  // Skip \"Game \" and convert the rest to an integer\n  *game_id_out = atoi(token + strlen(\"Game \"));\n\n  // Get the rest of the string containing the sets\n  // Using an empty string as delimiter for strtok_r effectively gets the rest\n  // of the string\n  return strtok_r(NULL, \"\", &game_id_end_ptr);\n}\n\nint main() {\n  FILE *file;\n  char line[512]; // Assuming a max line length of 511 characters + null\n                  // terminator\n  long long total_power_sum = 0; // Changed to long long for sum of powers\n\n  // Open the input file\n  // Ensure 'input.txt' is in the same directory as your compiled executable\n  file = fopen(\"input.txt\", \"r\");\n  if (file == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  // Read the file line by line\n  while (fgets(line, sizeof(line), file) != NULL) {\n    // Remove trailing newline character if present\n    line[strcspn(line, \"\\n\")] = 0;\n\n    // Create a mutable copy of the line for strtok_r to modify\n    char *line_copy = strdup(line);\n    if (line_copy == NULL) {\n      perror(\"Failed to duplicate line\");\n      fclose(file);\n      return 1;\n    }\n\n    int game_id = 0;\n    char *sets_string = NULL;\n\n    // Parse the game line to get ID and sets string\n    sets_string = parse_game_line(line_copy, &game_id);\n\n    if (sets_string == NULL) {\n      fprintf(stderr, \"Error parsing line: %s\\n\", line);\n      free(line_copy);\n      continue; // Skip to the next line\n    }\n\n    // Calculate the power of the current game\n    total_power_sum += calculate_game_power(sets_string, game_id);\n\n    free(line_copy); // Free the duplicated line for the current iteration\n  }\n\n  fclose(file); // Close the file after processing all lines\n\n  printf(\"Sum of the powers of all games: %lld\\n\",\n         total_power_sum); // Use %lld for long long\n\n  return 0;\n}\n\n```",
          "excerpt": "Progress and solutions for Day 2 of the Advent of Code 2023 programming challenge, covering both Part 1 and Part 2.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-08-17T11:50:15.189Z"
        },
        {
          "id": "101-advent-of-code-2023-day-4-md",
          "slug": "101-advent-of-code/2023/day-4",
          "filepath": "101-ADVENT OF CODE/2023/Day 4.md",
          "folder": "101-ADVENT OF CODE/2023",
          "filename": "Day 4.md",
          "frontmatter": {
            "title": "Day 4",
            "date": "2025-08-17",
            "tags": [
              "advent-of-code",
              "aoc2023",
              "programming",
              "puzzles",
              "coding-challenge",
              "day4"
            ],
            "category": "101-ADVENT OF CODE/2023",
            "description": "Solutions and progress for the Day 4 puzzles of the 2023 Advent of Code programming challenge."
          },
          "content": "### PART 1\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n    return 1;\n  }\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  char line[1028];\n  int total_points = 0;\n\n  while (fgets(line, sizeof(line), fptr)) {\n    line[strcspn(line, \"\\n\")] = 0;\n\n    char *line_copy = strdup(line); // Create a copy for strtok\n    if (!line_copy) {\n      // Handle memory allocation error\n      perror(\"Memory allocation failed\");\n      fclose(fptr);\n      return 1;\n    }\n\n    // Split the line into winning and my numbers strings\n    char *winning_numbers_str = strtok(line_copy, \"|\");\n    char *my_numbers_str = strtok(NULL, \"|\");\n\n    // Skip \"Card X:\" part\n    strtok(winning_numbers_str, \":\");\n    winning_numbers_str = strtok(NULL, \":\");\n\n    // Arrays to hold the numbers (assuming max 20 numbers for safety)\n    int winning_numbers[50];\n    int my_numbers[50];\n    int winning_count = 0;\n    int my_count = 0;\n\n    // Populate winning_numbers array\n    char *token = strtok(winning_numbers_str, \" \");\n    while (token != NULL) {\n      winning_numbers[winning_count++] = atoi(token);\n      token = strtok(NULL, \" \");\n    }\n\n    // Populate my_numbers array\n    token = strtok(my_numbers_str, \" \");\n    while (token != NULL) {\n      my_numbers[my_count++] = atoi(token);\n      token = strtok(NULL, \" \");\n    }\n\n    int matches_per_card = 0;\n    for (int i = 0; i < my_count; i++) {\n      for (int j = 0; j < winning_count; j++) {\n        if (my_numbers[i] == winning_numbers[j]) {\n          matches_per_card++;\n        }\n      }\n    }\n\n    int card_points = 0;\n    if (matches_per_card > 0) {\n      // card_points = (int)pow(2, matches_per_card - 1);\n      card_points = 1 << (matches_per_card - 1);\n    }\n\n    total_points += card_points;\n\n    free(line_copy);\n  }\n  fclose(fptr);\n\n  printf(\"Total points: %d\\n\", total_points);\n\n  return 0;\n}\n\n```\n\n### PART 2\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint countMatches(int *winning_numbers, int winning_count, int *my_numbers,\n                 int my_count);\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n    return 1;\n  }\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  char ch;\n  int lineCount = 0;\n  while ((ch = fgetc(fptr)) != EOF) {\n    if (ch == '\\n') {\n      lineCount++;\n    }\n  }\n  rewind(fptr); // Rewind file pointer\n\n  int cardCopies[lineCount];\n  for (int i = 0; i < lineCount; i++) {\n    cardCopies[i] = 1; // Initialize with 1 copy\n  }\n\n  char line[1028];\n\n  while (fgets(line, sizeof(line), fptr)) {\n    line[strcspn(line, \"\\n\")] = 0; // Remove newline\n\n    char *line_copy = strdup(line); // Copy for strtok\n    if (!line_copy) {\n      perror(\"Memory allocation failed\");\n      fclose(fptr);\n      return 1;\n    }\n\n    char *card_and_winning_str = strtok(line_copy, \"|\");\n    char *my_numbers_str_raw = strtok(NULL, \"|\");\n\n    char *card_part = strtok(card_and_winning_str, \":\");\n    char *winning_numbers_str_raw = strtok(NULL, \":\");\n\n    int cardIndex = -1;\n    if (card_part != NULL) {\n      char *index_str = strchr(card_part, ' ');\n      if (index_str != NULL && *(index_str + 1) != '\\0') {\n        index_str++;\n        cardIndex = atoi(index_str);\n      }\n    }\n\n    if (cardIndex == -1 || cardIndex < 1 || cardIndex > lineCount) {\n      fprintf(stderr, \"Error: Invalid card index %d\\n\", cardIndex);\n      free(line_copy);\n      fclose(fptr);\n      return 1;\n    }\n    int currentCardArrayIndex = cardIndex - 1; // 0-based index\n\n    int winning_numbers_arr[50];\n    int my_numbers_arr[50];\n    int winning_count = 0;\n    int my_count = 0;\n\n    // Copies for independent strtok parsing\n    char *winning_numbers_copy_for_parsing = NULL;\n    if (winning_numbers_str_raw != NULL) {\n      winning_numbers_copy_for_parsing = strdup(winning_numbers_str_raw);\n      if (!winning_numbers_copy_for_parsing) {\n        perror(\"Memory allocation failed\");\n        free(line_copy);\n        fclose(fptr);\n        return 1;\n      }\n    }\n\n    char *my_numbers_copy_for_parsing = NULL;\n    if (my_numbers_str_raw != NULL) {\n      my_numbers_copy_for_parsing = strdup(my_numbers_str_raw);\n      if (!my_numbers_copy_for_parsing) {\n        perror(\"Memory allocation failed\");\n        free(line_copy);\n        free(winning_numbers_copy_for_parsing);\n        fclose(fptr);\n        return 1;\n      }\n    }\n\n    char *token = strtok(winning_numbers_copy_for_parsing, \" \");\n    while (token != NULL && winning_count < 50) {\n      if (strlen(token) > 0) {\n        winning_numbers_arr[winning_count++] = atoi(token);\n      }\n      token = strtok(NULL, \" \");\n    }\n\n    token = strtok(my_numbers_copy_for_parsing, \" \");\n    while (token != NULL && my_count < 50) {\n      if (strlen(token) > 0) {\n        my_numbers_arr[my_count++] = atoi(token);\n      }\n      token = strtok(NULL, \" \");\n    }\n\n    int matches = countMatches(winning_numbers_arr, winning_count,\n                               my_numbers_arr, my_count);\n\n    int num_current_card_copies = cardCopies[currentCardArrayIndex];\n\n    for (int i = 1; i <= matches; i++) {\n      if (currentCardArrayIndex + i < lineCount) {\n        cardCopies[currentCardArrayIndex + i] += num_current_card_copies;\n      }\n    }\n\n    // Free duplicated strings\n    free(line_copy);\n    free(winning_numbers_copy_for_parsing);\n    free(my_numbers_copy_for_parsing);\n  }\n  fclose(fptr);\n\n  int total_cards_part2 = 0;\n  for (int i = 0; i < lineCount; i++) {\n    total_cards_part2 += cardCopies[i];\n  }\n  printf(\"Total : %d\\n\", total_cards_part2);\n\n  return 0;\n}\n\nint countMatches(int *winning_numbers, int winning_count, int *my_numbers,\n                 int my_count) {\n  int matches = 0;\n  for (int i = 0; i < winning_count; i++) {\n    for (int j = 0; j < my_count; j++) {\n      if (winning_numbers[i] == my_numbers[j]) {\n        matches++;\n      }\n    }\n  }\n  return matches;\n}\n\n```",
          "excerpt": "Solutions and progress for the Day 4 puzzles of the 2023 Advent of Code programming challenge.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-08-17T11:51:00.530Z"
        },
        {
          "id": "101-advent-of-code-2023-day-5-md",
          "slug": "101-advent-of-code/2023/day-5",
          "filepath": "101-ADVENT OF CODE/2023/Day 5.md",
          "folder": "101-ADVENT OF CODE/2023",
          "filename": "Day 5.md",
          "frontmatter": {
            "title": "Day 5",
            "date": "2025-08-17",
            "tags": [
              "advent-of-code",
              "aoc-2023",
              "coding-challenges",
              "programming",
              "puzzle-solving",
              "algorithms",
              "day-5"
            ],
            "category": "101-ADVENT OF CODE/2023",
            "description": "Progress tracking and scratchpad for the Day 5 puzzle of the Advent of Code 2023 programming challenge."
          },
          "content": "### PART 1\n```python\ndef lookup(thing, mapping):\n    \"\"\"\n    Finds the mapped value for a given 'thing' based on a list of maps.\n    \"\"\"\n    for dest_start, src_start, length in mapping:\n        if src_start <= thing < src_start + length:\n            return dest_start + (thing - src_start)\n    return thing\n\ndef parse_input_file(filepath):\n    \"\"\"\n    Parses the input file to extract seeds and all mapping tables.\n    \"\"\"\n    with open(filepath) as f:\n        data = f.read().strip()\n\n    sections = data.split('\\n\\n')\n    \n    # Parse seeds\n    seeds_line = sections[0]\n    seed_numbers = [int(num) for num in seeds_line.split(': ')[1].split()]\n    \n    # Parse maps\n    parsed_maps = []\n    for section in sections[1:]:\n        lines = section.split('\\n')[1:] # Skip the \"map:\" line\n        current_map = []\n        for line in lines:\n            current_map.append(tuple(map(int, line.split())))\n        parsed_maps.append(current_map)\n\n    return seed_numbers, parsed_maps\n\ndef main():\n    \"\"\"\n    Main function to run the optimization logic.\n    \"\"\"\n    seed_array, maps = parse_input_file(\"input.txt\")\n    print(f\"Seeds: {seed_array}\")\n\n    # The most crucial optimization: Process seeds by ranges.\n    # We no longer generate a massive list of individual seeds.\n    final_min = float('inf')\n\n    # Iterate over the seed ranges from PART B\n    for i in range(0, len(seed_array), 2):\n        start_seed = seed_array[i]\n        range_length = seed_array[i+1]\n        \n        # Iterate through each seed in the current range\n        for j in range(start_seed, start_seed + range_length):\n            current_value = j\n            for mapping in maps:\n                current_value = lookup(current_value, mapping)\n            \n            if current_value < final_min:\n                final_min = current_value\n\n    print(f\"\\nFinal minimum location: {final_min}\")\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n### PART 2\n???",
          "excerpt": "Progress tracking and scratchpad for the Day 5 puzzle of the Advent of Code 2023 programming challenge.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-08-17T11:53:40.708Z"
        },
        {
          "id": "101-advent-of-code-2023-day-6-md",
          "slug": "101-advent-of-code/2023/day-6",
          "filepath": "101-ADVENT OF CODE/2023/Day 6.md",
          "folder": "101-ADVENT OF CODE/2023",
          "filename": "Day 6.md",
          "frontmatter": {
            "title": "Day 6",
            "date": "2025-08-17",
            "tags": [
              "advent-of-code",
              "aoc2023",
              "day6",
              "coding-challenge",
              "programming",
              "puzzle-solving"
            ],
            "category": "101-ADVENT OF CODE/2023",
            "description": "Progress and solution notes for Part 1 of the Day 6 puzzle from Advent of Code 2023."
          },
          "content": "### PART 1\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n  long int time = 48876981;\n  long int distance = 255128811171623;\n\n  int count = 0;\n  for (long int j = 0; j <= time; j++) {\n    long int mydist = j * (time - j);\n    if (mydist > distance)\n      count++;\n  }\n\n  printf(\"%d \\n\", count);\n  return 0;\n}\n```",
          "excerpt": "Progress and solution notes for Part 1 of the Day 6 puzzle from Advent of Code 2023.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-08-17T11:53:28.361Z"
        },
        {
          "id": "101-advent-of-code-2023-day-7-md",
          "slug": "101-advent-of-code/2023/day-7",
          "filepath": "101-ADVENT OF CODE/2023/Day 7.md",
          "folder": "101-ADVENT OF CODE/2023",
          "filename": "Day 7.md",
          "frontmatter": {
            "title": "Day 7",
            "date": "2025-08-17",
            "tags": [
              "adventofcode",
              "aoc2023",
              "programming",
              "puzzles",
              "codingchallenge",
              "day7"
            ],
            "category": "101-ADVENT OF CODE/2023",
            "description": "Solutions and progress for Day 7 of the Advent of Code 2023 programming challenge."
          },
          "content": "### PART 1\n```c\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DELIMITERS \" \"\n#define EXCEPTION_FORMAT \"Error: Format.\\n\"\n#define HAND_SIZE 5\n#define PLAYER_LIST_CAPACITY 1024\n\nenum Card {\n  CARD_TWO,\n  CARD_THREE,\n  CARD_FOUR,\n  CARD_FIVE,\n  CARD_SIX,\n  CARD_SEVEN,\n  CARD_EIGHT,\n  CARD_NINE,\n  CARD_TEN,\n  CARD_JACK,\n  CARD_QUEEN,\n  CARD_KING,\n  CARD_ACE,\n  CARD_NONE\n};\nstruct Hand {\n  int frequency[CARD_NONE];\n  int count;\n  int max_frequency;\n};\n\nenum HandType {\n  HAND_TYPE_HIGH_CARD,\n  HAND_TYPE_ONE_PAIR,\n  HAND_TYPE_TWO_PAIR,\n  HAND_TYPE_THREE_OF_A_KIND,\n  HAND_TYPE_FULL_HOUSE,\n  HAND_TYPE_FOUR_OF_A_KIND,\n  HAND_TYPE_FIVE_OF_A_KIND,\n  HAND_TYPE_NONE\n};\n\nstruct Player {\n  enum Card cards[HAND_SIZE];\n  enum HandType handType;\n  int bid;\n};\n\nstruct PlayerList {\n  struct Player items[PLAYER_LIST_CAPACITY];\n  int count;\n};\n\ntypedef const void *Object;\ntypedef char *String;\ntypedef enum Card Card;\ntypedef enum HandType HandType;\ntypedef struct Hand *Hand;\ntypedef struct Player *Player;\ntypedef struct PlayerList *PlayerList;\n\nCard getCardFromString(char symbol) {\n  switch (symbol) {\n  case '2':\n    return CARD_TWO;\n  case '3':\n    return CARD_THREE;\n  case '4':\n    return CARD_FOUR;\n  case '5':\n    return CARD_FIVE;\n  case '6':\n    return CARD_SIX;\n  case '7':\n    return CARD_SEVEN;\n  case '8':\n    return CARD_EIGHT;\n  case '9':\n    return CARD_NINE;\n  case 'T':\n    return CARD_TEN;\n  case 'J':\n    return CARD_JACK;\n  case 'Q':\n    return CARD_QUEEN;\n  case 'K':\n    return CARD_KING;\n  case 'A':\n    return CARD_ACE;\n  default:\n    return CARD_NONE; // Invalid card\n  }\n}\n\nHandType hand_get_type(Hand hand) {\n  if (hand->max_frequency == 5) {\n    return HAND_TYPE_FIVE_OF_A_KIND;\n  } else if (hand->max_frequency == 4) {\n    return HAND_TYPE_FOUR_OF_A_KIND;\n  } else if (hand->max_frequency == 3 && hand->count == 2) {\n    return HAND_TYPE_FULL_HOUSE;\n  } else if (hand->max_frequency == 3) {\n    return HAND_TYPE_THREE_OF_A_KIND;\n  } else if (hand->max_frequency == 2 && hand->count == 3) {\n    return HAND_TYPE_TWO_PAIR;\n  } else if (hand->max_frequency == 2) {\n    return HAND_TYPE_ONE_PAIR;\n  } else {\n    return HAND_TYPE_HIGH_CARD;\n  }\n}\n\nint player_compare(Object left, Object right) {\n  if (!left && !right) {\n    return 0;\n  }\n\n  if (!left) {\n    return -1;\n  }\n\n  if (!right) {\n    return 1;\n  }\n\n  const struct Player *leftPlayer = left;\n  const struct Player *rightPlayer = right;\n  int handDifference = rightPlayer->handType - leftPlayer->handType;\n\n  if (handDifference) {\n    return handDifference;\n  }\n\n  for (int i = 0; i < HAND_SIZE; i++) {\n    int cardDifference = rightPlayer->cards[i] - leftPlayer->cards[i];\n    if (cardDifference) {\n      return cardDifference;\n    }\n  }\n\n  return 0;\n}\n\nvoid player_list_sort(PlayerList instance) {\n  qsort(instance->items, instance->count, sizeof *instance->items,\n        player_compare);\n}\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n    return 1;\n  }\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  char line[1028];\n\n  struct PlayerList players;\n  players.count = 0;\n\n  while (fgets(line, sizeof(line), fptr)) {\n\n    String cards = strtok(line, \" \");\n    char *bid = strtok(NULL, \" \");\n\n    struct Hand hand = {0};\n    Player player = players.items + players.count;\n    players.count++;\n\n    for (int i = 0; i < HAND_SIZE; i++) {\n      Card drawnCard = getCardFromString(cards[i]);\n      if (drawnCard == CARD_NONE) {\n        fprintf(stderr, EXCEPTION_FORMAT);\n        fclose(fptr);\n        return 1;\n      }\n      // hand add\n      int frequency = hand.frequency[drawnCard];\n      if (!frequency) {\n        hand.count++;\n      }\n      frequency++;\n\n      hand.frequency[drawnCard] = frequency;\n\n      if (frequency > hand.max_frequency) {\n        hand.max_frequency = frequency;\n      }\n\n      player->cards[i] = drawnCard;\n    }\n\n    HandType handType = hand_get_type(&hand);\n\n    if (!bid || handType == HAND_TYPE_NONE) {\n      fprintf(stderr, EXCEPTION_FORMAT);\n\n      return 1;\n    }\n    player->handType = handType;\n    player->bid = atoi(bid);\n  }\n\n  player_list_sort(&players);\n  long sum = 0;\n\n  for (int i = 0; i < players.count; i++) {\n    sum += (players.count - i) * players.items[i].bid;\n  }\n\n  printf(\"%ld\\n\", sum);\n  return 0;\n}\n\n```\n\n### PART 2\n```c\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define EXCEPTION_FORMAT \"Error: Format.\\n\"\n#define HAND_SIZE 5\n#define PLAYER_LIST_CAPACITY 1024\n\nenum Card {\n  CARD_JOKER,\n  CARD_TWO,\n  CARD_THREE,\n  CARD_FOUR,\n  CARD_FIVE,\n  CARD_SIX,\n  CARD_SEVEN,\n  CARD_EIGHT,\n  CARD_NINE,\n  CARD_TEN,\n  CARD_QUEEN,\n  CARD_KING,\n  CARD_ACE,\n  CARD_NONE\n};\nstruct Hand {\n  int frequency[CARD_NONE];\n  int count;\n  int max_frequency;\n};\n\nenum HandType {\n  HAND_TYPE_HIGH_CARD,\n  HAND_TYPE_ONE_PAIR,\n  HAND_TYPE_TWO_PAIR,\n  HAND_TYPE_THREE_OF_A_KIND,\n  HAND_TYPE_FULL_HOUSE,\n  HAND_TYPE_FOUR_OF_A_KIND,\n  HAND_TYPE_FIVE_OF_A_KIND,\n  HAND_TYPE_NONE\n};\n\nstruct Player {\n  enum Card cards[HAND_SIZE];\n  enum HandType handType;\n  int bid;\n};\n\nstruct PlayerList {\n  struct Player items[PLAYER_LIST_CAPACITY];\n  int count;\n};\n\ntypedef const void *Object;\ntypedef char *String;\ntypedef enum Card Card;\ntypedef enum HandType HandType;\ntypedef struct Hand *Hand;\ntypedef struct Player *Player;\ntypedef struct PlayerList *PlayerList;\n\nCard getCardFromString(char symbol) {\n  switch (symbol) {\n  case '2':\n    return CARD_TWO;\n  case '3':\n    return CARD_THREE;\n  case '4':\n    return CARD_FOUR;\n  case '5':\n    return CARD_FIVE;\n  case '6':\n    return CARD_SIX;\n  case '7':\n    return CARD_SEVEN;\n  case '8':\n    return CARD_EIGHT;\n  case '9':\n    return CARD_NINE;\n  case 'T':\n    return CARD_TEN;\n  case 'J':\n    return CARD_JOKER;\n  case 'Q':\n    return CARD_QUEEN;\n  case 'K':\n    return CARD_KING;\n  case 'A':\n    return CARD_ACE;\n  default:\n    return CARD_NONE; // Invalid card\n  }\n}\n\nHandType hand_get_type(Hand hand) {\n  int jokers = hand->frequency[CARD_JOKER];\n\n  // Find the highest frequency among non-joker cards.\n  int max_freq_no_jokers = 0;\n  for (int i = 0; i < CARD_NONE; i++) {\n    if (i == CARD_JOKER)\n      continue;\n    if (hand->frequency[i] > max_freq_no_jokers) {\n      max_freq_no_jokers = hand->frequency[i];\n    }\n  }\n\n  // The best possible group size is the max frequency of any card plus the\n  // number of jokers.\n  int effective_max_freq = max_freq_no_jokers + jokers;\n\n  if (effective_max_freq == 5) {\n    return HAND_TYPE_FIVE_OF_A_KIND;\n  }\n  if (effective_max_freq == 4) {\n    return HAND_TYPE_FOUR_OF_A_KIND;\n  }\n\n  // If we have jokers, they will merge with another group, reducing the number\n  // of distinct card groups.\n  int distinct_groups = hand->count;\n  if (jokers > 0) {\n    distinct_groups--;\n  }\n\n  if (effective_max_freq == 3) {\n    // A group of 3 and a group of 2 (e.g., KKKQQ or T55J5).\n    if (distinct_groups == 2) {\n      return HAND_TYPE_FULL_HOUSE;\n    }\n    // A group of 3 and two singles (e.g., KKKQJ).\n    return HAND_TYPE_THREE_OF_A_KIND;\n  }\n\n  if (effective_max_freq == 2) {\n    // Two groups of 2 (e.g., KKQQJ).\n    if (distinct_groups == 3) {\n      return HAND_TYPE_TWO_PAIR;\n    }\n    // One group of 2 (e.g., KKQJ2).\n    return HAND_TYPE_ONE_PAIR;\n  }\n\n  return HAND_TYPE_HIGH_CARD;\n}\n\nint player_compare(Object left, Object right) {\n  if (!left && !right) {\n    return 0;\n  }\n\n  if (!left) {\n    return -1;\n  }\n\n  if (!right) {\n    return 1;\n  }\n\n  const struct Player *leftPlayer = left;\n  const struct Player *rightPlayer = right;\n  int handDifference = rightPlayer->handType - leftPlayer->handType;\n\n  if (handDifference) {\n    return handDifference;\n  }\n\n  for (int i = 0; i < HAND_SIZE; i++) {\n    int cardDifference = rightPlayer->cards[i] - leftPlayer->cards[i];\n\n    if (cardDifference) {\n      return cardDifference;\n    }\n  }\n\n  return 0;\n}\n\nvoid player_list_sort(PlayerList instance) {\n  qsort(instance->items, instance->count, sizeof *instance->items,\n        player_compare);\n}\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n    return 1;\n  }\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  char line[1028];\n\n  struct PlayerList players;\n  players.count = 0;\n\n  while (fgets(line, sizeof(line), fptr)) {\n\n    String cards = strtok(line, \" \");\n    char *bid = strtok(NULL, \" \");\n\n    struct Hand hand = {0};\n    Player player = players.items + players.count;\n    players.count++;\n\n    for (int i = 0; i < HAND_SIZE; i++) {\n      Card drawnCard = getCardFromString(cards[i]);\n      if (drawnCard == CARD_NONE) {\n        fprintf(stderr, EXCEPTION_FORMAT);\n        fclose(fptr);\n        return 1;\n      }\n      // hand add\n      int frequency = hand.frequency[drawnCard];\n      if (!frequency) {\n        hand.count++;\n      }\n      frequency++;\n\n      hand.frequency[drawnCard] = frequency;\n\n      if (frequency > hand.max_frequency) {\n        hand.max_frequency = frequency;\n      }\n\n      player->cards[i] = drawnCard;\n    }\n\n    HandType handType = hand_get_type(&hand);\n\n    if (!bid || handType == HAND_TYPE_NONE) {\n      fprintf(stderr, EXCEPTION_FORMAT);\n\n      return 1;\n    }\n    player->handType = handType;\n    player->bid = atoi(bid);\n  }\n\n  player_list_sort(&players);\n  long sum = 0;\n\n  for (int i = 0; i < players.count; i++) {\n    sum += (players.count - i) * players.items[i].bid;\n  }\n\n  printf(\"%ld\\n\", sum);\n  return 0;\n}\n\n```",
          "excerpt": "Solutions and progress for Day 7 of the Advent of Code 2023 programming challenge.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-08-17T11:54:23.464Z"
        },
        {
          "id": "101-advent-of-code-2023-day-8-md",
          "slug": "101-advent-of-code/2023/day-8",
          "filepath": "101-ADVENT OF CODE/2023/Day 8.md",
          "folder": "101-ADVENT OF CODE/2023",
          "filename": "Day 8.md",
          "frontmatter": {
            "title": "Day 8",
            "date": "2025-08-17",
            "tags": [
              "advent-of-code",
              "aoc-2023",
              "coding-challenge",
              "puzzles",
              "algorithms",
              "day-8"
            ],
            "category": "101-ADVENT OF CODE/2023",
            "description": "Solutions and progress for the Day 8 challenge of the 2023 Advent of Code programming event."
          },
          "content": "### PART 1\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Define a struct to hold the key and the two values\ntypedef struct {\n  char key[4];\n  char left[4];\n  char right[4];\n} Node;\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n    return 1;\n  }\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  char line[1028];\n  Node *map = NULL;\n  int num_nodes = 0;\n\n  // Read and store the direction line (first line)\n  char *token = fgets(line, sizeof(line), fptr);\n  if (token) {\n    line[strcspn(line, \"\\n\")] = 0; // Remove trailing newline\n    printf(\"Direction: %s\\n\", line);\n  }\n  char *direction = malloc(1024 * sizeof(char));\n  strcpy(direction, token);\n\n  // Skip the empty line\n  fgets(line, sizeof(line), fptr);\n\n  // Loop through the rest of the lines and parse them\n  while (fgets(line, sizeof(line), fptr)) {\n    if (line[0] == '\\n') {\n      continue; // Skip any empty lines\n    }\n\n    // Dynamically resize the array to store the new node\n    map = realloc(map, sizeof(Node) * (num_nodes + 1));\n    if (map == NULL) {\n      perror(\"Memory allocation failed\");\n      fclose(fptr);\n      // Free any previously allocated memory\n      for (int i = 0; i < num_nodes; i++) {\n        free(map);\n      }\n      return 1;\n    }\n\n    // Use a comprehensive set of delimiters\n    char *key_token = strtok(line, \" =(),\\n\");\n    char *left_token = strtok(NULL, \" =(),\\n\");\n    char *right_token = strtok(NULL, \" =(),\\n\");\n\n    // Ensure all three parts are found before storing\n    if (key_token && left_token && right_token) {\n      strcpy(map[num_nodes].key, key_token);\n      strcpy(map[num_nodes].left, left_token);\n      strcpy(map[num_nodes].right, right_token);\n      num_nodes++;\n    }\n  }\n\n  char *current = \"AAA\";\n  int j = 0;\n  int steps = 0;\n  // char currentDir = direction[j];\n  // printf(\"%c\\n\", currentDir);\n  while (strcmp(current, \"ZZZ\") != 0) {\n    for (int i = 0; i < num_nodes; i++) {\n      if (strcmp(map[i].key, current) == 0) {\n\n        if (j >= strlen(direction)) {\n          j = 0;\n        }\n        char currentDir = direction[j];\n\n        if (currentDir == 'L') {\n          current = map[i].left;\n        } else if (currentDir == 'R') {\n          current = map[i].right;\n        }\n        j++;\n        steps++;\n        printf(\"%d\\n\", steps);\n        break;\n      }\n    }\n  }\n  printf(\"Steps: %d\\n\", steps);\n  fclose(fptr);\n\n  // Clean up dynamically allocated memory\n  free(map);\n\n  return 0;\n}\n****\n```\n### PART 2\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Define a struct to hold the key and the two values\ntypedef struct {\n  char key[4];\n  char left[4];\n  char right[4];\n} Node;\n\n// FIND NODE\nNode *find_node(Node *map, int num_nodes, const char *key) {\n  for (int i = 0; i < num_nodes; i++) {\n    if (strcmp(map[i].key, key) == 0) {\n      return &map[i];\n    }\n  }\n  return NULL;\n}\n\nlong long gcd(long long a, long long b) {\n  while (b) {\n    long long temp = a % b;\n    a = b;\n    b = temp;\n  }\n  return a;\n}\n\nlong long lcm(long long a, long long b) {\n  if (a == 0 || b == 0)\n    return 0;\n  return (a * b) / gcd(a, b);\n}\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n    return 1;\n  }\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  char line[1028];\n  Node *map = NULL;\n  int num_nodes = 0;\n  char direction[1024];\n\n  if (fgets(line, sizeof(line), fptr)) {\n    line[strcspn(line, \"\\n\")] = 0;\n    strcpy(direction, line);\n  } else {\n    fclose(fptr);\n    return 1;\n  }\n\n  fgets(line, sizeof(line), fptr);\n\n  // Loop through the rest of the lines and parse them\n  while (fgets(line, sizeof(line), fptr)) {\n    if (line[0] == '\\n')\n      continue;\n\n    map = realloc(map, sizeof(Node) * (num_nodes + 1));\n    if (map == NULL) {\n      perror(\"Memory allocation failed\");\n      fclose(fptr);\n      free(map);\n      return 1;\n    }\n\n    char *key_token = strtok(line, \" =(),\\n\");\n    char *left_token = strtok(NULL, \" =(),\\n\");\n    char *right_token = strtok(NULL, \" =(),\\n\");\n\n    if (key_token && left_token && right_token) {\n      strcpy(map[num_nodes].key, key_token);\n      strcpy(map[num_nodes].left, left_token);\n      strcpy(map[num_nodes].right, right_token);\n      num_nodes++;\n    }\n  }\n  fclose(fptr);\n\n  // 1. Find all starting nodes (ending with 'A')\n  const char *start_nodes[num_nodes];\n  int num_start_nodes = 0;\n  for (int i = 0; i < num_nodes; i++) {\n    if (map[i].key[2] == 'A') {\n      start_nodes[num_start_nodes++] = map[i].key;\n    }\n  }\n\n  long long steps_to_z[num_start_nodes];\n  int direction_length = strlen(direction);\n\n  // 2. Calculate steps for each path to reach a 'Z' ending node\n  for (int i = 0; i < num_start_nodes; i++) {\n    const char *current_key = start_nodes[i];\n    long long steps = 0;\n\n    while (current_key[2] != 'Z') {\n      Node *current_node = find_node(map, num_nodes, current_key);\n      if (!current_node) {\n        fprintf(stderr, \"Error: Node '%s' not found!\\n\", current_key);\n        break;\n      }\n\n      char current_dir = direction[steps % direction_length];\n\n      if (current_dir == 'L') {\n        current_key = current_node->left;\n      } else if (current_dir == 'R') {\n        current_key = current_node->right;\n      }\n      steps++;\n    }\n    steps_to_z[i] = steps;\n  }\n\n  // 3. Find the LCM of all path lengths\n  long long total_steps = steps_to_z[0];\n  for (int i = 1; i < num_start_nodes; i++) {\n    total_steps = lcm(total_steps, steps_to_z[i]);\n  }\n\n  printf(\"Total steps to reach all 'Z' nodes simultaneously: %lld\\n\",\n         total_steps);\n\n  free(map);\n\n  return 0;\n}\n\n```",
          "excerpt": "Solutions and progress for the Day 8 challenge of the 2023 Advent of Code programming event.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-08-17T11:55:09.641Z"
        },
        {
          "id": "101-advent-of-code-2023-day-10-md",
          "slug": "101-advent-of-code/2023/day-10",
          "filepath": "101-ADVENT OF CODE/2023/Day 10.md",
          "folder": "101-ADVENT OF CODE/2023",
          "filename": "Day 10.md",
          "frontmatter": {
            "title": "Day 10",
            "date": "2025-08-17",
            "tags": [
              "advent-of-code",
              "aoc-2023",
              "day-10",
              "pipe-maze",
              "algorithms",
              "coding-challenge"
            ],
            "category": "101-ADVENT OF CODE/2023",
            "description": "Implementation and notes for Part 1 of the Day 10 Pipe Maze puzzle from the 2023 Advent of Code challenge."
          },
          "content": "### PART 1\n```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_DIM 200\n\ntypedef struct {\n  int x;\n  int y;\n} Point;\n\n// QUEUE IMPLIMENTATION\n\nPoint queue[MAX_DIM * MAX_DIM];\nint front = 0;\nint rear = -1;\nint queue_size = 0;\n\nvoid enqueue(Point p) {\n  rear = (rear + 1) % (MAX_DIM * MAX_DIM);\n  queue[rear] = p;\n  queue_size++;\n}\n\nPoint dequeue() {\n  Point p = queue[front];\n  front = (front + 1) % (MAX_DIM * MAX_DIM);\n  queue_size--;\n  return p;\n}\nint is_queue_empty() { return queue_size == 0; }\n\nint main(int argc, char *argv[]) {\n  char grid[MAX_DIM][MAX_DIM];\n  int visited[MAX_DIM][MAX_DIM] = {0};\n  int num_rows = 0, num_cols = 0;\n\n  if (argc < 2) {\n    fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n    return 1;\n  }\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  while (fgets(grid[num_rows], MAX_DIM, fptr) != NULL) {\n    grid[num_rows][strcspn(grid[num_rows], \"\\n\")] =\n        '\\0'; // Remove newline character\n    if (num_cols == 0) {\n      num_cols = strlen(grid[num_rows]);\n    }\n    num_rows++;\n  }\n  fclose(fptr);\n\n  int start_x = -1, start_y = -1;\n\n  for (int i = 0; i < num_rows; i++) {\n    for (int j = 0; j < num_cols; j++) {\n      if (grid[i][j] == 'S') {\n        start_x = j;\n        start_y = i;\n        break;\n      }\n    }\n    if (start_y != -1)\n      break;\n  }\n  // BFS\n  Point start = {start_x, start_y};\n  enqueue(start);\n  visited[start_y][start_x] = 1;\n  int loop_count = 0;\n\n  while (!is_queue_empty()) {\n    Point current = dequeue();\n    loop_count++;\n    int x = current.x;\n    int y = current.y;\n    char current_char = grid[y][x];\n    // 1. check up\n    if (y > 0 && !visited[y - 1][x] && strchr(\"S|JL\", current_char) &&\n        strchr(\"|7F\", grid[y - 1][x])) {\n      visited[y - 1][x] = 1;\n      Point next = {x, y - 1};\n      enqueue(next);\n    }\n    // 2. check down\n    if (y < num_rows - 1 && !visited[y + 1][x] &&\n        strchr(\"S|7F\", current_char) && strchr(\"|JL\", grid[y + 1][x])) {\n      visited[y + 1][x] = 1;\n      Point next = {x, y + 1};\n      enqueue(next);\n    }\n    // 3. check left\n    if (x > 0 && !visited[y][x - 1] && strchr(\"S-J7\", current_char) &&\n        strchr(\"-LF\", grid[y][x - 1])) {\n      visited[y][x - 1] = 1;\n      Point next = {x - 1, y};\n      enqueue(next);\n    }\n    // 4. check right\n    if (x < num_cols - 1 && !visited[y][x + 1] &&\n        strchr(\"S-LF\", current_char) && strchr(\"-J7\", grid[y][x + 1])) {\n      visited[y][x + 1] = 1;\n      Point next = {x + 1, y};\n      enqueue(next);\n    }\n  }\n\n  printf(\"Number of loops: %d\\n\", loop_count / 2);\n  return 0;\n}\n\n```",
          "excerpt": "Implementation and notes for Part 1 of the Day 10 Pipe Maze puzzle from the 2023 Advent of Code challenge.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-08-17T11:55:32.110Z"
        },
        {
          "id": "101-advent-of-code-2023-day-13-md",
          "slug": "101-advent-of-code/2023/day-13",
          "filepath": "101-ADVENT OF CODE/2023/Day 13.md",
          "folder": "101-ADVENT OF CODE/2023",
          "filename": "Day 13.md",
          "frontmatter": {
            "title": "Part 2",
            "date": "2025-09-01",
            "tags": [
              "advent-of-code",
              "aoc-2023",
              "symmetry",
              "two-pointers",
              "grid",
              "transpose",
              "pattern-matching",
              "algorithms"
            ],
            "category": "101-ADVENT OF CODE/2023",
            "description": "A logic overview for detecting grid reflection symmetry using a two-pointer approach and matrix transposition for Advent of Code 2023."
          },
          "content": "### Pattern Matching and Symmetry Detection\n- **%% Basically a two pointer problem %%\n\n## The Approach\n1. Parse the input into a grid.\n2. Checking a Potential Reflection\n\t- Take 2 Pointers i and i+1 and check if same. \n\t- if eq then check i-1 and i+2 till the end of line.\n3. Continue for rows and columns both\n4. Use transpose the grid to reuse the function.\n\n```python\ndef find_horizontal_mirror(grid):\n\n    for i in range(len(grid) - 1):\n        top_ptr = i\n        bottom_ptr = i + 1\n        is_perfect_mirror = True\n\n        while top_ptr >= 0 and bottom_ptr < len(grid):\n            if grid[top_ptr] != grid[bottom_ptr]:\n                is_perfect_mirror = False\n                break\n            \n            top_ptr -= 1\n            bottom_ptr += 1\n            \n        if is_perfect_mirror:\n            return i + 1\n            \n    return 0\n\ndef solve(filename=\"input.txt\"):\n\n    try:\n        with open(filename, 'r') as file:\n            # Patterns are separated by blank lines.\n            patterns = file.read().strip().split('\\n\\n')\n    except FileNotFoundError:\n        print(f\"Error: Input file '{filename}' not found.\")\n        return\n\n    total_summary = 0\n\n    for pattern_str in patterns:\n        # Convert each pattern block into a grid (list of strings).\n        grid = pattern_str.splitlines()\n\n        # 1. Check for a horizontal mirror.\n        horizontal_rows = find_horizontal_mirror(grid)\n        if horizontal_rows > 0:\n            total_summary += 100 * horizontal_rows\n            continue # Move to the next pattern once the mirror is found.\n\n        # 2. If no horizontal mirror, check for a vertical one by transposing.\n        transposed_grid = [\"\".join(col) for col in zip(*grid)]\n\n        vertical_cols = find_horizontal_mirror(transposed_grid)\n        if vertical_cols > 0:\n            total_summary += vertical_cols\n\n    return total_summary\n\nif __name__ == \"__main__\":\n    # You will need to create an 'input.txt' file with your puzzle input.\n    result = solve()\n    if result is not None:\n        print(f\"The final summary for Part 1 is: {result}\")\n\n```\n\n\n# Part 2\n```\n\n```",
          "excerpt": "A logic overview for detecting grid reflection symmetry using a two-pointer approach and matrix transposition for Advent of Code 2023.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-09-01T13:19:30.229Z"
        },
        {
          "id": "101-advent-of-code-2023-day-17-md",
          "slug": "101-advent-of-code/2023/day-17",
          "filepath": "101-ADVENT OF CODE/2023/Day 17.md",
          "folder": "101-ADVENT OF CODE/2023",
          "filename": "Day 17.md",
          "frontmatter": {
            "title": "pseudo code",
            "date": "2025-09-05",
            "tags": [
              "advent of code",
              "dijkstra",
              "pathfinding",
              "algorithms",
              "graph-theory",
              "optimization"
            ],
            "category": "101-ADVENT OF CODE/2023",
            "description": "A walkthrough of adapting Dijkstra's algorithm with state tracking to solve the movement constraints of Advent of Code 2023 Day 17."
          },
          "content": "\n### The Problem: Advent of Code 2023, Day 17\n\n**The Goal**: Find the path from the top-left corner to the bottom-right corner with the minimum total heat loss.\n\n**The Twist (The Constraints)**: This isn't a simple pathfinding problem. Your movement is restricted:\n* You cannot reverse direction (e.g., if you moved right, your next move can't be left).\n* **Crucible Constraint (Part 1)**: You can move at most **three** steps in a single direction before you **must** turn 90 degrees left or right.\n\nThis constraint changes everything. The shortest path to a grid cell is meaningless if you arrive there having already moved three steps in the same direction, as your options for the next move are now limited.\n\n\n---\n\n###  The Solution: Combining Dijkstra's with State\n\nTo solve this, we must adapt Dijkstra's algorithm. The key is to realize that a \"node\" in our graph isn't just a position `(row, col)`. It has to include the information needed to follow the rules.\n\n#### Step 1: Redefine the \"Node\" as a \"State\"\n\nA state must uniquely identify a point in our search and contain enough information to determine the next valid moves. A good state representation is a tuple:\n\n`state = (row, col, direction, consecutive_steps)`\n\n* `row, col`: Your current grid coordinates.\n* `direction`: The direction you entered this cell from (e.g., North, East, South, West).\n* `consecutive_steps`: How many steps in a row you've taken in that `direction`.\n\n#### Step 2: Adapt Dijkstra's with the New State\n\nWe will use a priority queue, but instead of storing `(distance, row, col)`, we'll store the full state information, prioritized by heat loss:\n\n`Priority Queue Item: (total_heat_loss, row, col, direction, consecutive_steps)`\n\nWe also need a `visited` set to avoid processing the exact same *state* twice. Notice this is a set of states, not just coordinates. `visited.add((row, col, direction, steps))`\n\n#### Step 3: Detailed Walkthrough of the Algorithm\n\n1.  **Initialization**:\n    * Create an empty priority queue.\n    * Create an empty `visited` set.\n    * The starting point is `(0, 0)`. You can start by moving Right or Down. So, push two initial states onto the queue. (Note: The puzzle is about the heat loss of the *entered* cell, so the starting cell `(0,0)` has 0 cost).\n        * `pq.push((grid[0][1], 0, 1, EAST, 1))`\n        * `pq.push((grid[1][0], 1, 0, SOUTH, 1))`\n\n2.  **The Main Loop**:\n    * **Pop the state with the lowest heat loss**. Let's say we pop `(10, 3, 4, NORTH, 2)`. This means we've reached cell `(3, 4)` with a total heat loss of 10, having come from the south (moved North) for 2 consecutive steps.\n    * **Check if visited**. If `(3, 4, NORTH, 2)` is in our `visited` set, we've already found a better or equal path to this exact state. `continue` to the next item in the queue. Otherwise, add it to `visited`.\n    * **Check for Goal**. Is `(row, col)` the bottom-right corner? If yes, we're done! The `total_heat_loss` is our answer.\n    * **Generate Next Moves (Neighbors)**. From our current state `(row=3, col=4, dir=NORTH, steps=2)`, what can we do next?\n        * **Turn Left (move West)**: This is a valid turn. The new state would be at `(3, 3)`. The number of steps resets to 1.\n            * New state: `(row=3, col=3, dir=WEST, steps=1)`\n            * New heat loss: `10 + grid[3][3]`\n            * Push `(10 + grid[3][3], 3, 3, WEST, 1)` to the queue.\n        * **Turn Right (move East)**: This is also a valid turn. The new state would be at `(3, 5)`. Steps reset to 1.\n            * New state: `(row=3, col=5, dir=EAST, steps=1)`\n            * New heat loss: `10 + grid[3][5]`\n            * Push `(10 + grid[3][5], 3, 5, EAST, 1)` to the queue.\n        * **Go Straight (move North)**: Can we continue North? Yes, because our current `steps=2` is less than the max of 3.\n            * New state: `(row=2, col=4, dir=NORTH, steps=3)`\n            * New heat loss: `10 + grid[2][4]`\n            * Push `(10 + grid[2][4], 2, 4, NORTH, 3)` to the queue.\n\n    * **Repeat**: The loop continues, always processing the state with the absolute minimum heat loss found so far across all possible paths, until the destination is reached.\n\n## pseudo code\n\n\n```\n// Define constants for directions for clarity\n// For example: 0:North, 1:East, 2:South, 3:West\nDIRECTIONS = [( -1, 0 ), ( 0, 1 ), ( 1, 0 ), ( 0, -1 )]\n\nfunction solve(grid):\n    // The priority queue stores tuples of:\n    // (total_heat_loss, row, col, direction_index, consecutive_steps)\n    priority_queue = new PriorityQueue()\n\n    // The visited set stores tuples of:\n    // (row, col, direction_index, consecutive_steps)\n    // to avoid redundant computations for the exact same state.\n    visited = new Set()\n\n    // Get grid dimensions\n    height = number of rows in grid\n    width = number of columns in grid\n\n    // -- Initialization --\n    // We start at (0,0) but haven't moved yet. We can either go\n    // East (1) or South (2) as our first move.\n    // The starting cell's heat loss is not counted.\n    // So, we push the states for the first move onto the queue.\n    \n    // Move East from start\n    if (0, 1) is a valid coordinate:\n        heat_loss = grid[0][1]\n        priority_queue.push((heat_loss, 0, 1, 1, 1)) // dir=East, steps=1\n\n    // Move South from start\n    if (1, 0) is a valid coordinate:\n        heat_loss = grid[1][0]\n        priority_queue.push((heat_loss, 1, 0, 2, 1)) // dir=South, steps=1\n\n    // -- Main Dijkstra Loop --\n    while priority_queue is not empty:\n        // 1. Pop the state with the minimum heat loss\n        (heat_loss, r, c, dir, steps) = priority_queue.pop()\n\n        // 2. Check if we reached the destination\n        if r == height - 1 and c == width - 1:\n            return heat_loss // We found the shortest path!\n\n        // 3. Check if we have already processed this exact state\n        if (r, c, dir, steps) is in visited:\n            continue\n        visited.add((r, c, dir, steps))\n\n        // 4. Explore next possible moves (neighbors in the state graph)\n\n        // -- A) Continue Straight --\n        // Check if we can continue in the same direction (steps < 3)\n        if steps < 3:\n            // Calculate next position\n            nr = r + DIRECTIONS[ddir][0]\n            nc = c + DIRECTIONS[dir][1]\n\n            // Check if the new position is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                new_heat_loss = heat_loss + grid[nr][nc]\n                new_state = (new_heat_loss, nr, nc, dir, steps + 1)\n                priority_queue.push(new_state)\n\n        // -- B) Turn Left & Right --\n        // We can always turn. We iterate through all four directions.\n        for new_dir in range(4):\n            // We cannot go in the same direction (handled above) or reverse.\n            // The reverse of dir `d` is `(d + 2) % 4`.\n            if new_dir == dir or new_dir == (dir + 2) % 4:\n                continue\n\n            // Calculate next position based on the new direction\n            nr = r + DIRECTIONS[new_dir][0]\n            nc = c + DIRECTIONS[new_dir][1]\n            \n            // Check if the new position is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                new_heat_loss = heat_loss + grid[nr][nc]\n                // After a turn, consecutive steps reset to 1\n                new_state = (new_heat_loss, nr, nc, new_dir, 1)\n                priority_queue.push(new_state)\n\n    return -1 // Should not be reached if a path exists\n```",
          "excerpt": "A walkthrough of adapting Dijkstra's algorithm with state tracking to solve the movement constraints of Advent of Code 2023 Day 17.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-09-05T08:26:30.569Z"
        }
      ]
    },
    {
      "name": "101-ADVENT OF CODE/2024",
      "path": "101-ADVENT OF CODE/2024",
      "noteCount": 6,
      "notes": [
        {
          "id": "101-advent-of-code-2024-day-1-md",
          "slug": "101-advent-of-code/2024/day-1",
          "filepath": "101-ADVENT OF CODE/2024/Day 1.md",
          "folder": "101-ADVENT OF CODE/2024",
          "filename": "Day 1.md",
          "frontmatter": {
            "title": "Day 1",
            "date": "2025-11-13",
            "tags": [
              "python"
            ],
            "category": "101-ADVENT OF CODE/2024"
          },
          "content": "```python\nl1 = []\nl2 = []\ntotal = 0\nwith open(\"input.txt\",\"r\") as file:\n    for line in file.readlines():\n        a = line.strip().split(\"  \")\n        l1.append(int(a[0].strip()))\n        l2.append(int(a[1].strip()))\n        l1.sort()\n        l2.sort()\nfor i in l1:\n    count = l2.count(i)\n    val = count * i\n    total += val\nprint(total)\n\n```\n\n\n```python\nl1 = []\nl2 = []\ntotal = 0\nwith open(\"input.txt\",\"r\") as file:\n    for line in file.readlines():\n        a = line.strip().split(\"  \")\n        l1.append(int(a[0].strip()))\n        l2.append(int(a[1].strip()))\n        l1.sort()\n        l2.sort()\nfor i in l1:\n    count = l2.count(i)\n    val = count * i\n    total += val\nprint(total)\n\n```",
          "excerpt": "",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-11-13T12:52:50.174Z"
        },
        {
          "id": "101-advent-of-code-2024-day-2-md",
          "slug": "101-advent-of-code/2024/day-2",
          "filepath": "101-ADVENT OF CODE/2024/Day 2.md",
          "folder": "101-ADVENT OF CODE/2024",
          "filename": "Day 2.md",
          "frontmatter": {
            "title": "----------------------------------------------------------------------",
            "date": "2025-11-13",
            "tags": [
              "python"
            ],
            "category": "101-ADVENT OF CODE/2024"
          },
          "content": "\n```python\nimport os\n\ndef is_safe_report(levels):\n    \"\"\"\n    Checks if a list of levels meets the Part 1 safety criteria:\n    1. Strictly monotonic (all increasing or all decreasing).\n    2. All adjacent differences are in [1, 3].\n    \"\"\"\n    if len(levels) < 2:\n        return True # Trivial case: 0 or 1 element is always safe\n\n    is_strictly_increasing = True\n    is_strictly_decreasing = True\n    \n    for i in range(len(levels) - 1):\n        diff = levels[i+1] - levels[i]\n        abs_diff = abs(diff)\n        \n        # CRITERION 2: Check difference constraint (must be 1 to 3 for ALL pairs)\n        if not (1 <= abs_diff <= 3):\n            return False # Failed the difference test immediately\n        \n        # CRITERION 1: Update strict monotonicity flags\n        if diff <= 0:\n            is_strictly_increasing = False\n        \n        if diff >= 0:\n            is_strictly_decreasing = False\n    \n    # Must be EITHER strictly increasing OR strictly decreasing (and passed diff test)\n    return is_strictly_increasing or is_strictly_decreasing\n\n# ----------------------------------------------------------------------\ndef is_part2_safe(report):\n    \"\"\"\n    Checks if a report is safe under Part 2 rules:\n    The original report OR any version with one element removed must be safe by Part 1 rules.\n    \"\"\"\n    # 1. Check if the original report is already safe (covers Part 1 solution)\n    if is_safe_report(report):\n        return True\n\n    # 2. Check every possible sub-report by removing one element\n    for i in range(len(report)):\n        # Create a new list by skipping the element at index i\n        # report[:i] is the left part, report[i+1:] is the right part\n        sub_report = report[:i] + report[i+1:]\n        \n        if is_safe_report(sub_report):\n            return True # Found a safe sub-report, no need to check others\n\n    return False # Neither the original nor any single-removal version was safe\n\ndef solve_part2():\n    safe_reports_count = 0\n    file_path = \"input.txt\" # Ensure your puzzle input is in 'input.txt'\n    \n    try:\n        with open(file_path, 'r') as file:\n            for line in file:\n                cleaned_line = line.strip()\n                if not cleaned_line:\n                    continue\n\n                try:\n                    # Convert the line to a list of integers\n                    levels = [int(x) for x in cleaned_line.split()]\n                except ValueError:\n                    print(f\"Skipping line due to non-integer content: '{cleaned_line}'\")\n                    continue\n                \n                # Check the Part 2 safety rule\n                if is_part2_safe(levels):\n                    safe_reports_count += 1\n\n    except FileNotFoundError:\n        print(f\"Error: Input file '{file_path}' not found.\")\n        return None\n    \n    return safe_reports_count\n\n# --- Run the solution ---\nfinal_answer = solve_part2()\n\nif final_answer is not None:\n    print(f\"The number of Part 2 safe reports is: {final_answer}\")\n\n# --- Example Check (for verification) ---\n# Example from Part 1 description (7 6 4 2 1 and 1 3 6 7 9 were safe)\n# The Part 2 test requires the original report OR a single-removal report to be safe.\n# Let's test the original unsafe examples to see if they become safe in Part 2.\nprint(\"\\n--- Example Verification ---\")\nexample_reports_part2 = [\n    [7, 6, 4, 2, 1],  # Safe in Part 1 -> Safe in Part 2 (Expected: True)\n    [1, 2, 7, 8, 9],  # Unsafe (diff 5). Removing 7 makes [1, 2, 8, 9] (diffs 1, 6, 1) -> Unsafe. Removing 2 makes [1, 7, 8, 9] (diffs 6, 1, 1) -> Unsafe. It might remain Unsafe.\n    [9, 7, 6, 2, 1],  # Unsafe (diff 4). Removing 6 makes [9, 7, 2, 1] (diffs 2, 5, 1) -> Unsafe. Removing 2 makes [9, 7, 6, 1] (diffs 2, 1, 5) -> Unsafe. It might remain Unsafe.\n    [1, 3, 2, 4, 5],  # Unsafe (not monotonic). Removing 3 makes [1, 2, 4, 5] (Safe). -> Safe in Part 2\n    [8, 6, 4, 4, 1],  # Unsafe (diff 0). Removing one 4 makes [8, 6, 4, 1] (Safe). -> Safe in Part 2\n    [1, 3, 6, 7, 9]   # Safe in Part 1 -> Safe in Part 2 (Expected: True)\n]\n\n# We don't have the final example count for Part 2, but let's count our checks.\nexample_part2_safe_count = sum(is_part2_safe(r) for r in example_reports_part2)\n\nprint(f\"Example Part 2 safe count: {example_part2_safe_count} (Expected value depends on which sub-reports become safe)\")\n\n```",
          "excerpt": "",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-11-13T12:53:13.448Z"
        },
        {
          "id": "101-advent-of-code-2024-day-3-md",
          "slug": "101-advent-of-code/2024/day-3",
          "filepath": "101-ADVENT OF CODE/2024/Day 3.md",
          "folder": "101-ADVENT OF CODE/2024",
          "filename": "Day 3.md",
          "frontmatter": {
            "title": "Day 3",
            "date": "2025-11-13",
            "tags": [
              "cpp",
              "include"
            ],
            "category": "101-ADVENT OF CODE/2024"
          },
          "content": "```cpp\n#include <fstream>\n#include <iostream>\n#include <regex>\n#include <string>\n\nint main() {\n  std::ifstream file(\"input.txt\");\n  std::string content;\n  char ch;\n  while (file.get(ch)) {\n    content += ch;\n  }\n\n  std::regex mul_pattern(R\"(mul\\((\\d{1,3}),(\\d{1,3})\\))\");\n  std::smatch match;\n  std::string::const_iterator searchStart(content.cbegin());\n  int part1_sum = 0;\n\n  while (regex_search(searchStart, content.cend(), match, mul_pattern)) {\n    int x = stoi(match[1]);\n    int y = stoi(match[2]);\n    part1_sum += x * y;\n    searchStart = match.suffix().first;\n  }\n  std::cout << \"Part 1: \" << part1_sum << std::endl;\n\n  std::regex full_pattern(R\"(mul\\((\\d{1,3}),(\\d{1,3})\\)|do\\(\\)|don't\\(\\))\");\n  searchStart = content.cbegin();\n  int part2_sum = 0;\n  bool enabled = true;\n\n  while (regex_search(searchStart, content.cend(), match, full_pattern)) {\n    std::string matched = match[0];\n\n    if (matched == \"do()\") {\n      enabled = true;\n    } else if (matched == \"don't()\") {\n      enabled = false;\n    } else if (enabled) {\n      int x = stoi(match[1]);\n      int y = stoi(match[2]);\n      part2_sum += x * y;\n    }\n\n    searchStart = match.suffix().first;\n  }\n\n  std::cout << \"Part 2: \" << part2_sum << std::endl;\n}\n\n```",
          "excerpt": "",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-11-13T12:53:54.035Z"
        },
        {
          "id": "101-advent-of-code-2024-day-4-md",
          "slug": "101-advent-of-code/2024/day-4",
          "filepath": "101-ADVENT OF CODE/2024/Day 4.md",
          "folder": "101-ADVENT OF CODE/2024",
          "filename": "Day 4.md",
          "frontmatter": {
            "title": "Day 4",
            "date": "2025-11-13",
            "tags": [
              "python"
            ],
            "category": "101-ADVENT OF CODE/2024"
          },
          "content": "```python\ngrid = []\nwith open(\"input.txt\", 'r') as f:\n   grid =  [line.strip() for line in f if line.strip()]\n\nR = len(grid)\nC = len(grid[0])\n\ndef isInside(r,c):\n    return 0 <= r < R and 0 <= c < C\n\ndirections = [(0,1),(1,0),(0,-1),(-1,0),(1,1),(1,-1),(-1,1),(-1,-1)]\n\nword = \"XMAS\"\ncount = 0\n\nfor r in range(R):\n    for c in range(C):\n        if grid[r][c] == 'X':\n\n            for dir_r, dir_c in directions:\n                match_x = True\n                for step in range(1,4):\n                    nr,nc = r + dir_r * step, c + dir_c * step\n                    if not isInside(nr,nc) or grid[nr][nc] != word[step]:\n                        match_x = False\n                        break\n                if match_x:\n                    count += 1\n\ndef solve_part2(grid):\n    R = len(grid)\n    C = len(grid[0])\n    count = 0\n\n    # The 4 diagonal offset coordinates (dr, dc)\n    DIAGONALS = [(-1, -1), (-1, 1), (1, -1), (1, 1)] # Top-L, Top-R, Bottom-L, Bottom-R\n\n    for r in range(1, R - 1): # 'A' must be at least one step from the edge\n        for c in range(1, C - 1):\n            \n            if grid[r][c] == 'A':\n                # The 4 surrounding diagonal characters\n                chars = []\n                for dr, dc in DIAGONALS:\n                    chars.append(grid[r + dr][c + dc])\n\n                # The four diagonal characters are at indices 0, 1, 2, 3\n                # chars[0] = Top-Left (TL)\n                # chars[1] = Top-Right (TR)\n                # chars[2] = Bottom-Left (BL)\n                # chars[3] = Bottom-Right (BR)\n                \n                # We need exactly two 'M's and two 'S's\n                if sorted(chars) == ['M', 'M', 'S', 'S']:\n                    \n                    # We only care about the diagonals pairing up:\n                    # 1. TL-BR and TR-BL (M.A.S on one diagonal, S.A.M on the other)\n                    # OR\n                    # 2. TL-TR and BL-BR (M's on top row, S's on bottom, or vice-versa)\n                    \n                    # Combination 1: Diagonal MAS/SAM\n                    # e.g., M-S and S-M pairings\n                    if (chars[0] != chars[3]) and (chars[1] != chars[2]):\n                        count += 1\n                        \n                    # Combination 2: Horizontal M/S rows\n                    # e.g., M-M and S-S pairings\n                    elif (chars[0] == chars[1]) and (chars[2] == chars[3]):\n                        count += 1\n                        \n    return count\n               \nprint(solve_part2(grid))\n\n```",
          "excerpt": "",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-11-13T12:54:24.405Z"
        },
        {
          "id": "101-advent-of-code-2024-day-6-md",
          "slug": "101-advent-of-code/2024/day-6",
          "filepath": "101-ADVENT OF CODE/2024/Day 6.md",
          "folder": "101-ADVENT OF CODE/2024",
          "filename": "Day 6.md",
          "frontmatter": {
            "title": "Day 6",
            "date": "2025-11-13",
            "tags": [
              "cpp",
              "include"
            ],
            "category": "101-ADVENT OF CODE/2024"
          },
          "content": "```cpp\n#include <iostream>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\n// Represents the grid and guard's state\nstruct GuardSim {\n  vector<string> grid;\n  int startRow, startCol, startDir;\n  int rows, cols;\n\n  // Directions: 0: Up, 1: Right, 2: Down, 3: Left\n  // Change in (row, col) for each direction\n  const vector<pair<int, int>> moves = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n\n  // Constructor to parse the input grid\n  GuardSim(const vector<string> &inputGrid) {\n    grid = inputGrid;\n    rows = grid.size();\n    cols = grid[0].size();\n    findStart();\n  }\n\n  // Finds the guard's starting position and direction\n  void findStart() {\n    for (int r = 0; r < rows; ++r) {\n      for (int c = 0; c < cols; ++c) {\n        char ch = grid[r][c];\n        if (ch == '^') {\n          startRow = r;\n          startCol = c;\n          startDir = 0;\n          return;\n        }\n        if (ch == '>') {\n          startRow = r;\n          startCol = c;\n          startDir = 1;\n          return;\n        }\n        if (ch == 'v') {\n          startRow = r;\n          startCol = c;\n          startDir = 2;\n          return;\n        }\n        if (ch == '<') {\n          startRow = r;\n          startCol = c;\n          startDir = 3;\n          return;\n        }\n      }\n    }\n  }\n\n  // Checks if a position is within the grid boundaries\n  bool isOutOfBounds(int r, int c) {\n    return r < 0 || r >= rows || c < 0 || c >= cols;\n  }\n\n  /**\n   * Simulates the guard's path.\n   * detectsLoop:\n   * - If true (for Part 2), returns 1 if a loop is found, 0 otherwise.\n   * - If false (for Part 1), returns the count of visited tiles.\n   */\n  int simulate(bool detectsLoop) {\n    int r = startRow;\n    int c = startCol;\n    int dir = startDir;\n\n    // Set to store visited positions (row, col)\n    set<pair<int, int>> visitedPos;\n\n    // Set to store visited states (row, col, dir) for loop detection\n    set<tuple<int, int, int>> visitedStates;\n\n    // Safety break for very long loops, though state-based detection is primary\n    for (int step = 0; step < 1000000; ++step) {\n\n      if (detectsLoop) {\n        // --- Part 2 Logic: Loop Detection ---\n        tuple<int, int, int> state = {r, c, dir};\n        if (visitedStates.count(state)) {\n          return 1; // Loop detected!\n        }\n        visitedStates.insert(state);\n      } else {\n        // --- Part 1 Logic: Position Counting ---\n        visitedPos.insert({r, c});\n      }\n\n      // 1. Calculate next position\n      int nextR = r + moves[dir].first;\n      int nextC = c + moves[dir].second;\n\n      // 2. Check for exit\n      if (isOutOfBounds(nextR, nextC)) {\n        // Guard exits the grid\n        return detectsLoop ? 0 : visitedPos.size();\n      }\n\n      // 3. Check for obstacle\n      if (grid[nextR][nextC] == '#') {\n        // Turn right\n        dir = (dir + 1) % 4;\n      } else {\n        // Move forward\n        r = nextR;\n        c = nextC;\n      }\n    }\n\n    // Should only be reached if loop detected or safety break hit\n    return detectsLoop ? 1 : visitedPos.size();\n  }\n};\n\nint main() {\n  vector<string> inputGrid;\n  string line;\n\n  cout << \"Paste your puzzle input and press Ctrl+D (Linux/macOS) or Ctrl+Z \"\n          \"(Windows) to end:\"\n       << endl;\n  while (getline(cin, line)) {\n    if (!line.empty()) {\n      inputGrid.push_back(line);\n    }\n  }\n\n  if (inputGrid.empty()) {\n    cerr << \"No input provided!\" << endl;\n    return 1;\n  }\n\n  // --- Part 1 ---\n  GuardSim simPart1(inputGrid);\n  int part1_answer = simPart1.simulate(false);\n  cout << \"-----------------------------------\" << endl;\n  cout << \"Part 1 Answer: \" << part1_answer << endl;\n\n  // --- Part 2 ---\n  int loopFormingObstacles = 0;\n  vector<pair<int, int>> emptyTiles;\n\n  // Find all potential spots to add an obstacle\n  for (int r = 0; r < simPart1.rows; ++r) {\n    for (int c = 0; c < simPart1.cols; ++c) {\n      if (simPart1.grid[r][c] == '.') {\n        emptyTiles.push_back({r, c});\n      }\n    }\n  }\n\n  // Test each empty tile\n  for (const auto &tile : emptyTiles) {\n    // Create a copy of the grid and add the new obstacle\n    vector<string> modifiedGrid = inputGrid;\n    modifiedGrid[tile.first][tile.second] = '#';\n\n    // Run simulation on the modified grid\n    GuardSim simPart2(modifiedGrid);\n    if (simPart2.simulate(true) == 1) {\n      loopFormingObstacles++;\n    }\n  }\n\n  cout << \"Part 2 Answer: \" << loopFormingObstacles << endl;\n  cout << \"-----------------------------------\" << endl;\n\n  return 0;\n}\n\n```",
          "excerpt": "",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-11-13T12:54:45.019Z"
        },
        {
          "id": "101-advent-of-code-2024-day-7-md",
          "slug": "101-advent-of-code/2024/day-7",
          "filepath": "101-ADVENT OF CODE/2024/Day 7.md",
          "folder": "101-ADVENT OF CODE/2024",
          "filename": "Day 7.md",
          "frontmatter": {
            "title": "Day 7",
            "date": "2025-11-13",
            "tags": [
              "python"
            ],
            "category": "101-ADVENT OF CODE/2024"
          },
          "content": "```python\ntotal  = 0\n\ndef concat(a,b):\n    return int(str(a)+str(b))\n\n\ndef canReach(currentTotal,remaining,target):\n    if len(remaining)==0:\n        return currentTotal==target\n    \n    next = remaining[0]\n    rest = remaining[1:]\n    \n    withAdd = canReach(currentTotal+next,rest,target)\n    withMul = canReach(currentTotal*next,rest,target)\n\n    concatTotal = concat(currentTotal,next)\n    withConcat = canReach(concatTotal,rest,target)\n\n    return (withAdd or withMul or withConcat)\n\n\nwith open(\"input.txt\") as f:\n    for line in f:\n        target,rest = line.split(':')\n        target = int(target)\n        numbers = [int(x) for x in rest.split()]\n\n        firstNum = numbers[0]\n        remaining = numbers[1:]\n        \n        if canReach(firstNum,remaining,target):\n            total = total + target\n\nprint(\"total:\",total)\n\n```\n",
          "excerpt": "",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-11-13T12:55:11.048Z"
        }
      ]
    },
    {
      "name": "200-NEXT",
      "path": "200-NEXT",
      "noteCount": 1,
      "notes": [
        {
          "id": "200-next-next-docs-md",
          "slug": "200-next/next-docs",
          "filepath": "200-NEXT/Next-Docs.md",
          "folder": "200-NEXT",
          "filename": "Next-Docs.md",
          "frontmatter": {
            "title": "Error Handling",
            "date": "2025-05-11",
            "tags": [
              "react",
              "nextjs",
              "server-actions",
              "useactionstate",
              "streaming",
              "suspense",
              "error-handling",
              "server-components"
            ],
            "category": "200-NEXT",
            "description": "Learn to manage expected errors in Server Actions using the useActionState hook while understanding streaming, suspense, and server component constraints."
          },
          "content": "## Error Handling\n\nHandling Expected Errors from Server Actions\n\n> const [state, FormAction, pending] = useActionState( createUser, initialState )\n\nUse the useActionState hook to manage the state of Server Actions, including handling errors. This approach avoids try/catch blocks for expected errors,\n\n---\n\n## Loading UI and Streaming\n\n![](https://beta.appflowy.cloud/api/file_storage/5280cd98-0615-4f27-b162-2f7e8f5d0dbe/v1/blob/4a0e06d7%2D04e2%2D5c99%2Dad75%2D23e1bca86797/BFFaB5ByU4F_iBPosiusqdFuvURpyyVtgLUCjzb3GzM=.png)  \n\n## Streaming without Suspense :\n\n![](https://beta.appflowy.cloud/api/file_storage/5280cd98-0615-4f27-b162-2f7e8f5d0dbe/v1/blob/4a0e06d7%2D04e2%2D5c99%2Dad75%2D23e1bca86797/A_pHbXVkPtxSnZP7hHGt5B29KtuQXnszy7a83yibT5Y=.png)\n\n## Streaming with Suspense :\n\n![](https://beta.appflowy.cloud/api/file_storage/5280cd98-0615-4f27-b162-2f7e8f5d0dbe/v1/blob/4a0e06d7%2D04e2%2D5c99%2Dad75%2D23e1bca86797/DebToGILPUo3iTRI7BbPfDmGHY-k9MSnIeShyb4UQt4=.png)\n## Streaming with Suspense :\n\n![](https://beta.appflowy.cloud/api/file_storage/5280cd98-0615-4f27-b162-2f7e8f5d0dbe/v1/blob/4a0e06d7%2D04e2%2D5c99%2Dad75%2D23e1bca86797/DebToGILPUo3iTRI7BbPfDmGHY-k9MSnIeShyb4UQt4=.png)\n## Server Components:\n\nwe can't use state, because state can change, but Server Components can't re-render. And we can't use effects because effects only run _after_ the render, on the client, and Server Components never make it to the client.\n\nIt also means that we have a bit more flexibility when it comes to the rules. For example, in traditional React, we need to put side effects inside a `useEffect` callback or an event handler or something, so that they don't repeat on every render. But if the component only runs _once_, we don't have to worry about that!\n\n\n\n",
          "excerpt": "Learn to manage expected errors in Server Actions using the useActionState hook while understanding streaming, suspense, and server component constraints.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-05-11T10:03:21.000Z"
        }
      ]
    },
    {
      "name": "200-NEXT/ProjectLearnings",
      "path": "200-NEXT/ProjectLearnings",
      "noteCount": 2,
      "notes": [
        {
          "id": "200-next-projectlearnings-middleware-md",
          "slug": "200-next/projectlearnings/middleware",
          "filepath": "200-NEXT/ProjectLearnings/Middleware.md",
          "folder": "200-NEXT/ProjectLearnings",
          "filename": "Middleware.md",
          "frontmatter": {
            "title": "***Used in ChatPulse***",
            "date": "2025-05-13",
            "tags": [
              "chatpulse",
              "javascript",
              "typescript",
              "middleware",
              "nextjs",
              "markdown"
            ],
            "category": "200-NEXT/ProjectLearnings",
            "description": "Code implementation of a simple JavaScript or TypeScript middleware used within the ChatPulse project for Markdown processing."
          },
          "content": "___\n## ***Used in ChatPulse***\n\nHere is your code converted to Markdown with syntax highlighting for JavaScript/TypeScript:\n\n```typescript\nimport { headers } from 'next/headers';\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\nimport { auth } from './lib/auth';\n\nconst publicPaths = [\n  '/',\n  '/signin',\n  '/api/auth',\n  '/info',\n  '/banner.png',\n];\n\nexport async function middleware(request: NextRequest) {\n  const { pathname } = request.nextUrl;\n\n  const isPublicPath = publicPaths.some(\n    (path) =>\n      pathname === path ||\n      pathname.startsWith(`${path}/`) ||\n      pathname.startsWith('/api/auth/')\n  );\n\n  const isAuthRoute = pathname.startsWith('/signin');\n\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (isAuthRoute && session) {\n    return NextResponse.redirect(new URL('/home', request.url));\n  }\n\n  if (!isPublicPath && !session) {\n    const signInUrl = new URL('/signin', request.url);\n    signInUrl.searchParams.set('callbackUrl', request.url);\n    return NextResponse.redirect(signInUrl);\n  }\n\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: [\n    '/((?!_next/static|_next/image|favicon\\\\.ico|public).*)',\n  ],\n};\n```\n\n\n## ***Simple middleware***\n\n```typescript\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { headers } from \"next/headers\";\nimport { auth } from \"@/lib/auth\";\n\nexport async function middleware(request: NextRequest) {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    return NextResponse.redirect(new URL(\"/sign-in\", request.url));\n  }\n\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: [\"/((?!api|_next/static|_next/image|favicon.ico|sign-in|assets).*)\"],\n};\n\n```\n\n___\n\n\n\n",
          "excerpt": "Code implementation of a simple JavaScript or TypeScript middleware used within the ChatPulse project for Markdown processing.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-05-13T12:52:04.000Z"
        },
        {
          "id": "200-next-projectlearnings-witherrorhandling-as-a-middleware-for-server-functions-md",
          "slug": "200-next/projectlearnings/witherrorhandling-as-a-middleware-for-server-functions",
          "filepath": "200-NEXT/ProjectLearnings/withErrorHandling as a middleware for server functions.md",
          "folder": "200-NEXT/ProjectLearnings",
          "filename": "withErrorHandling as a middleware for server functions.md",
          "frontmatter": {
            "title": "withErrorHandling as a middleware for server functions",
            "date": "2025-05-14",
            "tags": [
              "typescript"
            ],
            "category": "200-NEXT/ProjectLearnings"
          },
          "content": "\n```typescript\n// Higher order function to handle errors\nexport const withErrorHandling = <T, A extends unknown[]>(\n  fn: (...args: A) => Promise<T>\n) => {\n  return async (...args: A): Promise<T> => {\n    try {\n      const result = await fn(...args);\n      return result;\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error occurred\";\n      return errorMessage as unknown as T;\n    }\n  };\n};\n```\n`withErrorHandling(<func>)`\n",
          "excerpt": "",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-05-14T11:21:46.000Z"
        }
      ]
    },
    {
      "name": "404-BACKEND",
      "path": "404-BACKEND",
      "noteCount": 9,
      "notes": [
        {
          "id": "404-backend-http-protocol---md",
          "slug": "404-backend/http-protocol",
          "filepath": "404-BACKEND/HTTP Protocol.md",
          "folder": "404-BACKEND",
          "filename": "HTTP Protocol.md",
          "frontmatter": {
            "title": "HTTP Protocol",
            "date": "2025-08-21",
            "tags": [
              "http",
              "networking",
              "backend",
              "web-architecture",
              "https",
              "protocols",
              "api"
            ],
            "category": "404-BACKEND",
            "description": "A comprehensive overview of HTTP fundamentals, including version evolution, request-response structures, headers, and standard methods for web communication."
          },
          "content": "\n**1. HTTP Protocol Fundamentals**\n\n* **Statelessness**: It means that the server does not store any information about past client requests. Each request from a client is treated as an independent transaction. This design simplifies the server's architecture, as it doesn't need to maintain session state for each client. This makes it easier to scale web applications by distributing requests across multiple servers.\n\n* **Client-Server Model**: HTTP follows a strict client-server architecture. The client (e.g., a web browser) always initiates a request to a server. The server, which hosts the resources (like web pages or data), processes this request and sends back a response.\n\n* **HTTPS**: This is the secure version of HTTP. It adds a layer of security by using TLS (*Transport Layer Security*) or its predecessor, SSL (Secure Sockets Layer), to encrypt the communication between the client and the server. This encryption protects against eavesdropping and tampering with the data being exchanged.\n\n* **Underlying Transport Protocol (TCP)**: HTTP is an application layer protocol and it relies on a reliable transport layer protocol, which is typically TCP (Transmission Control Protocol). TCP ensures that data is delivered reliably and in the correct order between the client and the server.\n\n**2. Evolution of HTTP Versions**\n\n* **HTTP 1.0**: The earliest version. For each request, a new TCP connection was established, and it was closed after the response was sent. This was inefficient and led to performance issues.\n\n* **HTTP 1.1**: A significant improvement. It introduced the concept of persistent connections (`Keep-Alive`), allowing a single TCP connection to be reused for multiple requests. This reduced latency and improved performance. It also added features like chunked transfer encoding and better caching mechanisms.\n\n* **HTTP 2.0**: Focused on improving performance. It introduced multiplexing, which allows multiple requests and responses to be sent concurrently over a single TCP connection.\n\n* **HTTP 3.0**: The latest version, built on the QUIC protocol which uses UDP instead of TCP. This further improves performance by reducing connection establishment time and handling packet loss more effectively.\n\n**3. HTTP Messages (Request and Response)**\n\n* **Request Message**: This is the message sent from the client to the server. It consists of:\n\n\t* A start-line with the HTTP method, the requested URL, and the HTTP version.\n\t\n\t* Headers, which are key-value pairs providing metadata about the request.\n\t\n\t* An optional body, which contains data being sent to the server (e.g., in a POST request).\n\n* **Response Message**: This is the message sent from the server to the client. It consists of:\n\n\t* A status-line with the HTTP version, a status code, and a status message.\n\t\n\t* Headers, which provide metadata about the response.\n\t\n\t* An optional body, which contains the requested resource.\n\n**4. HTTP Headers**\n\n* **Purpose**: Headers are a crucial part of HTTP messages. They provide important metadata about the request or response, such as the content type, encoding, caching directives, and authentication information.\n\n* **Types of Headers**:\n\n* **Request Headers**: Provide information about the client and the requested resource (e.g., `User-Agent`, `Accept`).\n\n* **General Headers**: Apply to both requests and responses (e.g., `Date`, `Connection`).\n\n* **Representation Headers**: Describe the representation of the resource in the message body (e.g., `Content-Type`, `Content-Length`).\n\n* **Security Headers**: Used to enhance security (e.g., `Content-Security-Policy`, `Strict-Transport-Security`).\n\n**5. HTTP Methods\n\n* **Purpose**: These verbs define the action that the client wants to perform on a resource.\n\n* **Common Methods**:\n\n* **GET**: Retrieve a resource.\n\n* **POST**: Create a new resource.\n\n* **PUT**: Replace an existing resource.\n\n* **PATCH**: Partially update an existing resource.\n\n* **DELETE**: Delete a resource.\n\n* **Idempotent vs. Non-Idempotent**:\n\n\t* **Idempotent** methods produce the same result if called multiple times (e.g., GET, PUT, DELETE).\n\t\n\t* **Non-idempotent** methods may have different effects on each call (e.g., POST).\n\n* **OPTIONS**: Used by the client to determine the communication options for a target resource. This is often used in CORS pre-flight requests.\n\n**6. Cross-Origin Resource Sharing (CORS)**\n\n* **Same-Origin Policy**: A security feature in web browsers that prevents a web page from making requests to a different domain than the one that served the page.\n\n* **CORS Mechanism**: A mechanism that allows servers to relax the same-origin policy and specify which other origins are permitted to access their resources.\n\n* **Simple Request Flow**: For certain simple requests (e.g., GET requests with simple headers), the browser adds an `Origin` header. The server then responds with an `Access-Control-Allow-Origin` header if the origin is allowed.\n\n* **Pre-flight Request Flow**: For more complex requests (e.g., those with custom headers or using methods other than GET or POST), the browser sends a pre-flight `OPTIONS` request to the server to check if the actual request is allowed.\n\n**7. HTTP Response Codes (Status Codes)**\n\n* **Purpose**: These are three-digit codes that indicate the outcome of a request. They are grouped into five categories:\n\n* **1xx (Informational)**: The request has been received, and the process is continuing.\n\n* **2xx (Success)**: The request was successfully received, understood, and accepted.\n\n* **3xx (Redirection)**: Further action needs to be taken by the client to complete the request.\n\n* **4xx (Client Errors)**: The request contains bad syntax or cannot be fulfilled.\n\n* **5xx (Server Errors)**: The server failed to fulfill an apparently valid request.\n\n**8. HTTP Caching**\n\n* **Purpose**: Caching is used to store copies of responses to improve performance and reduce server load.\n\n* **Mechanism**:\n\n* **`Cache-Control`**: A header that provides caching directives for both requests and responses.\n\n* **`ETag`**: An identifier for a specific version of a resource.\n\n* **`Last-Modified`**: The date and time when the resource was last modified.\n\nThese headers allow the client to make conditional requests, and the server can respond with a `304 Not Modified` status if the resource has not changed.\n\n**9. Content Negotiation**\n\n* **Purpose**: A mechanism that allows the client and server to agree on the best representation of a resource when multiple representations are available.\n\n* **Types**:\n\n* **Media Type**: The client can specify the desired media type (e.g., `application/json`, `text/html`) using the `Accept` header.\n\n* **Language**: The client can specify the preferred language using the `Accept-Language` header.\n\n* **Encoding**: The client can specify the supported content encodings (e.g., `gzip`) using the `Accept-Encoding` header.\n\n* **HTTP Compression**: Servers can compress the response body to reduce the amount of data transferred, which improves performance.\n\n**10. Persistent Connections (`Keep-Alive`)**\n\n* **Concept**: In HTTP 1.1 and later, a single TCP connection can be kept open and reused for multiple HTTP requests and responses. This avoids the overhead of establishing a new connection for each request.\n\n* **Headers**: The `Connection: keep-alive` header is used to request a persistent connection.\n\n**11. Handling Large Requests and Responses**\n\n* **Large Requests (Client to Server)**: For uploading large files, multipart requests (`multipart/form-data`) are used. The request body is divided into multiple parts, each with its own headers.\n\n* **Large Responses (Server to Client)**: For sending large responses, the server can use chunked transfer encoding, where the response body is sent in a series of chunks.\n\n**12. SSL/TLS/HTTPS Overview**\n\n* **SSL (Secure Sockets Layer)**: The original protocol for encrypting communication between a client and a server. It is now considered insecure and has been replaced by TLS.\n\n* **TLS (Transport Layer Security)**: The modern standard for securing communication over a computer network. It provides privacy and data integrity between two communicating applications.\n\n* **HTTPS (HTTP Secure)**: This is HTTP over TLS. It ensures that the communication between the client and the server is encrypted and secure.",
          "excerpt": "A comprehensive overview of HTTP fundamentals, including version evolution, request-response structures, headers, and standard methods for web communication.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-08-21T16:47:37.623Z"
        },
        {
          "id": "404-backend-routing-md",
          "slug": "404-backend/routing",
          "filepath": "404-BACKEND/Routing.md",
          "folder": "404-BACKEND",
          "filename": "Routing.md",
          "frontmatter": {
            "title": " Backend Routing: How Requests Find Their Way Home",
            "date": "2025-10-08",
            "tags": [
              "backend",
              "routing",
              "api-design",
              "rest-api",
              "http-methods",
              "web-development"
            ],
            "category": "404-BACKEND",
            "description": "A comprehensive guide to backend routing covering HTTP methods, static and dynamic routes, parameters, nested resources, and API versioning."
          },
          "content": "\n##  Backend Routing: How Requests Find Their Way Home\n\n### 1. Fundamentals of Routing\n\n|Request Component|Purpose (The \"What\" vs. The \"Where\")|\n|---|---|\n|**HTTP Method** (e.g., GET, POST)|Expresses the **intent** or **action** (the **What**) the client wants to perform (e.g., fetch data, add data, delete data).|\n|**Route Path** (URL Path)|Expresses the **address** or **resource** (the **Where**) the action should be performed on (e.g., `/users`, `/products`).|\n|**Routing Definition**|Routing is the process of mapping the unique combination of the **HTTP Method** and the **Route Path** to a specific server-side handler or set of instructions (business logic).|\n\n### 2. Types of Routes\n\nThe backend categorizes routes based on how the URL path is defined and what kind of data is passed.\n\n#### A. Static Routes\n\n- **Definition:** Routes where the path remains constant and contains no variable parameters.\n    \n- **Characteristic:** The string in the path is fixed (e.g., `/api/books`).\n    \n- **Mapping Example:**\n    \n    - `GET /api/books` maps to a handler that returns a list of books.\n        \n    - `POST /api/books` maps to a handler that creates a new book.\n        \n    - _The same path can be used for different methods, mapping to unique logic._\n        \n\n#### B. Dynamic Routes (Path/Route Parameters)\n\n- **Definition:** Routes that contain a dynamic, variable segment within the URL path, used to identify a specific resource.\n    \n- **Usage:** Serves as a **semantic expression** of the resource's identity.\n    \n- **Server Convention:** In the server-side definition, the dynamic part is typically marked with a colon (e.g., `:ID`).\n    \n- **Examples:**\n    \n    - **Request:** `/api/users/`**`123`**\n        \n    - **Server Match:** `/api/users/`**`:ID`**\n        \n    - **Semantic Meaning:** \"Fetch the user resource with ID `123`.\"\n        \n\n**Conceptual Flow of Dynamic Route Matching:**\n\nCode snippet\n\n```\ngraph TD\n    A[Client Sends GET /api/users/123] --> B{Server Route Matcher};\n    B --> C{Matches GET};\n    B --> D{Matches Path Prefix /api/users/};\n    B --> E{Captures '123' as the :ID Parameter};\n    C & D & E --> F[Handler for /api/users/:ID];\n    F --> G[Logic: Fetch user where ID = 123 from DB];\n```\n\n### 3. Parameters in Requests\n\n|Feature|Path/Route Parameters|Query Parameters|\n|---|---|---|\n|**Location**|Part of the main URL path, following a forward slash (`/`).|Appended to the end of the path, starting with a question mark (`?`).|\n|**Format**|`/resource/:id`|`?key1=value1&key2=value2`|\n|**Semantic Role**|**Essential**Defines the specific resource being requested (its address/identity).|**Supplemental**Sends metadata, filtering, sorting, or pagination criteria.|\n|**Typical Use**|Fetching a single item by ID (`/posts/456`).|Used primarily in `GET` requests (which lack a request body) to send extra key-value data.|\n|**Example**|`/users/`**`123`**|`/books?`**`page=2`**`&limit=20`|\n\n### 4. Advanced Routing Concepts\n\n#### A. Nested Routes\n\n- **Definition:** A structuring practice where the route path reflects the hierarchical relationship between different resources.\n    \n- **Purpose:** Provides a human-readable, highly semantic expression of a relationship.\n    \n- **Example:**\n    \n    - `GET /api/users/123/posts/456`\n        \n    - **Interpretation:** Fetch the specific post with ID **`456`** that belongs to the user with ID **`123`**.\n        \n\n#### B. Route Versioning and Deprecation\n\n- **Definition:** Including an API version (e.g., `v1`, `v2`) directly in the route path.\n    \n- **Purpose:** Allows developers to introduce **breaking changes** (like modifying a field name in the JSON response) without immediately breaking existing clients.\n    \n- **Workflow:**\n    \n    1. Client uses old route: `/api/`**`v1`**`/products`.\n        \n    2. New requirements mandate a change. A new version is released: `/api/`**`v2`**`/products`.\n        \n    3. Front-end clients are given a grace period to migrate from `v1` to `v2`.\n        \n    4. `v1` is eventually **deprecated** and removed, maintaining a stable API.\n        \n\n|Version|Example Path|Product Response Change|\n|---|---|---|\n|**V1**|`/api/v1/products`|Field name is **`name`**|\n|**V2**|`/api/v2/products`|Field name is **`title`**|\n\n#### C. Catch-All Route\n\n- **Definition:** The final, default route configured on the server, designed to match any request that has not been matched by any specific route (static, dynamic, or nested).\n    \n- **Server Convention:** Usually set up with a wildcard path (e.g., `/*`).\n    \n- **Purpose:** To provide a graceful error handling mechanism. Instead of returning a technical or null error, the Catch-All Handler returns a user-friendly \"Route Not Found\" message (typically a 404 status code).",
          "excerpt": "A comprehensive guide to backend routing covering HTTP methods, static and dynamic routes, parameters, nested resources, and API versioning.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-10-08T05:38:05.407Z"
        },
        {
          "id": "404-backend-osi-model-md",
          "slug": "404-backend/osi-model",
          "filepath": "404-BACKEND/OSI Model.md",
          "folder": "404-BACKEND",
          "filename": "OSI Model.md",
          "frontmatter": {
            "title": " The 7 Layers of the OSI Model",
            "date": "2025-10-08",
            "tags": [
              "networking",
              "osi-model",
              "protocols",
              "backend",
              "architecture",
              "infrastructure"
            ],
            "category": "404-BACKEND",
            "description": "A detailed overview of the seven OSI layers, explaining network communication protocols and data encapsulation from the physical to the application layer."
          },
          "content": "\nThe OSI model helps engineers and developers design, troubleshoot, and understand complex networking systems.\n\n---\n\n##  The 7 Layers of the OSI Model\n\n| **Layer** | **Name** | **Function / Purpose** |\n|------------|-----------|------------------------|\n| **7** | **Application Layer** | Provides network services directly to the end-user applications (e.g., web browsers, email clients). |\n| **6** | **Presentation Layer** | Translates data between the application and network formats  handles encryption, compression, and serialization. |\n| **5** | **Session Layer** | Manages sessions or connections between local and remote applications. |\n| **4** | **Transport Layer** | Responsible for reliable data transfer, error detection, and flow control (e.g., TCP, UDP). |\n| **3** | **Network Layer** | Deals with logical addressing and routing of data packets (e.g., IP addresses, routers). |\n| **2** | **Data Link Layer** | Ensures reliable transmission of data frames between two directly connected nodes (e.g., Ethernet, MAC addresses). |\n| **1** | **Physical Layer** | Concerned with the physical transmission of bits over a medium (e.g., cables, switches, radio waves). |\n\n---\n\n###  Layer 1: **Physical Layer**\n- **Purpose**: Transmits raw bits (0s and 1s) over a physical medium.  \n- **Devices**: Hubs, repeaters, cables, connectors.  \n- **Examples**: Ethernet cables (Cat5/6), fiber optics, radio frequencies.  \n- **Functions**:\n  - Defines voltage levels, bit timings, and data rates.\n  - Specifies connectors and interface standards (e.g., RS-232, IEEE 802.3).\n\n---\n\n###  Layer 2: **Data Link Layer**\n- **Purpose**: Provides error detection and correction for reliable node-to-node communication.  \n- **Divided into two sub-layers**:  \n  1. **LLC (Logical Link Control)**  Manages communication between devices and multiplexing.  \n  2. **MAC (Media Access Control)**  Determines who can transmit data over the network.  \n- **Devices**: Switches, bridges.  \n- **Protocols**: Ethernet, PPP (Point-to-Point Protocol), HDLC.  \n- **Address Type**: MAC address (physical address).\n\n---\n\n###  Layer 3: **Network Layer**\n- **Purpose**: Handles logical addressing and routing  determines the best path for data.  \n- **Devices**: Routers, Layer 3 switches.  \n- **Protocols**: IP (IPv4, IPv6), ICMP, ARP, RIP, OSPF, BGP.  \n- **Address Type**: IP address.  \n- **Functions**:\n  - Packet forwarding and routing.\n  - Fragmentation and reassembly of packets.\n\n---\n\n###  Layer 4: **Transport Layer**\n- **Purpose**: Ensures reliable data delivery across the network.  \n- **Devices**: Gateways, firewalls (some operate here).  \n- **Protocols**: TCP (Transmission Control Protocol), UDP (User Datagram Protocol).  \n- **Functions**:\n  - **Segmentation** and **reassembly** of data.\n  - **Error control** and **flow control**.\n  - **Port addressing** (e.g., HTTP  port 80, HTTPS  port 443).\n\n---\n\n###  Layer 5: **Session Layer**\n- **Purpose**: Establishes, manages, and terminates connections between applications.  \n- **Functions**:\n  - Session establishment and teardown.\n  - Synchronization (e.g., checkpoints for long data transfers).  \n- **Example**: Keeping a user logged in during a web session.\n\n---\n\n###  Layer 6: **Presentation Layer**\n- **Purpose**: Translates data formats for the application layer and the network.  \n- **Functions**:\n  - Data **encryption** and **decryption**.\n  - **Data compression** and **decompression**.\n  - **Format translation** (e.g., converting EBCDIC to ASCII).  \n- **Examples**:\n  - SSL/TLS encryption.\n  - JPEG, MP3, and MPEG formats.\n\n---\n\n###  Layer 7: **Application Layer**\n- **Purpose**: Closest to the end user. Provides network services to applications.  \n- **Functions**:\n  - Enables user interaction with network.\n  - Interfaces with software that uses the network.  \n- **Examples**:\n  - HTTP, HTTPS, FTP, SMTP, POP3, IMAP, DNS, DHCP.\n\n---\n\n##  Mnemonics to Remember the OSI Layers\n\nFrom **Layer 7  1 (top-down)**:  \n> **A**ll **P**eople **S**eem **T**o **N**eed **D**ata **P**rocessing\n\nFrom **Layer 1  7 (bottom-up)**:  \n> **P**lease **D**o **N**ot **T**hrow **S**ausage **P**izza **A**way\n\n---\n\n##  Data Encapsulation & Decapsulation\n\nWhen data moves **down** the OSI model (transmission):\n1. Application data  encapsulated into segments, packets, frames, and finally bits.  \n2. Each layer adds its own **header** to the data (called **encapsulation**).\n\nWhen data moves **up** the OSI model (reception):\n1. Each layer **removes** its corresponding header (called **decapsulation**).\n\nThis ensures the data is interpreted correctly at both sender and receiver ends.\n\n---\n\n##  Real-World Example\n\nWhen you open a web page (like `https://example.com`):\n\n1. **Application (Layer 7)**: Browser uses HTTP/HTTPS to request web content.  \n2. **Presentation (Layer 6)**: SSL/TLS encrypts the data.  \n3. **Session (Layer 5)**: A secure session is established between you and the website.  \n4. **Transport (Layer 4)**: TCP breaks data into segments and ensures packets arrive in order.  \n5. **Network (Layer 3)**: IP handles logical addressing and routing.  \n6. **Data Link (Layer 2)**: Ethernet manages MAC addressing and error detection.  \n7. **Physical (Layer 1)**: Data is converted to electrical or optical signals and transmitted.\n\n---\n",
          "excerpt": "A detailed overview of the seven OSI layers, explaining network communication protocols and data encapsulation from the physical to the application layer.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-10-08T06:12:57.422Z"
        },
        {
          "id": "404-backend-authentication-and-authorization-md",
          "slug": "404-backend/authentication-and-authorization",
          "filepath": "404-BACKEND/Authentication and Authorization.md",
          "folder": "404-BACKEND",
          "filename": "Authentication and Authorization.md",
          "frontmatter": {
            "title": " Key Differences and Mechanism B/W JWT and Sessions",
            "date": "2025-10-13",
            "tags": [
              "jwt",
              "sessions",
              "authentication",
              "authorization",
              "backend",
              "rbac",
              "stateless",
              "security"
            ],
            "category": "404-BACKEND",
            "description": "A technical guide comparing stateful session-based and stateless JWT authentication, covering scalability, revocation, and role-based access control."
          },
          "content": "\n### 1. Core Concepts: Who vs. What \n\n|Concept|Question Answered|Definition|Example|\n|---|---|---|---|\n|**Authentication (AuthN)**|**Who are you?**|The mechanism to assign an **identity** to a subject (user or system).|Providing a **username and password** to log in.|\n|**Authorization (AuthZ)**|**What can you do?**|The process of verifying a subject's **permissions** and capabilities within a system after they have been identified.|An **Admin** can delete a user, but a **Standard User** cannot.|\n\n---\n\n### 2. Historical Evolution of Authentication\n\nAuthentication methods evolved based on different principles of proof, moving from implicit trust to digital cryptography.\n\n|Era|Mechanism|Principle of Proof|Key Evolution|\n|---|---|---|---|\n|**Pre-Industrial**|Handshake, Vouching|**Implicit Trust**|Based on human contextual trust; failed to scale.|\n|**Medieval**|Wax Seals|**Something You Possess** (Physical Token)|Early authentication tokens; vulnerable to forgery (bypass attacks).|\n|**Industrial**|Passphrases (Telegraph)|**Something You Know** (Shared Secret)|Static passwords; led to the need for secure storage.|\n|**Modern Digital** (1960s-1970s)|Passwords on Mainframes|**Computational Secrets**|Vulnerabilities (plain text storage) led to **hashing** algorithms to secure passwords.|\n|**Modern Frameworks** (21st Century)|JWTs, OAuth 2.0, MFA|**Multiple Factors**|Combined knowledge, possession, and biometrics; enabled scalable, decentralized identity management.|\n\n---\n\n### 3. Key Components for State Management\n\nBefore modern methods, HTTP's **stateless** nature (treating every request as isolated) required mechanisms to maintain session memory.\n\n|Component|Function|Use Case|Diagram|\n|---|---|---|---|\n|**Session**|Creates a temporary, **stateful** server-side context for a user. The server stores user data (cart items, roles) mapped to a unique **Session ID**.|Tracking logged-in state, shopping carts in e-commerce.||\n|**Cookie**|A small piece of information stored in the user's browser by the server. It is the common transport layer for Session IDs or JWTs back to the server.|Sending the Session ID or JWT with every subsequent request.||\n|**JWT (JSON Web Token)**|A self-contained, cryptographically signed token that holds user information (**claims**) like ID and role.|Stateless authentication, distributed microservices.|**Structure:** `Header.Payload.Signature`|\n\n#### Comparison: Sessions vs. JWTs\n\n|Feature|Session-Based (Stateful)|JWT-Based (Stateless)|\n|---|---|---|\n|**Server State**|**Requires** server-side storage (Redis/DB) for session data.|**No** server-side session storage required; state is in the token.|\n|**Scalability**|Lower; synchronizing data across distributed servers causes latency.|Higher; any server with the secret key can validate the token.|\n|**Revocation**|Easy (delete the session ID from storage in real-time).|Difficult (token is valid until it expires; requires complex \"blacklist\" lookups).|\n\n---\n\n### 4. Authentication Architectures (When to Use What)\n\n|Type|Mechanism|Key Advantage|Ideal Use Case|\n|---|---|---|---|\n|**Stateful**|Session ID + Server-Side Storage + Cookie|Centralized control, easy real-time revocation.|Traditional **Web Apps** (Server-Side Rendered or Monoliths).|\n|**Stateless**|JWT (Self-Contained Token)|Scalable, no session dependency, ideal for distributed systems.|**APIs** (Microservices) and **Mobile Apps**.|\n|**API Key**|Cryptographically random, long-lived secret key.|Simple, programmatic access.|**Machine-to-Machine** (M2M) communication (e.g., your server calling ChatGPT API).|\n|**OAuth 2.0 / OIDC**|Delegation via tokens (Access Tokens, ID Tokens).|Securely grants limited access to a third-party app without sharing passwords.|**\"Sign In with Google/Facebook\"** features (Third-party integrations).|\n\n---\n\n### 5. Authorization: Role-Based Access Control (RBAC)\n\nAuthorization determines the level of access an authenticated user has to resources.\n\n- **RBAC Principle:** Permissions are assigned to **roles**, and roles are assigned to **users**. This simplifies management by grouping capabilities.\n    \n- **Workflow:**\n    \n    1. User authenticates and the server determines their **Role** (e.g., `User`, `Admin`, `Moderator`).\n        \n    2. User requests a resource (e.g., `POST /notes`).\n        \n    3. The backend logic checks if the user's assigned **Role** has the **Permission** (`Write`) to perform the **Action** (`POST`) on the **Resource** (`Notes`).\n        \n    4. If not authorized, the server returns a **403 Forbidden** error.\n        \n\n---\n\n### 6. Security Considerations \n\nBackend engineers must follow strict protocols to prevent security exploits during the AuthN flow.\n\n| Attack Type             | Vulnerability                                                                                                                                                                  | Defense Strategy                                                                                                                                                     |\n| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Information Leakage** | Sending specific error messages (e.g., \"User Not Found,\" \"Incorrect Password\") gives attackers clues about valid accounts.                                                     | Always send **generic** error messages (e.g., \"**Authentication failed**\") to prevent attackers from confirming valid usernames.                                     |\n| **Timing Attacks**      | If the server responds faster when a username is invalid (failing early) versus when a password is wrong (failing late after hashing), the response time can leak information. | **Equalize response times** by either using constant-time password comparison functions or simulating a small delay (`sleep` function) in the invalid username path. |\n|                         |                                                                                                                                                                                |                                                                                                                                                                      |\n\n\n---\n---\n\n##  Key Differences and Mechanism B/W JWT and Sessions\n\n| Feature               | Session-Based Authentication                                                                                                                                           | JWT Authentication                                                                                                                                                                                              |\n| --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Statefulness**      | **Stateful** (Server maintains the user's session record).                                                                                                             | **Stateless** (Server does not store the session; the token contains all necessary data).                                                                                                                       |\n| **Data Storage**      | Session data (user ID, roles, expiry) is stored securely on the **server** (in-memory, database, or Redis).                                                            | The JWT token (user data/claims) is stored on the **client** (browser storage, cookie).                                                                                                                         |\n| **Validation**        | Server receives an opaque **Session ID** (usually in a cookie), which it must **look up** in its session store/database to verify the user and retrieve their details. | Server receives the **JWT** (usually in an `Authorization` header), which it verifies locally using a **secret key** to validate the signature and extract user claims. No database lookup is typically needed. |\n| **Token Type**        | **Opaque Reference Token** (A meaningless random string/ID).                                                                                                           | **Self-Contained Token** (A string that encodes and signs actual user data).                                                                                                                                    |\n| **Default Transport** | **Cookie** (The browser automatically attaches the Session ID).                                                                                                        | **Authorization Header** (The client app manually attaches the token as `Bearer <token>`).                                                                                                                      |\n\n### Session Authentication Flow (Stateful)\n\n1. **Login:** The user sends credentials.\n    \n2. **Creation:** The server verifies credentials, creates a session object in the **database** (or cache), and generates a unique, opaque **Session ID**.\n    \n3. **Delivery:** The Session ID is sent back to the client, usually inside an **HTTP-only cookie**.\n    \n4. **Subsequent Request:** The client automatically sends the cookie (containing the Session ID) with every request.\n    \n5. **Authorization:** The server must perform a **database lookup** using the Session ID to retrieve the user's data and confirm the session is still active.\n    \n\n### JWT Authentication Flow (Stateless)\n\n1. **Login:** The user sends credentials.\n    \n2. **Creation:** The server verifies credentials, creates a **JWT** that includes user claims (ID, role, expiry time), and signs it with a secret key.\n    \n3. **Delivery:** The signed JWT is sent back to the client.\n    \n4. **Subsequent Request:** The client stores the JWT and sends it in the `Authorization: Bearer` header with every request.\n    \n5. **Authorization:** The server uses the secret key to **verify the token's signature**. If valid, the user's identity and permissions are read directly from the token payload, **skipping a database call.**\n    \n\n---\n\n##  Trade-offs: Scalability, Control, and Security\n\nThe choice between the two often comes down to prioritizing **scalability/performance** (JWT) versus **real-time control/simplicity** (Session).\n\n### 1. Scalability and Performance\n\n- **JWT Advantage:** Since JWTs are stateless, they are highly scalable. Any server (in a load-balanced or microservices architecture) can validate a JWT without having to share or query a centralized session database. This eliminates the database lookup latency and reduces server load, making it ideal for distributed systems.\n    \n- **Session Disadvantage:** Scaling session-based apps requires complex solutions like **sticky sessions** (forcing a user to hit the same server) or **centralized session stores** (like Redis), which introduces architectural complexity and the performance overhead of a constant session lookup on every request.\n    \n\n### 2. Revocation and Control (The \"Kill Switch\")\n\n- **Session Advantage:** Sessions offer immediate, real-time revocation. If a user logs out, changes their password, or is suspected of malicious activity, the server simply **deletes the session record** from the database, instantly invalidating the Session ID.\n    \n- **JWT Disadvantage:** JWTs are problematic for real-time revocation. Once a JWT is issued, it remains valid until its built-in **expiration time** because the server holds no state to check against. To revoke a token early (e.g., after a user logs out), the server must implement a **blacklist** or revocation list, which partially defeats the purpose of being stateless and introduces a required database lookup again.\n    \n\n### 3. Security Considerations\n\n|Aspect|Session-Based Security|JWT Security|\n|---|---|---|\n|**Data Exposure**|**Low.** The client only has an opaque ID; all user data is safely on the server.|**Medium/High.** The user data (payload) is visible to the client (Base64-encoded, not encrypted) and must **not** contain sensitive information.|\n|**CSRF Protection**|Vulnerable to **Cross-Site Request Forgery (CSRF)** attacks because cookies are automatically sent. Requires implementing anti-CSRF tokens.|Less vulnerable when sent via the `Authorization` header, as it is not automatically attached by the browser.|\n|**Storage Risk**|Lower risk if the Session ID is stored in an **HTTP-only cookie** (preventing JavaScript access via XSS).|Vulnerable to **Cross-Site Scripting (XSS)** if stored in `localStorage` (as malicious JavaScript can easily steal the token). Best stored in an **HTTP-only cookie**.|\n",
          "excerpt": "A technical guide comparing stateful session-based and stateless JWT authentication, covering scalability, revocation, and role-based access control.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-10-13T13:04:12.299Z"
        },
        {
          "id": "404-backend-controllers--services--repositories--middlewares-md",
          "slug": "404-backend/controllers,-services,-repositories,-middlewares",
          "filepath": "404-BACKEND/Controllers, Services, Repositories, Middlewares.md",
          "folder": "404-BACKEND",
          "filename": "Controllers, Services, Repositories, Middlewares.md",
          "frontmatter": {
            "title": " What Are Controllers, Services, Repositories, Middlewares, and Request Context?",
            "date": "2025-11-11",
            "tags": [
              "backend",
              "software-architecture",
              "design-patterns",
              "middleware",
              "api-development",
              "web-development"
            ],
            "category": "404-BACKEND",
            "description": "An overview of backend architecture patterns including the Controller-Service-Repository layers, middleware functions, and request context management."
          },
          "content": "\n#  What Are Controllers, Services, Repositories, Middlewares, and Request Context?\n\n\n---\n\n##  1. ControllerServiceRepository Pattern\n\nA foundational pattern that **separates concerns** in backend design, improving scalability, maintainability, and readability.\n\n###  Request Flow\n\n**Request  Controller  Service  Repository  Database  Response**\n\n---\n\n###  Controllers (a.k.a. Handlers)\n\nThe **entry point** of your application logic.\nIt directly interacts with HTTP requests and responses.\n\n**Responsibilities:**\n\n1. **Binding / Deserialization:**\n   Convert raw request data (e.g., JSON) into usable objects or classes.\n    Invalid input  send `400 Bad Request`.\n\n2. **Validation:**\n   Check that data meets all constraints  required fields, formats, types.\n\n3. **Transformation:**\n   Apply defaults or transformations before processing (e.g., add default pagination or sort order).\n\n4. **Delegation:**\n   Pass cleaned and validated data to the service layer.\n\n5. **Response Formation:**\n   Send back the appropriate HTTP response with status codes (200, 201, 404, 500, etc.).\n\n**In short:**\n *Controller = Interface between client and server logic.*\n\n---\n\n###  Services\n\nContain the **business logic**  the ***brains*** of your application.\n\n**Characteristics:**\n\n* Independent of HTTP or network layers.\n* Can be reused by multiple controllers.\n\n**Responsibilities:**\n\n1. **Business Processing:** Perform computations, decisions, or actions (e.g., send notifications, process payments).\n2. **Orchestration:** Combine multiple repository results to form complex outputs.\n3. **Database Interaction:** Call repository methods for data fetching or updates.\n\n**In short:**\n *Service = **Performs business logic and coordinates data sources**.*\n\n---\n\n###  Repositories\n\nThe **data access layer**  ***interacts directly with the database***.\n\n**Responsibilities:**\n\n* Execute database queries or ORM operations.\n* Perform single-purpose actions (like `findById`, `createUser`, `getAllBooks`).\n* Return raw or structured data to the service layer.\n\n**In short:**\n Repository = ***Talks to the database; one function, one purpose***.*\n\n---\n\n##  2. Middlewares\n\nMiddlewares are ***functions that process requests before reaching the controller (or after responses).***\n\nThey form a **chain** through which every request passes.\n\n###  How Middlewares Work\n\nEach middleware:\n\n```js\n(req, res, next) => { ... }\n```\n\n* Performs a specific task.\n* Calls `next()` to continue the chain.\n* Or sends a response early (e.g., error or access denied).\n\n**Order matters!**\nThey are executed in the exact order they are registered.\n\n---\n\n###  Common Middlewares and Their Uses\n\n| Middleware                | Purpose                                                            |\n| ------------------------- | ------------------------------------------------------------------ |\n| **Logging**               | Log each requests method, path, and timestamp.                    |\n| **CORS**                  | Add `Access-Control-Allow-Origin` headers for cross-origin access. |\n| **Authentication**        | Verify tokens and block unauthorized requests (`401`).             |\n| **Rate Limiting**         | Prevent abuse by limiting requests per IP (`429`).                 |\n| **Global Error Handling** | Catch and standardize all errors (`try/catch` alternative).        |\n| **Body Parsing**          | Automatically parse JSON or form data from requests.               |\n\n**Main Goal:**\n *Avoid duplication by centralizing shared logic.*\n\n---\n\n##  3. Request Context\n\nThe **Request Context** is like a private, ***temporary storage attached to each request***.\nIt exists **only for the duration of that request**.\n\n###  Purpose\n\n* Pass data *downstream* through middlewares, services, and handlers.\n* Avoid tight coupling and long parameter chains.\n\n---\n\n###  Common Use Cases\n\n#### 1. Authentication Data\n\n* Middleware authenticates a token  extracts `user_id`, `role`.\n* Stores these in the request context.\n* Handlers later read them to know *who* is making the request  securely and consistently.\n\n#### 2. Distributed Tracing (Request ID)\n\n* Middleware generates a unique `request_id` (UUID).\n* Stored in context and included in every log.\n* Enables tracking a single request across multiple services (useful in microservices).\n\n#### 3. Cancellation Signals\n\n* Context can signal when a request is cancelled or times out.\n* Useful for graceful shutdowns or aborting DB/network calls if a client disconnects.\n\n---\n\n##  Summary Overview\n\n| Layer               | Role                            | Should Know About HTTP? | Example Task                  |\n| ------------------- | ------------------------------- | ----------------------- | ----------------------------- |\n| **Controller**      | Entry point, validates & routes |  Yes                   | Validate user input           |\n| **Service**         | Business logic                  |  No                    | Calculate invoice total       |\n| **Repository**      | Data access                     |  No                    | Fetch users from DB           |\n| **Middleware**      | Pre-/Post-processing            |  Yes                   | Check authentication token    |\n| **Request Context** | Request-specific data           |  Scoped                | Store `user_id`, `request_id` |\n\n---\n\n##  Key Takeaways\n\n* **Controllers:** Handle requests & responses.\n* **Services:** Implement the core logic.\n* **Repositories:** Manage database access.\n* **Middlewares:** Handle reusable request logic.\n* **Request Context:** Pass request-scoped data without coupling.\n\nThis architecture ensures:\n High cohesion\n Low coupling\n Better testability\n Cleaner codebase\n\n---\n",
          "excerpt": "An overview of backend architecture patterns including the Controller-Service-Repository layers, middleware functions, and request context management.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-11-11T17:36:49.467Z"
        },
        {
          "id": "404-backend-ratelimiting-implimentation-md",
          "slug": "404-backend/ratelimiting-implimentation",
          "filepath": "404-BACKEND/RateLimiting Implimentation.md",
          "folder": "404-BACKEND",
          "filename": "RateLimiting Implimentation.md",
          "frontmatter": {
            "title": "RateLimiting Implimentation",
            "date": "2025-11-13",
            "tags": [
              "js"
            ],
            "category": "404-BACKEND"
          },
          "content": "\n```js\n/*\n  nodejs-rate-limiter.js\n  A flexible, production-ready rate limiting middleware for Express (Node.js).\n\n  Features:\n    - Pluggable stores: Redis (distributed) and in-memory (single-process fallback)\n    - Sliding window implementation in Redis using sorted sets for accurate limits\n    - Configurable window size and max requests, per-key identification (IP, user id)\n    - Response headers: RateLimit-Limit, RateLimit-Remaining, RateLimit-Reset\n    - Customizable callbacks and behavior when limit exceeded\n    - Easy Express integration\n\n  Usage example:\n    const express = require('express');\n    const createRateLimiter = require('./nodejs-rate-limiter');\n\n    // create Redis client (ioredis or node-redis compatible)\n    const Redis = require('ioredis');\n    const redis = new Redis();\n\n    const limiter = createRateLimiter({\n      windowMs: 60_000,          // 1 minute window\n      max: 100,                  // max 100 requests per window per key\n      redisClient: redis,        // optional, for distributed limiting\n      keyGenerator: (req) => req.user?.id || req.ip,\n      trustProxy: true,\n    });\n\n    const app = express();\n    app.use(limiter.middleware());\n\n    app.get('/', (req, res) => res.send('ok'));\n\n    app.listen(3000);\n*/\n\nconst DEFAULTS = {\n  windowMs: 60_000,\n  max: 60,\n  message: 'Too many requests, please try again later.',\n  headers: true,\n  keyPrefix: 'rl:',\n  trustProxy: false,\n  store: 'redis', // 'redis' | 'memory'\n};\n\nfunction createRateLimiter(options = {}) {\n  const cfg = Object.assign({}, DEFAULTS, options);\n\n  if (cfg.store === 'redis' && !cfg.redisClient) {\n    console.warn('[rate-limiter] store=redis but no redisClient provided  falling back to memory store');\n    cfg.store = 'memory';\n  }\n\n  const store = cfg.store === 'redis' ? createRedisStore(cfg) : createMemoryStore(cfg);\n\n  function middleware() {\n    return async function rateLimitMiddleware(req, res, next) {\n      try {\n        const key = (cfg.keyPrefix || '') + (await (cfg.keyGenerator ? cfg.keyGenerator(req) : defaultKeyGenerator(req, cfg)));\n\n        const now = Date.now();\n        const result = await store.increment(key, now);\n        // result: { current, remaining, reset }\n\n        if (cfg.headers) {\n          res.setHeader('RateLimit-Limit', String(cfg.max));\n          res.setHeader('RateLimit-Remaining', String(Math.max(0, result.remaining)));\n          res.setHeader('RateLimit-Reset', String(Math.ceil(result.reset / 1000))); // seconds until reset\n        }\n\n        if (result.current > cfg.max) {\n          // Exceeded\n          if (cfg.onLimitReached) {\n            // allow custom handling (logging, metrics)\n            try { cfg.onLimitReached(req, { key, result, cfg }); } catch (e) { /* ignore */ }\n          }\n\n          res.status(cfg.statusCode || 429);\n          // Recommended to include Retry-After header in seconds\n          const retryAfterSec = Math.ceil(result.reset / 1000);\n          res.setHeader('Retry-After', String(retryAfterSec));\n\n          if (typeof cfg.handler === 'function') return cfg.handler(req, res, next);\n\n          return res.json({ error: cfg.message, retry_after_seconds: retryAfterSec });\n        }\n\n        // allowed\n        return next();\n      } catch (err) {\n        // If the store fails, decide whether to allow or block. Default: allow (fail-open)\n        console.error('[rate-limiter] error', err);\n        if (cfg.failClosed) {\n          return res.status(500).json({ error: 'rate limiter error' });\n        }\n        return next();\n      }\n    };\n  }\n\n  return { middleware };\n}\n\nfunction defaultKeyGenerator(req, cfg) {\n  // Use IP by default. If trustProxy is true, use req.ip (express handles X-Forwarded-For if trust proxy configured on app)\n  if (cfg.trustProxy && req.ip) return req.ip;\n  // fallback to remote address\n  return (req.ip || req.connection?.remoteAddress || 'unknown');\n}\n\n// --- Memory store (single-process) ---\nfunction createMemoryStore(cfg) {\n  // Token-bucket inspired sliding window using timestamps array per key\n  const clients = new Map();\n  const windowMs = cfg.windowMs;\n  const max = cfg.max;\n\n  // periodic cleanup to avoid memory growth\n  const CLEANUP_INTERVAL = Math.max(60_000, Math.floor(windowMs * 2));\n  const cleanupHandle = setInterval(() => {\n    const now = Date.now();\n    for (const [key, item] of clients.entries()) {\n      if (item.lastSeen + windowMs * 2 < now) clients.delete(key);\n    }\n  }, CLEANUP_INTERVAL).unref();\n\n  async function increment(key, now) {\n    let item = clients.get(key);\n    if (!item) {\n      item = { timestamps: [], lastSeen: now };\n      clients.set(key, item);\n    }\n    item.lastSeen = now;\n    const cut = now - windowMs;\n    // keep only timestamps within window\n    item.timestamps = item.timestamps.filter(ts => ts > cut);\n    item.timestamps.push(now);\n\n    const current = item.timestamps.length;\n    const remaining = Math.max(0, max - current);\n    // compute reset time: earliest timestamp in window + windowMs - now\n    const reset = item.timestamps[0] ? (item.timestamps[0] + windowMs - now) : windowMs;\n\n    return { current, remaining, reset };\n  }\n\n  // expose store API\n  return { increment };\n}\n\n// --- Redis store (distributed, sliding window using sorted set) ---\nfunction createRedisStore(cfg) {\n  const redis = cfg.redisClient;\n  const windowMs = cfg.windowMs;\n  const max = cfg.max;\n  const prefix = cfg.keyPrefix || 'rl:';\n\n  // Lua script could be used for atomicity; but we'll use sorted-set commands which are atomic per command sequence\n  async function increment(key, now) {\n    const redisKey = key;\n    const min = now - windowMs;\n\n    // Use pipeline for efficiency\n    const pipeline = redis.multi();\n    pipeline.zadd(redisKey, 'NX', now, String(now));\n    pipeline.zremrangebyscore(redisKey, 0, min);\n    pipeline.zcard(redisKey);\n    pipeline.pexpire(redisKey, windowMs + 1000);\n\n    const execRes = await pipeline.exec();\n    // execRes is array of results for each command\n    // zadd -> [null, 1]\n    // zremrangebyscore -> [null, count]\n    // zcard -> [null, card]\n    // pexpire -> [null, 1]\n\n    // When using node-redis or ioredis the shape differs; normalize:\n    const zcardRes = execRes && execRes[2];\n    let current;\n    if (Array.isArray(zcardRes)) {\n      // ioredis returns [null, value]\n      current = Number(zcardRes[1]);\n    } else if (typeof zcardRes === 'number') {\n      current = zcardRes;\n    } else if (zcardRes && zcardRes[1] !== undefined) {\n      current = Number(zcardRes[1]);\n    } else {\n      // fallback: fetch explicitly\n      current = Number(await redis.zcard(redisKey));\n    }\n\n    const remaining = Math.max(0, max - current);\n\n    // Compute reset time: find the earliest timestamp in the sorted set\n    let reset = windowMs;\n    try {\n      const earliest = await redis.zrange(redisKey, 0, 0, 'WITHSCORES');\n      // earliest could be [member, score] or ['member1','member2'] depending on client\n      let score = null;\n      if (Array.isArray(earliest) && earliest.length >= 2) {\n        score = Number(earliest[1]);\n      } else if (Array.isArray(earliest) && earliest.length === 1) {\n        score = Number(earliest[0]);\n      }\n      if (!Number.isNaN(score)) {\n        reset = Math.max(0, Math.ceil((score + windowMs - now)));\n      }\n    } catch (e) {\n      // ignore, fallback to window\n    }\n\n    return { current, remaining, reset };\n  }\n\n  return { increment };\n}\n\nmodule.exports = createRateLimiter;\n\n```\n",
          "excerpt": "",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-11-13T12:56:14.033Z"
        },
        {
          "id": "404-backend-rest-api-design-md",
          "slug": "404-backend/rest-api-design",
          "filepath": "404-BACKEND/REST API DESIGN.md",
          "folder": "404-BACKEND",
          "filename": "REST API DESIGN.md",
          "frontmatter": {
            "title": " **Understanding REST Principles**",
            "date": "2025-11-13",
            "tags": [
              "rest-api",
              "backend",
              "http-methods",
              "web-architecture",
              "api-design",
              "software-engineering"
            ],
            "category": "404-BACKEND",
            "description": "A comprehensive guide to REST architectural principles, core constraints, and best practices for designing scalable and maintainable web APIs using HTTP."
          },
          "content": "\n---\n\n#  **Understanding REST Principles**\n\nREST (**Representational State Transfer**) is an architectural style that defines a set of constraints for creating scalable, maintainable, and reliable web services. REST APIs use HTTP as the communication protocol and are **resource-oriented**, meaning they revolve around entities (resources) rather than actions.\n\n---\n\n##  **Core Principles of REST Architecture**\n\n1. ### **Resource-Based**\n\n   * REST APIs are designed around **resources** (e.g., users, books, orders).\n   * Each resource is identified by a unique **URI (Uniform Resource Identifier)**.\n   * Example:\n\n     * `/users`  Collection of users\n     * `/users/101`  Specific user with ID 101\n\n### 1.  **Stateless**\n\n   * Every client request must include all necessary information for the server to process it.\n   * The **server does not store any client session** between requests.\n   * Benefit: Simplifies scalability and load balancing since any server can handle any request.\n\n### 3.  **Cacheable**\n\n   * Server responses should indicate whether they are **cacheable** or **non-cacheable**.\n   * This allows clients (or proxies) to reuse responses and improve performance.\n   * HTTP headers like `Cache-Control`, `ETag`, and `Expires` are used to control caching.\n\n### 4.  **Uniform Interface**\n\n   * REST APIs must follow a **consistent interface**, using standard HTTP methods:\n\n     * `GET`, `POST`, `PUT`, `PATCH`, `DELETE`\n   * This uniformity simplifies integration and enhances developer experience.\n\n### 5.  **Layered System**\n\n   * REST architecture can consist of **multiple layers** (e.g., caching, load balancers, proxies).\n   * Each layer only communicates with the one directly beneath it.\n   * This modularity improves scalability, security, and flexibility.\n\n---\n\n###  **Why These Principles Matter**\n\nBy adhering to these REST principles, APIs become:\n\n* **Scalable**  Easy to distribute across multiple servers.\n* **Maintainable**  Clear separation of concerns.\n* **Extensible**  New features can be added without breaking existing functionality.\n\n---\n\n#  **Best Practices for Designing REST APIs**\n\nThese conventions ensure your REST API is **robust, predictable, and user-friendly**.\n\n---\n\n## 1 **Use Nouns for Resource Naming**\n\n* REST focuses on *resources*, not actions.\n*  Use: `/users`, `/orders/{id}`\n*  Avoid: `/getUserData`, `/createOrder`\n* Endpoints should represent entities (nouns) rather than operations (verbs).\n\n---\n\n## 2 **Use Hierarchical Resource Naming**\n\n* Represent relationships between resources using a clear hierarchy.\n* Example:\n\n  * `/orders`  All orders\n  * `/orders/{orderId}`  Specific order\n  * `/orders/{orderId}/items`  Items belonging to a specific order\n* This makes your API structure **logical and intuitive**.\n\n---\n\n## 3 **Use HTTP Methods Correctly**\n\n| Method     | Description                                        | Idempotent? | Example      |\n| :--------- | :------------------------------------------------- | :---------: | :----------- |\n| **GET**    | Retrieve a resource                                |     Yes    | `/users/123` |\n| **POST**   | Create a new resource                              |      No    | `/users`     |\n| **PUT**    | Replace an existing resource (or create if absent) |     Yes    | `/users/123` |\n| **PATCH**  | Partially update a resource                        |      No    | `/users/123` |\n| **DELETE** | Remove a resource                                  |     Yes    | `/users/123` |\n\n* Idempotent = Performing the same operation multiple times has the same result.\n\n---\n\n## 4 **Use Appropriate HTTP Status Codes**\n\n| Code                          | Meaning                   | Use Case                     |\n| :---------------------------- | :------------------------ | :--------------------------- |\n| **200 OK**                    | Request successful        | Data retrieved successfully  |\n| **201 Created**               | New resource created      | After POST                   |\n| **204 No Content**            | Success, no response body | After DELETE or PUT          |\n| **400 Bad Request**           | Malformed request         | Invalid syntax or parameters |\n| **401 Unauthorized**          | Authentication required   | Missing/invalid credentials  |\n| **403 Forbidden**             | Access denied             | User lacks permission        |\n| **404 Not Found**             | Resource doesnt exist    | Wrong URI or deleted data    |\n| **500 Internal Server Error** | Server-side issue         | Unexpected error             |\n\nProper use of status codes improves **clarity and debugging** for clients.\n\n---\n\n## 5 **Use Plural Nouns for Resource Naming**\n\n* Use plural form for collections:\n\n  * `/users`  Collection of user resources\n  * `/books`  Collection of book resources\n* Promotes **consistency** and reflects standard REST conventions.\n\n---\n\n## 6 **Consistent Naming and Casing Conventions**\n\n* Choose one style and **stick to it** throughout your API:\n\n  * **kebab-case:** `/user-profiles`\n  * **snake_case:** `/user_profiles`\n  * **camelCase:** common in JSON fields (`firstName`)\n* Consistency ensures better developer experience and readability.\n\n---\n\n## 7 **Use Query Parameters for Filtering and Sorting**\n\n* Allow clients to filter and sort data efficiently.\n\n  * Example:\n\n    * `/users?name=John&age=30`  Filter by name and age\n    * `/books?sort=title&order=asc`  Sort by title in ascending order\n* Makes API more **flexible and client-friendly**.\n\n---\n\n## 8 **Implement API Versioning**\n\nVersioning helps avoid breaking changes for existing clients.\n\n**Common Strategies:**\n\n1. **URI Versioning:** `/v1/users`, `/v2/users`\n2. **Query Parameter:** `/users?version=2`\n3. **Header Versioning:** `Accept: application/vnd.company.v2+json`\n\n Choose one versioning approach and apply it consistently.\n\n---\n\n## 9 **Provide Comprehensive Documentation**\n\n* Good documentation improves adoption and usability.\n* Include:\n\n  * Endpoint list with descriptions\n  * Request/response formats\n  * Example payloads and responses\n* Use tools like:\n\n  * **Swagger (OpenAPI)**\n  * **API Blueprint**\n  * **Postman Collections**\n\n---\n\n##  **Implement Authentication and Authorization**\n\nSecure your API using standard mechanisms:\n\n| Mechanism                 | Description                                                     |\n| ------------------------- | --------------------------------------------------------------- |\n| **API Keys**              | Simple key-based authentication for trusted clients             |\n| **JWT (JSON Web Tokens)** | Token-based authentication for stateless sessions               |\n| **OAuth 2.0**             | Industry standard for delegated access (e.g., login via Google) |\n\nUse **RBAC** (Role-Based Access Control) or **ABAC** (Attribute-Based Access Control) for permissions.\n\n---\n\n## 11 **Support Caching**\n\n* Use caching to enhance performance and reduce server load.\n* Strategies:\n\n  * **Client-side caching**\n  * **Server-side caching**\n  * **Proxy caching**\n* Use headers like:\n\n  * `Cache-Control`\n  * `ETag`\n  * `Expires`\n\n---\n\n## 12 **Handle Errors Gracefully**\n\n* Return **clear and descriptive error messages**.\n* Include:\n\n  * **Error code**\n  * **Message**\n  * **Details (optional)**\n* Example:\n\n  ```json\n  {\n    \"error\": \"InvalidRequest\",\n    \"message\": \"The 'email' field is required.\"\n  }\n  ```\n\n---\n\n## 13 **Use Hypermedia Controls (HATEOAS)**\n\n* HATEOAS = **Hypermedia As The Engine Of Application State**\n* Include navigational links in responses to guide clients.\n* Example:\n\n  ```json\n  {\n    \"id\": 101,\n    \"title\": \"REST API Design\",\n    \"links\": {\n      \"self\": \"/books/101\",\n      \"author\": \"/books/101/author\"\n    }\n  }\n  ```\n* Makes the API **self-descriptive and discoverable**.\n\n---\n\n## 14 **Implement Rate Limiting and Throttling**\n\n* Protect your API from abuse and overload.\n* **Rate Limiting:** Limits the number of requests per user/time window.\n* **Throttling:** Slows down requests when limits are approached.\n* Example:\n\n  * 100 requests per minute per API key\n\n---\n\n## 15 **Monitor and Log API Activity**\n\n* Essential for **debugging**, **analytics**, and **security**.\n* Log details like:\n\n  * Request method and endpoint\n  * Response time and status code\n  * Error messages\n* Use monitoring tools like:\n\n  * Prometheus, Grafana, Datadog, ELK Stack\n\n---\n\n\n---\n",
          "excerpt": "A comprehensive guide to REST architectural principles, core constraints, and best practices for designing scalable and maintainable web APIs using HTTP.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-11-13T13:06:48.904Z"
        },
        {
          "id": "404-backend-dns-working-md",
          "slug": "404-backend/dns-working",
          "filepath": "404-BACKEND/DNS Working.md",
          "folder": "404-BACKEND",
          "filename": "DNS Working.md",
          "frontmatter": {
            "title": "Everything You Need to Know About DNS",
            "date": "2026-01-30",
            "tags": [
              "dns",
              "networking",
              "backend",
              "internet",
              "infrastructure",
              "caching"
            ],
            "category": "404-BACKEND",
            "description": "A comprehensive guide to the Domain Name System (DNS), explaining how domain names are resolved to IP addresses through a hierarchical network of servers."
          },
          "content": "\n# Everything You Need to Know About DNS  \n\n## What is DNS?\n\nDNS is like a phone book for the internet. It maps domain names, such as `www.example.com`, to IP addresses, such as `192.0.2.1`, which are the actual locations of the servers that host the websites. This way, we dont have to memorize long strings of numbers to visit our favorite sites. We can just type in the name and let DNS do the rest.\n\n---\n\n## How does DNS work?\n\nDNS doesnt know everything by itself. It relies on a network of servers called **DNS resolvers** that work together to find the answer.\n\nWhen you type in a domain name in your browser:\n\n1. Your computer first checks its **local DNS cache**.\n2. If not found, it sends a query to a **DNS resolver**.\n3. The resolver checks its own cache.\n4. If still not found, it queries other DNS servers until the answer is found or the request times out.\n\n> **DNS Resolver**: A server that stores DNS records and answers DNS queries.\n\n### DNS Resolution Flow (Example: `www.example.com`)\n\n1. Local Caches  \n2. Recursive DNS Servers  \n3. Root DNS Servers  \n4. Top-Level Domain (TLD) DNS Servers  \n5. Authoritative DNS Servers  \n\n---\n\n## Step 1: Local Caches\n\nYour computer checks its local cache first. If the mapping exists, the process stops here.\n\nPossible local caches include:\n\n- **Browser Cache**  Cached from previous visits  \n- **DNS Cache**  Cached based on TTL (Time To Live)  \n- **Hosts File**  Manually defined domain-to-IP mappings  \n\n---\n\n## Step 2: Recursive DNS Servers\n\nYour system sends the query to a **recursive DNS server** (usually provided by your ISP).  \n- If the server has the answer cached, it returns it.\n- Otherwise, it forwards the query to a root DNS server.\n\n---\n\n## Step 3: Root DNS Servers\n\nRoot DNS servers are at the top of the DNS hierarchy.  \nThey dont store IP addresses for domains but know where to find **TLD DNS servers**.\n\nExample commands:\n```bash\ndig +short NS com\ndig +short NS org\ndig +short NS ai\ndig +short NS fyi\ndig +short NS io\n````\n\n---\n\n## Step 4: Top-Level Domain DNS Servers\n\nTLD servers delegate queries to **authoritative DNS servers** for second-level domains.\n\nExample commands:\n\n```bash\ndig +short NS cs.fyi\ndig +short NS github.com\ndig +short NS medium.com\n```\n\n---\n\n## Step 5: Authoritative DNS Servers\n\nThese servers store the actual DNS records.\n\n- The authoritative server returns the **A record** (IP address).\n    \n- The recursive DNS server forwards it back to your computer.\n    \n\n---\n\n## How does DNS work in practice?\n\nWe can use the `dig` command to query DNS servers.\n\n### Installing `dig` on Windows\n\n```bash\nchoco install dig\n```\n\n### Finding an IP address\n\n```bash\ndig +short www.example.com\n```\n\nOutput:\n\n```text\n93.184.216.34\n```\n\n### Tracing the full DNS resolution\n\n```bash\ndig +trace www.example.com\n```\n\n---\n\n## Debugging DNS Issues\n\n### Checking DNS Resolution\n\n```bash\ndig example.com +short\n```\n\n### Retrieving A Records\n\n```bash\ndig example.com A\n```\n\n### Retrieving MX Records\n\n```bash\ndig example.com MX\n```\n\n### Checking DNS Propagation\n\n```bash\ndig example.com MX +trace\n```\n\n### Checking DNSSEC Validation\n\n```bash\ndig example.com +dnssec\n```\n\n> **DNSSEC**: A security extension that ensures DNS data authenticity and integrity.\n\n---\n\n## Querying a Specific DNS Server\n\nExample using Google Public DNS:\n\n```bash\ndig example.com A @8.8.8.8\n```\n\n---\n\n## Common DNS Errors\n\n### DNS_PROBE_FINISHED_NXDOMAIN\n\nDomain does not exist or was mistyped.\n\n### DNS_PROBE_FINISHED_NO_INTERNET\n\nDNS server is unreachable due to network issues.\n\n### DNS_PROBE_FINISHED_BAD_CONFIG\n\nIncorrect DNS configuration or unreachable DNS server.\n\n---\n\n## How to Flush DNS Cache\n\n### Windows\n\n```bash\nipconfig /flushdns\n```\n\n### macOS\n\n```bash\ndscacheutil -flushcache\n```\n\n---\n\n## Conclusion\n\nIn this article, we learned how DNS works, the DNS resolution process, and how to debug DNS issues using the `dig` command.  \nI hope you found this article usefulfeel free to share it with your friends and colleagues.\n\n---\n\n All rights reserved  cs.fyi",
          "excerpt": "A comprehensive guide to the Domain Name System (DNS), explaining how domain names are resolved to IP addresses through a hierarchical network of servers.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2026-01-30T14:37:29.106Z"
        },
        {
          "id": "404-backend-database-with-postgres-md",
          "slug": "404-backend/database-with-postgres",
          "filepath": "404-BACKEND/Database with Postgres.md",
          "folder": "404-BACKEND",
          "filename": "Database with Postgres.md",
          "frontmatter": {
            "title": "Database with Postgres",
            "date": "2026-02-02",
            "tags": [
              "postgresql",
              "sql",
              "backend",
              "databases",
              "migrations",
              "data-modeling",
              "knex",
              "relational-database"
            ],
            "category": "404-BACKEND",
            "description": "A comprehensive guide to PostgreSQL fundamentals, covering SQL vs NoSQL, data types, schema migrations, and relational modeling for backend applications."
          },
          "content": "\n### **1. Introduction to Database Systems**\n\n- **What is a Database?** \n    \n    - A system to **persist** information across sessions (survives after the program stops).\n        \n    - Basically, any structured storage (e.g., contact list, local storage, text files) can be a database.\n        \n- **Disk vs. RAM:** \n    \n    - **RAM (Primary Memory):** Very fast but expensive and volatile (data lost on power off). Used for caching (e.g., Redis).\n        \n    - **Disk (Secondary Memory):** Slower but cheaper and persistent. Used for primary databases (e.g., PostgreSQL, MongoDB).\n        \n- **DBMS (Database Management System):** \n    \n    - Software responsible for efficiently organizing data and providing **CRUD** (Create, Read, Update, Delete) operations.\n        \n    - Key responsibilities: Data organization, Access control, **Integrity** (accuracy/validity), and **Security**.\n        \n- **Why not Text Files?** \n    \n    - **Parsing:** Slow and error-prone to read/write specific data points.\n        \n    - **No Structure:** Difficult to enforce data types (e.g., ensuring a field is a number).\n        \n    - **Concurrency:** Handling multiple users updating the same file simultaneously leads to data corruption or loss.\n        \n\n### **2. Relational vs. Non-Relational Databases**\n\n- **Relational (SQL):** \n    \n    - Organizes data in **tables, rows, and columns**.\n        \n    - **Strict Schema:** Structure must be defined beforehand (Column names, types).\n        \n    - **Pros:** Strong data integrity and consistency. Best for structured data like CRM systems.\n        \n    - _Examples:_ PostgreSQL, MySQL, SQL Server.\n        \n- **Non-Relational (NoSQL):** \n    \n    - Organizes data in **collections and documents**.\n        \n    - **Flexible Schema:** Can store dynamic/unstructured data.\n        \n    - **Pros:** Flexibility for rapid prototyping or content-heavy apps (e.g., CMS).\n        \n    - **Cons:** Harder to maintain data integrity; checks often move to application code.\n        \n    - _Examples:_ MongoDB.\n        \n\n### **3. Why Choose PostgreSQL?**\n\n- **Open Source & Free:** No proprietary locking.\n    \n- **SQL Standard Compliant:** Easy to migrate to/from other SQL databases.\n    \n- **Extensible:** Huge ecosystem of extensions.\n    \n- **Reliability:** Proven track record for scalability.\n    \n- **JSON Support:** PostgreSQL offers a native `JSONB` type with indexing, allowing it to handle dynamic data just like NoSQL databases. This makes it a \"best of both worlds\" solution.\n    \n\n### **4. PostgreSQL Data Types** \n\n- **Integers:** `Serial` (auto-incrementing ID), `Integer`, `BigInt` (for large numbers).\n    \n- **Decimals:**\n    \n    - `Decimal`/`Numeric`: Exact precision (slow). **Use for money/prices.**\n        \n    - `Float`/`Real`: Approximate precision (fast). Use for scientific calculations where slight inaccuracies are acceptable.\n        \n- **Strings:**\n    \n    - `Char(n)`: Fixed length (pads with spaces). **Avoid.**\n        \n    - `Varchar(n)`: Variable length with a limit.\n        \n    - `Text`: Unlimited length. **Recommended:** PostgreSQL docs recommend using `text` as there is no performance penalty compared to `varchar`, and it avoids arbitrary limits (like the legacy `255`).\n        \n- **Others:** `Boolean`, `Date`, `Timestamp` (use `timestamptz` for timezones), `UUID` (great for unique IDs), `JSONB` (binary JSON for efficient storage/querying).\n    \n\n### **5. Database Migrations** \n\n- **Concept:** Version control for your database schema. Instead of running raw SQL commands manually, you write files (e.g., `001_create_users.sql`) that describe changes.\n    \n- **Structure:**\n    \n    - **Up:** SQL to apply changes (Create table).\n        \n    - **Down:** SQL to revert changes (Drop table).\n        \n- **Benefits:** Tracks history of changes, allows rollbacks, and ensures all developers/servers have the same DB structure.\n    \n- **Tool Used:** `dbmate` (Command-line migration tool).\n    \n\n### **6. Database Modeling (Project Management App)**\n\nThe video builds a schema for a project management tool with the following components:\n\n- **Enums:** Custom types to enforce allowed values (e.g., `project_status`: 'active', 'completed', 'archived').\n    \n- **Tables & Relationships:**\n    \n    - **Users:** Stores generic info (email, password hash).\n        \n    - **User Profiles (1-to-1):** Separates profile details (bio, avatar) from the main user table. Uses the `user_id` as both Primary Key and Foreign Key.\n        \n    - **Projects (1-to-Many):** One user (owner) can have many projects. Uses `owner_id` Foreign Key.\n        \n    - **Tasks (1-to-Many):** One project has many tasks. Uses `project_id` Foreign Key.\n        \n    - **Project Members (Many-to-Many):** Users can join multiple projects; projects can have multiple users. Implemented via a **Linking Table** with a composite primary key (`project_id`, `user_id`).\n        \n- **Constraints:**\n    \n    - `Primary Key`: Unique identifier, implies `Not Null` and `Unique`.\n        \n    - `Not Null`: Prevents missing data.\n        \n    - `Unique`: Ensures no duplicates (e.g., emails).\n        \n    - `Foreign Key`: Enforces **Referential Integrity**.\n        \n        - `On Delete Restrict`: Prevents deleting a user if they own projects.\n            \n        - `On Delete Cascade`: Deletes all tasks if the parent project is deleted.\n            \n    - `Check`: Custom validation (e.g., `priority` must be between 1 and 5).\n        \n\n### **7. Writing SQL for Backend APIs**\n\n- **Parameterized Queries:** \n    \n    - **Critical for Security:** Never concatenate strings to build queries. Use placeholders (e.g., `$1`) to prevent **SQL Injection**. The database treats input as data, not executable code.\n        \n- **Joining Data:** \n    \n    - Using `LEFT JOIN` to fetch users even if they don't have a profile.\n        \n    - Using `TO_JSONB` to nest related data (e.g., embedding profile inside the user object) directly in the SQL result.\n        \n- **Dynamic Filtering & Sorting:** \n    \n    - Building queries based on URL parameters.\n        \n    - `ILIKE`: Case-insensitive pattern matching for search (e.g., names starting with 'A').\n        \n    - Dynamic `ORDER BY` clauses based on user selection (e.g., sort by 'created_at' or 'email').\n        \n- **Pagination:** \n    \n    - Using `LIMIT` (page size) and `OFFSET` (skip count) to handle large datasets.\n        \n\n### **8. Advanced Concepts: Indexes & Triggers**\n\n- **Indexes:** \n    \n    - **Problem:** Without an index, finding a specific row requires a **Sequential Scan** (checking every row), which is slow.\n        \n    - **Solution:** An Index is a lookup table (like a book index) that points directly to the data location.\n        \n    - **When to use:** On fields used in `WHERE`, `JOIN`, or `ORDER BY`.\n        \n    - **Trade-off:** Speeds up Reads, but slows down Writes (insert/update) because the index must also be updated.\n        \n- **Triggers:** \n    \n    - **Automation:** A function that automatically runs in response to a database event.\n        \n    - **Use Case:** Automatically updating the `updated_at` timestamp column whenever a row is modified, so application code doesn't need to handle it manually.",
          "excerpt": "A comprehensive guide to PostgreSQL fundamentals, covering SQL vs NoSQL, data types, schema migrations, and relational modeling for backend applications.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2026-02-02T14:40:21.828Z"
        }
      ]
    },
    {
      "name": "501-DB",
      "path": "501-DB",
      "noteCount": 3,
      "notes": [
        {
          "id": "501-db-postgressql-md",
          "slug": "501-db/postgressql",
          "filepath": "501-DB/PostgresSQL.md",
          "folder": "501-DB",
          "filename": "PostgresSQL.md",
          "frontmatter": {
            "title": "Basic Commands:",
            "date": "2025-07-26",
            "tags": [
              "sql",
              "database",
              "querying",
              "ddl",
              "dml",
              "operators",
              "joins"
            ],
            "category": "501-DB",
            "description": "A foundational guide to SQL commands covering table manipulation, data selection operators, joins, and the rules for using the union operator."
          },
          "content": "# Basic Commands:\n\n### Create Table\n```sql\nCREATE TABLE cars (  \nbrand VARCHAR(255),  \nmodel VARCHAR(255),  \n year INT  \n);\n```\n\n### Insert into \n```sql\nINSERT INTO cars (brand, model, year)  \nVALUES ('Ford', 'Mustang', 1964);\n```\n\n### Alter table\n```sql\nALTER TABLE cars  \nADD color VARCHAR(255);\n```\n\n```sql\nALTER TABLE cars  \nALTER COLUMN year TYPE VARCHAR(4);\n```\n### Update Table\n```sql\nUPDATE cars  \nSET color = 'red'  \nWHERE brand = 'Volvo';\n```\n\n### Where Clause (All operators):\nWe can operate with different operators in the `WHERE` clause:\n\n|           |                                                                  |\n| --------- | ---------------------------------------------------------------- |\n| `=`       | Equal to                                                         |\n| `<`       | Less than                                                        |\n| `>`       | Greater than                                                     |\n| `<=`      | Less than or equal to                                            |\n| `>=`      | Greater than or equal to                                         |\n| `<>`      | Not equal to                                                     |\n| `!=`      | Not equal to                                                     |\n| `LIKE`    | Check if a value matches a pattern (case sensitive)              |\n| `ILIKE`   | Check if a value matches a pattern (case insensitive)            |\n| `AND`     | Logical AND                                                      |\n| `OR`      | Logical OR                                                       |\n| `IN`      | Check if a value is between a range of values                    |\n| `BETWEEN` | Check if a value is between a range of values                    |\n| `IS NULL` | Check if a value is NULL                                         |\n| `NOT`     | Makes a negative result e.g. `NOT LIKE`, `NOT IN`, `NOT BETWEEN` |\n\n### JOINS:\n![[Pasted image 20250726191832.png]]\n\n### UNION:\n\nThe `UNION` operator is used to combine the result-set of two or more queries.\n\nThe queries in the union must follow these rules:\n\n- They must have the same number of columns\n- The columns must have the same data types\n- The columns must be in the same order\n\nCombine `products` and `testproducts` using the `UNION` operator:\n```sql\nSELECT product_id, product_name  \nFROM products  \nUNION  \nSELECT testproduct_id, product_name  \nFROM testproducts  \nORDER BY product_id;\n```\n",
          "excerpt": "A foundational guide to SQL commands covering table manipulation, data selection operators, joins, and the rules for using the union operator.",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-07-26T13:50:34.000Z"
        },
        {
          "id": "501-db-redis-md",
          "slug": "501-db/redis",
          "filepath": "501-DB/REDIS.md",
          "folder": "501-DB",
          "filename": "REDIS.md",
          "frontmatter": {
            "title": "What is Redis?",
            "date": "2025-09-01",
            "category": "501-DB"
          },
          "content": "## What is Redis?\n\nRedis is an in-memory database that is significantly faster than traditional disk-based databases. It can be used for various purposes, including caching, message queues, and coordination.\n\n---\n\n## Why Redis?\n\nImagine a traditional database being pinged for every query, leading to high latency, increased load on the database, and financial costs. Redis helps solve this problem by creating a database in memory to handle repeated calls for the same data, offloading the traditional database.\n\n---\n\n## Where and for What Should I Use Redis?\n\nYou can determine if Redis is the right tool for a scenario by asking a few key questions:\n\n- **Am I fetching the same data repeatedly?** Redis can cache this data.\n    \n- **Do I need very fast read/write speeds, in microseconds?** Redis operations are much faster than traditional databases.\n    \n- **Do I need a queue or a pub/sub system for coordination?** Redis Lists can be used for this.\n    \n- **Is it okay if this data is temporary or can be reconstructed?** 8\n    \n\n### Why Do I Need a Queue?\n\nA queue is useful when tasks arrive faster than you can process them, or when you need controlled, background processing. For example, if 1000 customers place a food order at once, you can't process them all simultaneously. Instead, you can add them to a queue to be processed on a \"first come, first serve\" basis. This allows customers to wait while their orders are processed.\n\n### What is Coordination?\n\nCoordination ensures that systems or workers don't clash with each other and instead work together peacefully. For example, if you have 10 chefs, you want to make sure only one chef takes a specific pizza order.\n\n---\n\n## How to Use Redis\n\n### Caching Repeated Data\n\nA common use case for Redis is caching. For instance, in a news app that shows the top 10 trending stories, many users may open the app at once, and a database call for each user could overload the database. A better solution is to cache the trending news in Redis so that subsequent requests hit the cache instead of the database16. The cache can be refreshed when new news becomes available.\n\nA common workflow is to first check if the data exists in Redis. If it does, return the cached data19. If not, fetch the data from the source database, store it in Redis with an expiration time, and then return the data.\n\n### Redis Methods\n\n- **get**: Retrieves the value of a key.\n    \n- **setex**: Sets a key to a value and specifies a time-to-live (expiration time)22.\n    \n- **set**: Sets a key to a value with no expiration.\n    \n- **getset**: Sets a key to a new value and returns the old value.\n    \n- **del**: Deletes one or more keys.\n    \n- **exists**: Checks if a key exists.\n    \n- **expire**: Sets a timeout on an existing key in seconds.\n    \n- **ttl**: Returns the remaining time-to-live for a key in seconds.\n    \n- **persist**: Removes the expiration from a key.\n    \n- **incr**: Increments the integer value of a key by .\n    \n- **decr**: Decrements the integer value of a key by .\n    \n- **incrby**: Increments the integer value of a key by a specified amount.\n    \n\n### Using Redis for Queues\n\nWhen orders arrive faster than you can process them, you can use a queue. You can push tasks into a queue using\n\n`lpush` and have a background worker pull them using `brpop`. This approach frees up your web app to handle other tasks while the worker processes the queue in the background. This is good for apps that perform background tasks like image processing or other operations that shouldn't block the user36.\n\n---\n\n## Redis Data Types\n\nRedis is a key-value store where every piece of data requires a key. You can store anything in Redis as long as you model it using one of its data types.\n\n| Redis Data Type       | Stored As (Key  Value)             | What It Looks Like                                      | Common Use Cases                                 |\n| --------------------- | ----------------------------------- | ------------------------------------------------------- | ------------------------------------------------ |\n| **String**            | key  string (text/number)          | `SET user:1 \"Ajeet\"`                                    | Caching values, counters, feature flags, tokens  |\n| **List**              | key  ordered list                  | `LPUSH queue \"task1\"`  `[\"task1\", \"task2\"]`            | Message queues, task lists, chat history         |\n| **Set**               | key  unordered unique items        | `SADD online_users 101 102`  `{101, 102}`              | Unique visitors, tags, \"likes\"                   |\n| **Sorted Set (ZSET)** | key  set + scores (sorted)         | `ZADD leaderboard 500 \"player1\"`  `[(\"player1\", 500)]` | Leaderboards, rankings, priority queues          |\n| **Hash**              | key  field-value pairs (mini JSON) | `HSET user:1 name \"Ajeet\" age 25`                       | User profiles, product info, config maps         |\n| **Stream**            | key  append-only log of events     | `XADD mystream * message \"Hi\"`                          | Event sourcing, chat feeds, logs                 |\n| **Bitmap**            | key  bit array                     | `SETBIT logins 51`                                      | Track daily activity (yes/no), flags             |\n| **HyperLogLog**       | key  probabilistic counter         | `PFADD unique_users user123`                            | Count unique items (e.g., unique visitors)       |\n| **Geospatial**        | key  geo-coordinates (lat, lon)    | `GEOADD locations 77.1 28.6 \"Delhi\"`                    | Find nearby places, \"who's closest\" lookups      |\n",
          "excerpt": "What is Redis?\n\nRedis is an in-memory database that is significantly faster than traditional disk-based databases. It can be used for various purposes, including caching, message queues, and coordinat...",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-09-01T12:49:38.081Z"
        },
        {
          "id": "501-db-drizzle-md",
          "slug": "501-db/drizzle",
          "filepath": "501-DB/Drizzle.md",
          "folder": "501-DB",
          "filename": "Drizzle.md",
          "frontmatter": {
            "title": "Drizzle",
            "date": "2025-09-06",
            "tags": [
              "ts",
              "sql"
            ],
            "category": "501-DB"
          },
          "content": "\n> [!NOTE] DEF\n> Drizzle is a **headless TypeScript ORM** (Object-Relational Mapper) that prioritizes performance, type safety, and a familiar SQL-like syntax. Unlike traditional ORMs that might hide SQL from you, Drizzle empowers you to write queries that closely mirror raw SQL, but with the full safety of TypeScript.\n\n**Key Features:**\n\n- **Type Safety:** If your query is valid in TypeScript, it's a valid SQL query. This catches errors at compile-time, not runtime.\n    \n- **Performance:** Drizzle is extremely lightweight and boasts near-native SQL driver performance.\n    \n- **SQL-like Syntax:** You don't need to learn a complex new query language. If you know SQL, you'll feel right at home.\n    \n- **Schema as Code:** Your database schema is defined directly in your TypeScript files, enabling version control and a single source of truth.\n    \n\n---\n\n###  Approach 1: Codebase-First (The Standard Workflow)\n\nIn this approach, your **TypeScript schema files are the single source of truth**. You define your database structure in code, and Drizzle's tooling generates the necessary SQL to make your database match that code.\n\n#### Workflow Steps\n\n**1. Define or Modify Your Schema**\n\nYou start by defining your tables in a `.ts` file (e.g., `src/db/schema.ts`). Drizzle provides functions like `pgTable`, `mysqlTable`, or `sqliteTable` to define tables and various data types for columns.\n\n\n```ts\n// src/db/schema.ts\nimport { relations } from 'drizzle-orm';\nimport { pgTable, serial, text, varchar } from 'drizzle-orm/pg-core';\n\nexport const users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  fullName: text('full_name'),\n  email: varchar('email', { length: 256 }).notNull().unique(),\n});\n\nexport const posts = pgTable('posts', {\n  id: serial('id').primaryKey(),\n  content: text('content').notNull(),\n  authorId: serial('author_id').references(() => users.id),\n});\n\n// Optional: Define relationships for type-safe joins\nexport const usersRelations = relations(users, ({ many }) => ({\n  posts: many(posts),\n}));\n```\n\n**2. Generate Migration Files **\n\nAfter you create or change your schema, you use the **Drizzle Kit** command-line tool to generate an SQL migration file.\n\nBash\n\n```\nnpx drizzle-kit generate:pg\n```\n\nThis command inspects your TypeScript schema, compares it to its last known state, and generates a new SQL file in your migrations folder. For example, if you just added the `posts` table, the generated SQL file might look like this:\n\nSQL\n\n```sql\n-- migrations/0001_initial_posts.sql\nCREATE TABLE IF NOT EXISTS \"posts\" (\n\t\"id\" serial PRIMARY KEY NOT NULL,\n\t\"content\" text NOT NULL,\n\t\"author_id\" serial\n);\n\nDO $$ BEGIN\n ALTER TABLE \"posts\" ADD CONSTRAINT \"posts_author_id_users_id_fk\" FOREIGN KEY (\"author_id\") REFERENCES \"public\".\"users\"(\"id\") ON DELETE no action ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n```\n\n**3. Apply the Migration**\n\nFinally, you run the migration against your database. Drizzle Kit provides a command for this as well.\n\nBash\n\n```\nnpx drizzle-kit migrate:pg\n```\n\nThis command connects to your database, checks which migrations haven't been applied yet, and executes them in order.\n\n####  Pros &  Cons\n\n- ** Pros:**\n    \n    - **Single Source of Truth:** Your Git repository contains the entire history and definition of your database.\n        \n    - **Full Type Safety:** Your application code is always in sync with your schema.\n        \n    - **Collaboration:** Easy for teams to collaborate on schema changes through pull requests.\n        \n- ** Cons:**\n    \n    - Requires a disciplined workflow; manual changes to the database can cause drift.\n        \n\n---\n\n###  Approach 2: Database-First (Introspection)\n\nIn this approach, your **existing database is the single source of truth**. This is perfect for projects with a pre-existing database or where a Database Administrator (DBA) manages the schema directly.\n\n#### Workflow Steps\n\n**1. Point Drizzle Kit to Your Database**\n\nYou need an existing database with tables and columns already defined.\n\n**2. Introspect the Database **\n\nYou run the Drizzle Kit `introspect` command:\n\nBash\n\n```\nnpx drizzle-kit introspect:pg\n```\n\nDrizzle Kit connects to your database, reads its entire schema (tables, columns, types, relations, etc.), and **generates the corresponding TypeScript schema files for you**.\n\nThe output will be a complete `schema.ts` file that perfectly mirrors your database's current state, ready for you to use in your application for type-safe querying.\n\n####  Pros &  Cons\n\n- ** Pros:**\n    \n    - **Perfect for Existing Projects:** The easiest way to adopt Drizzle without rebuilding your schema from scratch.\n        \n    - **DBA-Friendly:** Allows database schemas to be managed by dedicated tools or teams while developers still get type-safe clients.\n        \n- ** Cons:**\n    \n    - You lose the \"single source of truth\" in your codebase. Schema changes must be made in the database first, then re-introspected.\n        \n\n---\n\n### In-Depth: Migration & Generation Techniques\n\nDrizzle Kit offers two primary ways to sync your schema with your database, which are crucial to understand.\n\n#### `drizzle-kit push` (For Prototyping)\n\nThe `push` command is a fast, simple way to make your database schema match your TypeScript schema.\n\nBash\n\n```\nnpx drizzle-kit push:pg\n```\n\n- **How it Works:** It directly compares your code schema with the database and generates and applies the necessary SQL `ALTER` statements to sync them. It **does not create migration files**.\n    \n- **When to Use It:** **Only for local development and prototyping.** It's a destructive tool, meaning it can drop columns or data if you're not careful. It's great for quickly iterating on your schema during early development.\n    \n- ** Warning:** **Never use `push` in a production environment.**\n    \n\n#### `drizzle-kit migrate` (For Production)\n\nThe `migrate` command is the production-safe method for applying schema changes.\n\nBash\n\n```\nnpx drizzle-kit migrate:pg\n```\n\n- **How it Works:** It relies on the migration files you create with `drizzle-kit generate`. It keeps track of which migrations have already been applied (in a special `__drizzle_migrations` table) and only runs the new ones.\n    \n- **When to Use It:** For all environments other than initial local development (Staging, Production). It provides a reliable, repeatable, and historical log of every schema change.\n    \n\n#### Drizzle Studio: Visual Generation\n\nDrizzle Kit also includes a powerful utility called **Drizzle Studio**, a GUI for your database.\n\nBash\n\n```\nnpx drizzle-kit studio\n```\n\nThis command opens a browser window with a clean interface to view, add, and edit data in your database. It's an excellent tool for debugging and visualizing your schema without needing a heavy, external database client.",
          "excerpt": "> [!NOTE] DEF\n> Drizzle is a headless TypeScript ORM (Object-Relational Mapper) that prioritizes performance, type safety, and a familiar SQL-like syntax. Unlike traditional ORMs that might hide SQL f...",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-09-06T06:32:45.785Z"
        }
      ]
    },
    {
      "name": "991-CLANG",
      "path": "991-CLANG",
      "noteCount": 6,
      "notes": [
        {
          "id": "991-clang-file-io-and-strings-md",
          "slug": "991-clang/file-io-and-strings",
          "filepath": "991-CLANG/File IO and Strings.md",
          "folder": "991-CLANG",
          "filename": "File IO and Strings.md",
          "frontmatter": {
            "title": "File IO and Strings",
            "date": "2025-08-07",
            "tags": [
              "c",
              "include"
            ],
            "category": "991-CLANG"
          },
          "content": "\n### Reading from a File Line by Line\n\n```c\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  char line[1028];\n  int points = 0;\n\n  while (fgets(line, sizeof(line), fptr)) {\n    line[strcspn(line, \"\\n\")] = 0;\n    printf(\"Processing line: %s\\n\", line);\n}\n\n```\n\n\n### Splitting Strings using strtok\n\n```c\n#include <string.h>\n#include <stdio.h>\n\nchar** split_string(const char *str, char delimiter) {\n    char *delimiter_ptr = strchr(str, delimiter);\n\n    if (delimiter_ptr == NULL) {\n        return NULL;\n    }\n\n    size_t first_part_len = delimiter_ptr - str;\n\n    char **result = malloc(sizeof(char*) * 2);\n    if (result == NULL) {\n        return NULL;\n    }\n\n    result[0] = malloc(first_part_len + 1);\n    if (result[0] == NULL) {\n        free(result);\n        return NULL;\n    }\n    strncpy(result[0], str, first_part_len);\n    result[0][first_part_len] = '\\0';\n\n    size_t second_part_len = strlen(delimiter_ptr + 1);\n    result[1] = malloc(second_part_len + 1);\n    if (result[1] == NULL) {\n        free(result[0]);\n        free(result);\n        return NULL;\n    }\n    strcpy(result[1], delimiter_ptr + 1);\n\n    return result;\n}\n```\n",
          "excerpt": "Reading from a File Line by Line\n\n\n\n\nSplitting Strings using strtok",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-08-07T14:46:06.000Z"
        },
        {
          "id": "991-clang-data-types-md",
          "slug": "991-clang/data-types",
          "filepath": "991-CLANG/Data Types.md",
          "folder": "991-CLANG",
          "filename": "Data Types.md",
          "frontmatter": {
            "title": "Boolean Expression:",
            "date": "2025-07-01",
            "tags": [
              "c",
              "include"
            ],
            "category": "991-CLANG"
          },
          "content": "| Data Type | Size         | Description                                                                                           | Example |\n| --------- | ------------ | ----------------------------------------------------------------------------------------------------- | ------- |\n| `int`     | 2 or 4 bytes | Stores whole numbers, without decimals                                                                | `1`     |\n| `float`   | 4 bytes      | Stores fractional numbers, containing one or more decimals. Sufficient for storing 6-7 decimal digits | `1.99`  |\n| `double`  | 8 bytes      | Stores fractional numbers, containing one or more decimals. Sufficient for storing 15 decimal digits  | `1.99`  |\n| `char`    | 1 byte       | Stores a single character/letter/number, or ASCII values                                              | `'A'`   |\n\n\n\n| `%d` or `%i` | `int`                                                                                                                        |     |\n| ------------ | ---------------------------------------------------------------------------------------------------------------------------- | --- |\n| `%f` or `%F` | `float`                                                                                                                      |     |\n| `%lf`        | `double`                                                                                                                     |     |\n| `%c`         | `char`                                                                                                                       |     |\n| `%s`         | Used for **[strings](https://www.w3schools.com/c/c_strings.php) (text)**, which you will learn more about in a later chapter |     |\n\n## Boolean Expression:\n```c\n#include <stdbool.h>\n\nbool isProgrammingFun = true;  \nbool isFishTasty = false;\n// returned as 0,1\n\n```\n\n\n## Short Hand if else:\n```c\n_variable_ = (_condition_) ? _expressionTrue_ : _expressionFalse_;\n```\n\n\n## Switch statements:\n```c\nswitch (_expression_) {  \n case x:  \n _// code block_  \n break;  \n case y:  \n _// code block_  \n break;  \n default:  \n _// code block_  \n}\n```\n\n### *sizeof() includes the \\0 wehere as strlen does not!!!*\n\n\n\n",
          "excerpt": "| Data Type | Size         | Description                                                                                           | Example |\n| --------- | ------------ | ----------------------------...",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-07-01T16:57:00.000Z"
        },
        {
          "id": "991-clang-make-file-md",
          "slug": "991-clang/make-file",
          "filepath": "991-CLANG/Make File.md",
          "folder": "991-CLANG",
          "filename": "Make File.md",
          "frontmatter": {
            "title": "Typically blah.c would already exist, but I want to limit any additional required files",
            "date": "2025-07-23",
            "tags": [
              "C",
              "ffb8eba6",
              "variables",
              "automatic",
              "1",
              "2",
              "the",
              "string",
              "makefile"
            ],
            "category": "991-CLANG"
          },
          "content": "## Why do Makefiles exist?\n\nMakefiles are used to help decide which parts of a large program need to be recompiled. In the vast majority of cases, C or C++ files are compiled. Other languages typically have their own tools that serve a similar purpose as Make. Make can also be used beyond compilation too, when you need a series of instructions to run depending on what files have changed. This tutorial will focus on the C/C++ compilation use case.\n\n## The versions and types of Make\n\nThere are a variety of implementations of Make, but most of this guide will work on whatever version you're using. However, it's specifically written for GNU Make, which is the standard implementation on Linux and MacOS. All the examples work for Make versions 3 and 4, which are nearly equivalent other than some esoteric differences.\n\n## Running the Examples\n\nTo run these examples, you'll need a terminal and \"make\" installed. For each example, put the contents in a file called `Makefile`, and in that directory run the command `make`. Let's start with the simplest of Makefiles:\n\n```C\nhello:\n\techo \"Hello, World\"\n```\n\n> Note: Makefiles **must** be indented using TABs and not spaces or `make` will fail.\n\nHere is the output of running the above example:\n\n```C\n$ make\necho \"Hello, World\"\nHello, World\n```\n\nThat's it! If you're a bit confused, here's a video that goes through these steps, along with describing the basic structure of Makefiles.\n\n## Makefile Syntax\n\nA Makefile consists of a set of _rules_. A rule generally looks like this:\n\n```\ntargets: prerequisites\n\tcommand\n\tcommand\n\tcommand\n```\n\n- The _targets_ are file names, separated by spaces. Typically, there is only one per rule.\n- The _commands_ are a series of steps typically used to make the target(s). These _need to start with a tab character_, not spaces.\n- The _prerequisites_ are also file names, separated by spaces. These files need to exist before the commands for the target are run. These are also called _dependencies_\n\n## The essence of Make\n\nLet's start with a hello world example:\n\n```\nhello:\n\techo \"Hello, World\"\n\techo \"This line will print if the file hello does not exist.\"\n```\n\n- We have one _target_ called `hello`\n- This target has two _commands_\n- This target has no _prerequisites_\n\nWe'll then run `make hello`. As long as the `hello` file does not exist, the commands will run. If `hello` does exist, no commands will run.\n\nIt's important to realize that I'm talking about `hello` as both a _target_ and a _file_. That's because the two are directly tied together. Typically, when a target is run (aka when the commands of a target are run), the commands will create a file with the same name as the target. In this case, the `hello` _target_ does not create the `hello` _file_.\n\nLet's create a more typical Makefile - one that compiles a single C file. But before we do, make a file called `blah.c` that has the following contents:\n\n```C\n// blah.c\nint main() { return 0; }\n```\n\nThen create the Makefile (called `Makefile`, as always):\n\n```C\nblah:\n\tcc blah.c -o blah\n```\n\nThis time, try simply running `make`. Since there's no target supplied as an argument to the `make` command, the first target is run. In this case, there's only one target (`blah`). The first time you run this, `blah` will be created. The second time, you'll see `make: 'blah' is up to date`. That's because the `blah` file already exists. But there's a problem: if we modify `blah.c` and then run `make`, <mark style=\"background: #FFB8EBA6;\">nothing gets recompiled</mark>.\n\nWe solve this by adding a prerequisite:\n\n```C\nblah: blah.c\n\tcc blah.c -o blah\n```\n\nWhen we run `make` again, the following set of steps happens:\n\n- The first target is selected, because the first target is the default target\n- This has a prerequisite of `blah.c`\n- Make decides if it should run the `blah` target. It will only run if `blah` doesn't exist, or `blah.c` is _newer than_ `blah`\n\nThis last step is critical, and is the **essence of make**. What it's attempting to do is decide if the prerequisites of `blah` have changed since `blah` was last compiled. That is, if `blah.c` is modified, running `make` should recompile the file. And conversely, if `blah.c` has not changed, then it should not be recompiled.\n\nTo make this happen, **it uses the filesystem timestamps as a proxy to determine if something has changed.** This is a reasonable heuristic, because file timestamps typically will only change if the files are modified. But it's important to realize that this isn't always the case. You could, for example, modify a file, and then change the modified timestamp of that file to something old. If you did, Make would incorrectly guess that the file hadn't changed and thus could be ignored.\n\nWhew, what a mouthful. **Make sure that you understand this. It's the crux of Makefiles, and might take you a few minutes to properly understand**. \n\n## More quick examples\n\nThe following Makefile ultimately runs all three targets. When you run `make` in the terminal, it will build a program called `blah` in a series of steps:\n\n- Make selects the target `blah`, because the first target is the default target\n- `blah` requires `blah.o`, so make searches for the `blah.o` target\n- `blah.o` requires `blah.c`, so make searches for the `blah.c` target\n- `blah.c` has no dependencies, so the `echo` command is run\n- The `cc -c` command is then run, because all of the `blah.o` dependencies are finished\n- The top `cc` command is run, because all the `blah` dependencies are finished\n- That's it: `blah` is a compiled c program\n\n```\nblah: blah.o\n\tcc blah.o -o blah # Runs third\n\nblah.o: blah.c\n\tcc -c blah.c -o blah.o # Runs second\n\n# Typically blah.c would already exist, but I want to limit any additional required files\nblah.c:\n\techo \"int main() { return 0; }\" > blah.c # Runs first\n```\n\nIf you delete `blah.c`, all three targets will be rerun. If you edit it (and thus change the timestamp to newer than `blah.o`), the first two targets will run. If you run `touch blah.o` (and thus change the timestamp to newer than `blah`), then only the first target will run. If you change nothing, none of the targets will run. Try it out!\n\nThis next example doesn't do anything new, but is nontheless a good additional example. It will always run both targets, because `some_file` depends on `other_file`, which is never created.\n\n```\nsome_file: other_file\n\techo \"This will always run, and runs second\"\n\ttouch some_file\n\nother_file:\n\techo \"This will always run, and runs first\"\n```\n\n## Make clean\n\n`clean` is often used as a target that removes the output of other targets, but it is not a special word in Make. You can run `make` and `make clean` on this to create and delete `some_file`.\n\nNote that `clean` is doing two new things here:\n\n- It's a target that is not first (the default), and not a prerequisite. That means it'll never run unless you explicitly call `make clean`\n- It's not intended to be a filename. If you happen to have a file named `clean`, this target won't run, which is not what we want. See `.PHONY` later in this tutorial on how to fix this\n\n```\nsome_file: \n\ttouch some_file\n\nclean:\n\trm -f some_file\n```\n\n## Variables\n\nVariables can only be strings. You'll typically want to use `:=`, but `=` also works. See [Variables Pt 2](https://makefiletutorial.com/#variables-pt-2).\n\nHere's an example of using variables:\n\n```C\nfiles := file1 file2\nsome_file: $(files)\n\techo \"Look at this variable: \" $(files)\n\ttouch some_file\n\nfile1:\n\ttouch file1\nfile2:\n\ttouch file2\n\nclean:\n\trm -f file1 file2 some_file\n```\n\nSingle or double quotes have no meaning to Make. They are simply characters that are assigned to the variable. Quotes _are_ useful to shell/bash, though, and you need them in commands like `printf`. In this example, the two commands behave the same:\n\n```\na := one two# a is set to the string \"one two\"\nb := 'one two' # Not recommended. b is set to the string \"'one two'\"\nall:\n\tprintf '$a'\n\tprintf $b\n```\n\nReference variables using either `${}` or `$()`\n\n```\nx := dude\n\nall:\n\techo $(x)\n\techo ${x}\n\n\t# Bad practice, but works\n\techo $x \n```\n\n# Targets\n\n## The all target\n\nMaking multiple targets and you want all of them to run? Make an `all` target. Since this is the first rule listed, it will run by default if `make` is called without specifying a target.\n\n```\nall: one two three\n\none:\n\ttouch one\ntwo:\n\ttouch two\nthree:\n\ttouch three\n\nclean:\n\trm -f one two three\n```\n\n## Multiple targets\n\nWhen there are multiple targets for a rule, the commands will be run for each target. `$@` is an [automatic variable](https://makefiletutorial.com/#automatic-variables) that contains the target name.\n\n```\nall: f1.o f2.o\n\nf1.o f2.o:\n\techo $@\n# Equivalent to:\n# f1.o:\n#\t echo f1.o\n# f2.o:\n#\t echo f2.o\n```\n\n# Automatic Variables and Wildcards\n\n## * Wildcard\n\nBoth `*` and `%` are called wildcards in Make, but they mean entirely different things. `*` searches your filesystem for matching filenames. I suggest that you always wrap it in the `wildcard` function, because otherwise you may fall into a common pitfall described below.\n\n```\n# Print out file information about every .c file\nprint: $(wildcard *.c)\n\tls -la  $?\n```\n\n`*` may be used in the target, prerequisites, or in the `wildcard` function.\n\nDanger: `*` may not be directly used in a variable definitions\n\nDanger: When `*` matches no files, it is left as it is (unless run in the `wildcard` function)\n\n```\nthing_wrong := *.o # Don't do this! '*' will not get expanded\nthing_right := $(wildcard *.o)\n\nall: one two three four\n\n# Fails, because $(thing_wrong) is the string \"*.o\"\none: $(thing_wrong)\n\n# Stays as *.o if there are no files that match this pattern :(\ntwo: *.o \n\n# Works as you would expect! In this case, it does nothing.\nthree: $(thing_right)\n\n# Same as rule three\nfour: $(wildcard *.o)\n```\n\n## % Wildcard\n\n`%` is really useful, but is somewhat confusing because of the variety of situations it can be used in.\n\n- When used in \"matching\" mode, it matches one or more characters in a string. This match is called the stem.\n- When used in \"replacing\" mode, it takes the stem that was matched and replaces that in a string.\n- `%` is most often used in rule definitions and in some specific functions.\n\n\n# Fancy Rules\n\n## Implicit Rules\n\nMake loves c compilation. And every time it expresses its love, things get confusing. Perhaps the most confusing part of Make is the magic/automatic rules that are made. Make calls these \"implicit\" rules. I don't personally agree with this design decision, and I don't recommend using them, but they're often used and are thus useful to know. Here's a list of implicit rules:\n\n- Compiling a C program: `n.o` is made automatically from `n.c` with a command of the form `$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@`\n- Linking a single object file: `n` is made automatically from `n.o` by running the command `$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@`\n\nThe important variables used by implicit rules are:\n\n- `CC`: Program for compiling C programs; default `cc`\n- `CXX`: Program for compiling C++ programs; default `g++`\n- `CFLAGS`: Extra flags to give to the C compiler\n- `CXXFLAGS`: Extra flags to give to the C++ compiler\n- `CPPFLAGS`: Extra flags to give to the C preprocessor\n- `LDFLAGS`: Extra flags to give to compilers when they are supposed to invoke the linker\n\nLet's see how we can now build a C program without ever explicitly telling Make how to do the compilation:\n\n```C\nCC = gcc # Flag for implicit rules\nCFLAGS = -g # Flag for implicit rules. Turn on debug info\n\n# Implicit rule #1: blah is built via the C linker implicit rule\n# Implicit rule #2: blah.o is built via the C compilation implicit rule, because blah.c exists\nblah: blah.o\n\nblah.c:\n\techo \"int main() { return 0; }\" > blah.c\n\nclean:\n\trm -f blah*\n```\n\n## Static Pattern Rules\n\nStatic pattern rules are another way to write less in a Makefile. Here's their syntax:\n\n```\ntargets...: target-pattern: prereq-patterns ...\n   commands\n```\n\nThe essence is that the given `target` is matched by the `target-pattern` (via a `%` wildcard). Whatever was matched is called the _stem_. The stem is then substituted into the `prereq-pattern`, to generate the target's prereqs.\n\nA typical use case is to compile `.c` files into `.o` files. Here's the _manual way_:\n\n```\nobjects = foo.o bar.o all.o\nall: $(objects)\n\t$(CC) $^ -o all\n\nfoo.o: foo.c\n\t$(CC) -c foo.c -o foo.o\n\nbar.o: bar.c\n\t$(CC) -c bar.c -o bar.o\n\nall.o: all.c\n\t$(CC) -c all.c -o all.o\n\nall.c:\n\techo \"int main() { return 0; }\" > all.c\n\n# Note: all.c does not use this rule because Make prioritizes more specific matches when there is more than one match.\n%.c:\n\ttouch $@\n\nclean:\n\trm -f *.c *.o all\n```\n\nHere's the more _efficient way_, using a static pattern rule:\n\n```\nobjects = foo.o bar.o all.o\nall: $(objects)\n\t$(CC) $^ -o all\n\n# Syntax - targets ...: target-pattern: prereq-patterns ...\n# In the case of the first target, foo.o, the target-pattern matches foo.o and sets the \"stem\" to be \"foo\".\n# It then replaces the '%' in prereq-patterns with that stem\n$(objects): %.o: %.c\n\t$(CC) -c $^ -o $@\n\nall.c:\n\techo \"int main() { return 0; }\" > all.c\n\n# Note: all.c does not use this rule because Make prioritizes more specific matches when there is more than one match.\n%.c:\n\ttouch $@\n\nclean:\n\trm -f *.c *.o all\n```\n\n## Static Pattern Rules and Filter\n\nWhile I introduce the [filter function](https://makefiletutorial.com/#the-filter-function) later on, it's common to use in static pattern rules, so I'll mention that here. The `filter` function can be used in Static pattern rules to match the correct files. In this example, I made up the `.raw` and `.result` extensions.\n\n```\nobj_files = foo.result bar.o lose.o\nsrc_files = foo.raw bar.c lose.c\n\nall: $(obj_files)\n# Note: PHONY is important here. Without it, implicit rules will try to build the executable \"all\", since the prereqs are \".o\" files.\n.PHONY: all \n\n# Ex 1: .o files depend on .c files. Though we don't actually make the .o file.\n$(filter %.o,$(obj_files)): %.o: %.c\n\techo \"target: $@ prereq: $<\"\n\n# Ex 2: .result files depend on .raw files. Though we don't actually make the .result file.\n$(filter %.result,$(obj_files)): %.result: %.raw\n\techo \"target: $@ prereq: $<\" \n\n%.c %.raw:\n\ttouch $@\n\nclean:\n\trm -f $(src_files)\n```\n\n## Pattern Rules\n\nPattern rules are often used but quite confusing. You can look at them as two ways:\n\n- A way to define your own implicit rules\n- A simpler form of static pattern rules\n\nLet's start with an example first:\n\n```\n# Define a pattern rule that compiles every .c file into a .o file\n%.o : %.c\n\t\t$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@\n```\n\nPattern rules contain a '%' in the target. This '%' matches any nonempty string, and the other characters match themselves. % in a prerequisite of a pattern rule stands for the same stem that was matched by the % in the target.\n\nHere's another example:\n\n```\n# Define a pattern rule that has no pattern in the prerequisites.\n# This just creates empty .c files when needed.\n%.c:\n   touch $@\n```\n\n## Double-Colon Rules\n\nDouble-Colon Rules are rarely used, but allow multiple rules to be defined for the same target. If these were single colons, a warning would be printed and only the second set of commands would run.\n\n```\nall: blah\n\nblah::\n\techo \"hello\"\n\nblah::\n\techo \"hello again\"\n```\n\n# Commands and execution\n\n## Command Echoing/Silencing\n\nAdd an `@` before a command to stop it from being printed  \nYou can also run make with `-s` to add an `@` before each line\n\n```\nall: \n\t@echo \"This make line will not be printed\"\n\techo \"But this will\"\n```\n\n## Command Execution\n\nEach command is run in a new shell (or at least the effect is as such)\n\n```\nall: \n\tcd ..\n\t# The cd above does not affect this line, because each command is effectively run in a new shell\n\techo `pwd`\n\n\t# This cd command affects the next because they are on the same line\n\tcd ..;echo `pwd`\n\n\t# Same as above\n\tcd ..; \\\n\techo `pwd`\n```\n\n## Default Shell\n\nThe default shell is `/bin/sh`. You can change this by changing the variable SHELL:\n\n```\nSHELL=/bin/bash\n\ncool:\n\techo \"Hello from bash\"\n```\n\n## Double dollar sign\n\nIf you want a string to have a dollar sign, you can use `$$`. This is how to use a shell variable in `bash` or `sh`.\n\nNote the differences between Makefile variables and Shell variables in this next example.\n\n```\nmake_var = I am a make variable\nall:\n\t# Same as running \"sh_var='I am a shell variable'; echo $sh_var\" in the shell\n\tsh_var='I am a shell variable'; echo $$sh_var\n\n\t# Same as running \"echo I am a make variable\" in the shell\n\techo $(make_var)\n```\n\n## Error handling with `-k`, `-i`, and `-`\n\nAdd `-k` when running make to continue running even in the face of errors. Helpful if you want to see all the errors of Make at once.  \nAdd a `-` before a command to suppress the error  \nAdd `-i` to make to have this happen for every command.\n\n```\none:\n\t# This error will be printed but ignored, and make will continue to run\n\t-false\n\ttouch one\n```\n\n## Interrupting or killing make\n\nNote only: If you `ctrl+c` make, it will delete the newer targets it just made.\n\n## Recursive use of make\n\nTo recursively call a makefile, use the special `$(MAKE)` instead of `make` because it will pass the make flags for you and won't itself be affected by them.\n\n```\nnew_contents = \"hello:\\n\\ttouch inside_file\"\nall:\n\tmkdir -p subdir\n\tprintf $(new_contents) | sed -e 's/^ //' > subdir/makefile\n\tcd subdir && $(MAKE)\n\nclean:\n\trm -rf subdir\n```\n\n## Export, environments, and recursive make\n\nWhen Make starts, it automatically creates Make variables out of all the environment variables that are set when it's executed.\n\n```\n# Run this with \"export shell_env_var='I am an environment variable'; make\"\nall:\n\t# Print out the Shell variable\n\techo $$shell_env_var\n\n\t# Print out the Make variable\n\techo $(shell_env_var)\n```\n\nThe `export` directive takes a variable and sets it the environment for all shell commands in all the recipes:\n\n```\nshell_env_var=Shell env var, created inside of Make\nexport shell_env_var\nall:\n\techo $(shell_env_var)\n\techo $$shell_env_var\n```\n\nAs such, when you run the `make` command inside of make, you can use the `export` directive to make it accessible to sub-make commands. In this example, `cooly` is exported such that the makefile in subdir can use it.\n\n```\nnew_contents = \"hello:\\n\\techo \\$$(cooly)\"\n\nall:\n\tmkdir -p subdir\n\tprintf $(new_contents) | sed -e 's/^ //' > subdir/makefile\n\t@echo \"---MAKEFILE CONTENTS---\"\n\t@cd subdir && cat makefile\n\t@echo \"---END MAKEFILE CONTENTS---\"\n\tcd subdir && $(MAKE)\n\n# Note that variables and exports. They are set/affected globally.\ncooly = \"The subdirectory can see me!\"\nexport cooly\n# This would nullify the line above: unexport cooly\n\nclean:\n\trm -rf subdir\n```\n\nYou need to export variables to have them run in the shell as well.\n\n```\none=this will only work locally\nexport two=we can run subcommands with this\n\nall: \n\t@echo $(one)\n\t@echo $$one\n\t@echo $(two)\n\t@echo $$two\n```\n\n`.EXPORT_ALL_VARIABLES` exports all variables for you.\n\n```\n.EXPORT_ALL_VARIABLES:\nnew_contents = \"hello:\\n\\techo \\$$(cooly)\"\n\ncooly = \"The subdirectory can see me!\"\n# This would nullify the line above: unexport cooly\n\nall:\n\tmkdir -p subdir\n\tprintf $(new_contents) | sed -e 's/^ //' > subdir/makefile\n\t@echo \"---MAKEFILE CONTENTS---\"\n\t@cd subdir && cat makefile\n\t@echo \"---END MAKEFILE CONTENTS---\"\n\tcd subdir && $(MAKE)\n\nclean:\n\trm -rf subdir\n```\n\n## Arguments to make\n\nThere's a nice [list of options](http://www.gnu.org/software/make/manual/make.html#Options-Summary) that can be run from make. Check out `--dry-run`, `--touch`, `--old-file`.\n\nYou can have multiple targets to make, i.e. `make clean run test` runs the `clean` goal, then `run`, and then `test`.\n\n# Variables Pt. 2\n\n## Flavors and modification\n\nThere are two flavors of variables:\n\n- recursive (use `=`) - only looks for the variables when the command is _used_, not when it's _defined_.\n- simply expanded (use `:=`) - like normal imperative programming -- only those defined so far get expanded\n\n```\n# Recursive variable. This will print \"later\" below\none = one ${later_variable}\n# Simply expanded variable. This will not print \"later\" below\ntwo := two ${later_variable}\n\nlater_variable = later\n\nall: \n\techo $(one)\n\techo $(two)\n```\n\nSimply expanded (using `:=`) allows you to append to a variable. Recursive definitions will give an infinite loop error.\n\n```\none = hello\n# one gets defined as a simply expanded variable (:=) and thus can handle appending\none := ${one} there\n\nall: \n\techo $(one)\n```\n\n`?=` only sets variables if they have not yet been set\n\n```\none = hello\none ?= will not be set\ntwo ?= will be set\n\nall: \n\techo $(one)\n\techo $(two)\n```\n\nSpaces at the end of a line are not stripped, but those at the start are. To make a variable with a single space, use `$(nullstring)`\n\n```\nwith_spaces = hello   # with_spaces has many spaces after \"hello\"\nafter = $(with_spaces)there\n\nnullstring =\nspace = $(nullstring) # Make a variable with a single space.\n\nall: \n\techo \"$(after)\"\n\techo start\"$(space)\"end\n```\n\nAn undefined variable is actually an empty string!\n\n```\nall: \n\t# Undefined variables are just empty strings!\n\techo $(nowhere)\n```\n\nUse `+=` to append\n\n```\nfoo := start\nfoo += more\n\nall: \n\techo $(foo)\n```\n\n[String Substitution](https://makefiletutorial.com/#string-substitution) is also a really common and useful way to modify variables. Also check out [Text Functions](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#Text-Functions) and [Filename Functions](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#File-Name-Functions).\n\n## Command line arguments and override\n\nYou can override variables that come from the command line by using `override`. Here we ran make with `make option_one=hi`\n\n```\n# Overrides command line arguments\noverride option_one = did_override\n# Does not override command line arguments\noption_two = not_override\nall: \n\techo $(option_one)\n\techo $(option_two)\n```\n\n## List of commands and define\n\nThe [define directive](https://www.gnu.org/software/make/manual/html_node/Multi_002dLine.html) is not a function, though it may look that way. I've seen it used so infrequently that I won't go into details, but it's mainly used for defining [canned recipes](https://www.gnu.org/software/make/manual/html_node/Canned-Recipes.html#Canned-Recipes) and also pairs well with the [eval function](https://www.gnu.org/software/make/manual/html_node/Eval-Function.html#Eval-Function).\n\n`define`/`endef` simply creates a variable that is set to a list of commands. Note here that it's a bit different than having a semi-colon between commands, because each is run in a separate shell, as expected.\n\n```\none = export blah=\"I was set!\"; echo $$blah\n\ndefine two\nexport blah=\"I was set!\"\necho $$blah\nendef\n\nall: \n\t@echo \"This prints 'I was set'\"\n\t@$(one)\n\t@echo \"This does not print 'I was set' because each command runs in a separate shell\"\n\t@$(two)\n```\n\n## Target-specific variables\n\nVariables can be set for specific targets\n\n```\nall: one = cool\n\nall: \n\techo one is defined: $(one)\n\nother:\n\techo one is nothing: $(one)\n```\n\n## Pattern-specific variables\n\nYou can set variables for specific target _patterns_\n\n```\n%.c: one = cool\n\nblah.c: \n\techo one is defined: $(one)\n\nother:\n\techo one is nothing: $(one)\n```\n\n# Conditional part of Makefiles\n\n## Conditional if/else\n\n```\nfoo = ok\n\nall:\nifeq ($(foo), ok)\n\techo \"foo equals ok\"\nelse\n\techo \"nope\"\nendif\n```\n\n## Check if a variable is empty\n\n```\nnullstring =\nfoo = $(nullstring) # end of line; there is a space here\n\nall:\nifeq ($(strip $(foo)),)\n\techo \"foo is empty after being stripped\"\nendif\nifeq ($(nullstring),)\n\techo \"nullstring doesn't even have spaces\"\nendif\n```\n\n## Check if a variable is defined\n\nifdef does not expand variable references; it just sees if something is defined at all\n\n```\nbar =\nfoo = $(bar)\n\nall:\nifdef foo\n\techo \"foo is defined\"\nendif\nifndef bar\n\techo \"but bar is not\"\nendif\n```\n\n## $(MAKEFLAGS)\n\nThis example shows you how to test make flags with `findstring` and `MAKEFLAGS`. Run this example with `make -i` to see it print out the echo statement.\n\n```\nall:\n# Search for the \"-i\" flag. MAKEFLAGS is just a list of single characters, one per flag. So look for \"i\" in this case.\nifneq (,$(findstring i, $(MAKEFLAGS)))\n\techo \"i was passed to MAKEFLAGS\"\nendif\n```\n\n# Functions\n\n## First Functions\n\n_Functions_ are mainly just for text processing. Call functions with `$(fn, arguments)` or `${fn, arguments}`. Make has a decent amount of [builtin functions](https://www.gnu.org/software/make/manual/html_node/Functions.html).\n\n```\nbar := ${subst not,\"totally\", \"I am not superman\"}\nall: \n\t@echo $(bar)\n```\n\nIf you want to replace spaces or commas, use variables\n\n```\ncomma := ,\nempty:=\nspace := $(empty) $(empty)\nfoo := a b c\nbar := $(subst $(space),$(comma),$(foo))\n\nall: \n\t@echo $(bar)\n```\n\nDo NOT include spaces in the arguments after the first. That will be seen as part of the string.\n\n```\ncomma := ,\nempty:=\nspace := $(empty) $(empty)\nfoo := a b c\nbar := $(subst $(space), $(comma) , $(foo)) # Watch out!\n\nall: \n\t# Output is \", a , b , c\". Notice the spaces introduced\n\t@echo $(bar)\n```\n\n## String Substitution\n\n`$(patsubst pattern,replacement,text)` does the following:\n\n\"Finds whitespace-separated words in text that match pattern and replaces them with replacement. Here pattern may contain a % which acts as a wildcard, matching any number of any characters within a word. If replacement also contains a %, the % is replaced by the text that matched the % in pattern. Only the first % in the pattern and replacement is treated this way; any subsequent % is unchanged.\" ([GNU docs](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#Text-Functions))\n\nThe substitution reference `$(text:pattern=replacement)` is a shorthand for this.\n\nThere's another shorthand that replaces only suffixes: `$(text:suffix=replacement)`. No `%` wildcard is used here.\n\nNote: don't add extra spaces for this shorthand. It will be seen as a search or replacement term.\n\n```\nfoo := a.o b.o l.a c.o\none := $(patsubst %.o,%.c,$(foo))\n# This is a shorthand for the above\ntwo := $(foo:%.o=%.c)\n# This is the suffix-only shorthand, and is also equivalent to the above.\nthree := $(foo:.o=.c)\n\nall:\n\techo $(one)\n\techo $(two)\n\techo $(three)\n```\n\n## The foreach function\n\nThe foreach function looks like this: `$(foreach var,list,text)`. It converts one list of words (separated by spaces) to another. `var` is set to each word in list, and `text` is expanded for each word.  \nThis appends an exclamation after each word:\n\n```\nfoo := who are you\n# For each \"word\" in foo, output that same word with an exclamation after\nbar := $(foreach wrd,$(foo),$(wrd)!)\n\nall:\n\t# Output is \"who! are! you!\"\n\t@echo $(bar)\n```\n\n## The if function\n\n`if` checks if the first argument is nonempty. If so, runs the second argument, otherwise runs the third.\n\n```\nfoo := $(if this-is-not-empty,then!,else!)\nempty :=\nbar := $(if $(empty),then!,else!)\n\nall:\n\t@echo $(foo)\n\t@echo $(bar)\n```\n\n## The call function\n\nMake supports creating basic functions. You \"define\" the function just by creating a variable, but use the parameters `$(0)`, `$(1)`, etc. You then call the function with the special [`call`](https://www.gnu.org/software/make/manual/html_node/Call-Function.html#Call-Function) builtin function. The syntax is `$(call variable,param,param)`. `$(0)` is the variable, while `$(1)`, `$(2)`, etc. are the params.\n\n```\nsweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3)\n\nall:\n\t# Outputs \"Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:\"\n\t@echo $(call sweet_new_fn, go, tigers)\n```\n\n## The shell function\n\nshell - This calls the shell, but it replaces newlines with spaces!\n\n```\nall: \n\t@echo $(shell ls -la) # Very ugly because the newlines are gone!\n```\n\n## The filter function\n\nThe `filter` function is used to select certain elements from a list that match a specific pattern. For example, this will select all elements in `obj_files` that end with `.o`.\n\n```\nobj_files = foo.result bar.o lose.o\nfiltered_files = $(filter %.o,$(obj_files))\n\nall:\n\t@echo $(filtered_files)\n```\n\nFilter can also be used in more complex ways:\n\n1. **Filtering multiple patterns**: You can filter multiple patterns at once. For example, `$(filter %.c %.h, $(files))` will select all `.c` and `.h` files from the files list.\n    \n2. **Negation**: If you want to select all elements that do not match a pattern, you can use `filter-out`. For example, `$(filter-out %.h, $(files))` will select all files that are not `.h` files.\n    \n3. **Nested filter**: You can nest filter functions to apply multiple filters. For example, `$(filter %.o, $(filter-out test%, $(objects)))` will select all object files that end with `.o` but don't start with `test`.\n    \n\n# Other Features\n\n## Include Makefiles\n\nThe include directive tells make to read one or more other makefiles. It's a line in the makefile that looks like this:\n\n```\ninclude filenames...\n```\n\nThis is particularly useful when you use compiler flags like `-M` that create Makefiles based on the source. For example, if some c files includes a header, that header will be added to a Makefile that's written by gcc. I talk about this more in the [Makefile Cookbook](https://makefiletutorial.com/#makefile-cookbook)\n\n## The vpath Directive\n\nUse vpath to specify where some set of prerequisites exist. The format is `vpath <pattern> <directories, space/colon separated>` `<pattern>` can have a `%`, which matches any zero or more characters. You can also do this globallyish with the variable VPATH\n\n```\nvpath %.h ../headers ../other-directory\n\n# Note: vpath allows blah.h to be found even though blah.h is never in the current directory\nsome_binary: ../headers blah.h\n\ttouch some_binary\n\n../headers:\n\tmkdir ../headers\n\n# We call the target blah.h instead of ../headers/blah.h, because that's the prereq that some_binary is looking for\n# Typically, blah.h would already exist and you wouldn't need this.\nblah.h:\n\ttouch ../headers/blah.h\n\nclean:\n\trm -rf ../headers\n\trm -f some_binary\n```\n\n## Multiline\n\nThe backslash (\"\\\") character gives us the ability to use multiple lines when the commands are too long\n\n```\nsome_file: \n\techo This line is too long, so \\\n\t\tit is broken up into multiple lines\n```\n\n## .phony\n\nAdding `.PHONY` to a target will prevent Make from confusing the phony target with a file name. In this example, if the file `clean` is created, make clean will still be run. Technically, I should have used it in every example with `all` or `clean`, but I wanted to keep the examples clean. Additionally, \"phony\" targets typically have names that are rarely file names, and in practice many people skip this.\n\n```\nsome_file:\n\ttouch some_file\n\ttouch clean\n\n.PHONY: clean\nclean:\n\trm -f some_file\n\trm -f clean\n```\n\n## .delete_on_error\n\nThe make tool will stop running a rule (and will propogate back to prerequisites) if a command returns a nonzero exit status.  \n`DELETE_ON_ERROR` will delete the target of a rule if the rule fails in this manner. This will happen for all targets, not just the one it is before like PHONY. It's a good idea to always use this, even though make does not for historical reasons.\n\n```\n.DELETE_ON_ERROR:\nall: one two\n\none:\n\ttouch one\n\tfalse\n\ntwo:\n\ttouch two\n\tfalse\n```\n\n# Makefile Cookbook\n\nLet's go through a really juicy Make example that works well for medium sized projects.\n\nThe neat thing about this makefile is it automatically determines dependencies for you. All you have to do is put your C/C++ files in the `src/` folder.\n\n```C\n# Thanks to Job Vranish (https://spin.atomicobject.com/2016/08/26/makefile-c-projects/)\nTARGET_EXEC := final_program\n\nBUILD_DIR := ./build\nSRC_DIRS := ./src\n\n# Find all the C and C++ files we want to compile\n# Note the single quotes around the * expressions. The shell will incorrectly expand these otherwise, but we want to send the * directly to the find command.\nSRCS := $(shell find $(SRC_DIRS) -name '*.cpp' -or -name '*.c' -or -name '*.s')\n\n# Prepends BUILD_DIR and appends .o to every src file\n# As an example, ./your_dir/hello.cpp turns into ./build/./your_dir/hello.cpp.o\nOBJS := $(SRCS:%=$(BUILD_DIR)/%.o)\n\n# String substitution (suffix version without %).\n# As an example, ./build/hello.cpp.o turns into ./build/hello.cpp.d\nDEPS := $(OBJS:.o=.d)\n\n# Every folder in ./src will need to be passed to GCC so that it can find header files\nINC_DIRS := $(shell find $(SRC_DIRS) -type d)\n# Add a prefix to INC_DIRS. So moduleA would become -ImoduleA. GCC understands this -I flag\nINC_FLAGS := $(addprefix -I,$(INC_DIRS))\n\n# The -MMD and -MP flags together generate Makefiles for us!\n# These files will have .d instead of .o as the output.\nCPPFLAGS := $(INC_FLAGS) -MMD -MP\n\n# The final build step.\n$(BUILD_DIR)/$(TARGET_EXEC): $(OBJS)\n\t$(CXX) $(OBJS) -o $@ $(LDFLAGS)\n\n# Build step for C source\n$(BUILD_DIR)/%.c.o: %.c\n\tmkdir -p $(dir $@)\n\t$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@\n\n# Build step for C++ source\n$(BUILD_DIR)/%.cpp.o: %.cpp\n\tmkdir -p $(dir $@)\n\t$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $< -o $@\n\n\n.PHONY: clean\nclean:\n\trm -r $(BUILD_DIR)\n\n# Include the .d makefiles. The - at the front suppresses the errors of missing\n# Makefiles. Initially, all the .d files will be missing, and we don't want those\n# errors to show up.\n-include $(DEPS)\n```",
          "excerpt": "Why do Makefiles exist?\n\nMakefiles are used to help decide which parts of a large program need to be recompiled. In the vast majority of cases, C or C++ files are compiled. Other languages typically h...",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-07-23T10:38:06.000Z"
        },
        {
          "id": "991-clang-memory-management-in-c-md",
          "slug": "991-clang/memory-management-in-c",
          "filepath": "991-CLANG/Memory Management in C.md",
          "folder": "991-CLANG",
          "filename": "Memory Management in C.md",
          "frontmatter": {
            "title": "Example: Read in File",
            "date": "2025-07-23",
            "tags": [
              "C",
              "c",
              "fn6",
              "how",
              "multiple"
            ],
            "category": "991-CLANG"
          },
          "content": "## Example: Read in File\n\n```C\nFILE *fp = fopen(\"input.txt\", \"r\");\nchar line[1024];\nchar **lines = NULL;\nsize_t num_lines = 0;\nif (!fp) {\n\tabort();\n}  \n// 1. Read in the file.\nwhile (1) {    \n\tchar *l = fgets(line, sizeof(line), fp);\n\tif (!l) {\n\t    break; // End of file (hopefully).    \n\t}    \n\t// Make room in the list of lines.\n\tif (!num_lines) {\n\t\tlines = malloc(sizeof(char *));\n\t} else {\n\t    lines = realloc(lines, (num_lines + 1) * sizeof(char *));\n\t}    \n\tif (!lines) {\n\t    abort(); // We are out of memory so panic.\n\t}    \n\tchar *copy = strdup(l);\n\tif (!copy) {\n\t    abort(); // We are out of memory so panic.\n\t}    \n\tlines[num_lines] = copy;\n    num_lines++;\n}\n```\n\nwe have the next line of the file in `line`, but we overwrite that buffer every time we read a new line from the file, so we need to store it somewhere. We use the `lines` variable for this, which is defined as:\n\n```c\n  char **lines = NULL;  size_t num_lines = 0;\n```\n\nStoring a copy of `line` is a two-part process:\n\n1. Make a copy of the line itself.\n2. Store the pointer to that line in `lines`.\n\nHowever, in order to store that pointer, we first need to make room in `lines`, which means allocating some memory. There are actually two cases here:\n\n1. Lines is empty (nothing is stored), which happens at the start.\n2. Lines is non-empty but doesn't have enough room.\n\nWe distinguish these by looking at `num_lines` which starts at `0`. In the former case, we allocate enough memory for a single line, like so:\n\n```c\n      lines = malloc(sizeof(char *));\n```\n\n==The latter case is more complicated, however, because we already have something in `lines`, it's just that there's not (necessarily) enough room in memory to add another value. This means we (may) need to\n\n1. Allocate enough memory to hold the new number of values.\n2. Copy over the current contents of `lines` into the new memory region.\n3. De-allocate the original memory.\n\n### When you call `malloc(size)` the system guarantees that the returned pointer is _at least_ big enough to hold an object of size `size`assuming that the allocation succeedsbut it's allowed to be larger\n\nAs we are doing here, then it's not efficient to have to copy the contents of the object over and over again. Instead, you can allocate more space than the programmer asked for and then when they ask for more, just say \"ok\" without taking any other action. All of this is handled automatically by the `realloc()` function call.\n\n\nIf this function were to return without cleaning up, it would create what's called a \"memory leak\". Remember that the only variable in our program that knows about any of this memory is `lines`, which points to the list of pointers for the individual stored lines. `lines` is on the stack and will be lost when the function returns, so if the function returns without cleaning up, then there is no program variable pointing to any of this memory and it's just lost.[[6]](https://educatedguesswork.org/posts/memory-management-1/#fn6) The result of a memory leak is that the leaked memory isn't available for new allocations but also can't be used because there's nothing pointing to it. If the program runs long enough and has a big enough leak, you can eventually accumulate enough leaked memory to affect the program function or even cause it to run out of memory, so you want to clean up. This is one reason why it often works to restart a program that seems stalled.\n\n```c\n  // Clean up.  \n  fclose(fp);  \n  for (size_t i=0; i<num_lines; i++) {\n      free(lines[i]);  \n\t}  \n  free(lines);\n```\n\n## How `malloc()` works [#](https://educatedguesswork.org/posts/memory-management-1/#how-malloc\\(\\)-works)\n\nSo far we've just been treating `malloc()` as a kind of black box, and that's generally fine for most programming tasks, but it's helpful to have some sense of what's going on internally. The first thing to realize is that `malloc()` isn't magic. In fact, you can write your own memory allocator in C (Firefox, for instance, uses a custom allocator).\n\nAt a very high level, you should think of `malloc()` as having access to one or more large contiguous blocks of memory, which it then dispenses on demand. On a very simple computer, `malloc()` would just have access to the entire memory of the machine, but on a modern multiprocess operating system, it gets chunks of memory from the operating system. For our purposes, let's easiest to think of it as having a big contiguous chunk of memory to work with. As I said, we usually wouldn't start at memory location 0, so we'll just assume the block starts at 1000.\n\nThe figure below shows the situation after a single allocation of size 200, with the allocation being red and the unallocated space being blue. What's happened here is just that `malloc(200)` just picked the first available memory region, which is at the start of the block because no memory has been allocated.\n\n![[Pasted image 20250722230727.png]]\n\nThe allocation starts at address 1000 and goes to address 1199, so `malloc()` just returns the address `1000`, which points to the start of the allocated region.\n\nThe next figure shows the situation with two more allocations, one of size 400 and one of size 200. Again, this is what you'd expect: the allocator just picks the lowest available region. As noted above, a real allocator would probably leave some extra space to facilitate growing the allocation but we're trying to keep things simple for the purpose of examples. Designing fast memory allocators is a whole (complicated) topic all on its own.\n\n![[Pasted image 20250722230831.png]]\n\nAs the program runs longer and memory is allocated and freed you tend get lots of small holes that can't be filled with big allocations, and so you have to allocate higher and higher memory regions. This is called _fragmentation_. In the extreme, you can get to the point where you can't allocate new memory even though there's actually plenty of free space; it's just not in a convenient form. There are techniques for avoiding this kind of fragmentation as well as for allocating memory more efficiently, but they're too advanced to cover here.\n\nWhen you call `malloc()` the allocator finds a suitable region and allocates it. When you call `free()` it adds it to the list of holes (or adjusts the highest allocation value if it's the highest allocation).\n\nInterestingly, it's not always necessary to store a list of every chunk of allocation memory. You can do this, but that means you need some data structure that lets you look up the allocations from their addresses. A common thing people do instead is to store the per-allocation metadata as a header right before the allocated region. The header contains the size of the allocation and maybe some other stuff. For instance, the first allocation above might look like this:\n![[Pasted image 20250722230943.png]]\n\n## Multiple References and UAF [#](https://educatedguesswork.org/posts/memory-management-1/#multiple-references-and-uaf)\n\nLet's consider a slight modification of the function we've been looking at, in which along with printing out all the lines, we instead return the last line in sort order. With a lot of trimming, the function might look like this:\n\n![[Pasted image 20250722231049.png]]\n\nThis function gets called like this:\n\n```c\nchar *largest = find_largest(\"input.txt\");printf(\"%s\\n\", largest);\n```\n\nThe experienced C programmer will immediately note that this code has a serious bug, because we are trying to use the memory pointed to `largest` after we have `free()`d it. When the calling function tries to use `largest`, there are **no guarantees at all** about what will happen. This is called a _use after free (UAF)_ bug. \nFor example, the allocator might have reallocated the memory in response to some other call to `malloc()`, in which case it is now full of some other data. Of course, it's also quite likely that the region is still unused and has the same contents as before; it's just that the allocator added it to the list of holes. In this case, the program may work fine under test but then fail unpredictably later when some change to your code causes allocations to happen differently and suddenly `largest` points to some memory reason being used for something else.\n\nThe reason this is all possible is that in C pointers are just values that hold the memory address; effectively they're just numbers and they behave like numbers. So if you assign a pointer value to another variable, now you have two variables that point to the same thing (i.e., they have the same value). When we call free on the first copy of the variable, that doesn't have any effect at all on the other copy (or on the first one, for that matter). It just changes the state of the memory region addressed by the variable. Once you've called `free(x)` you're still left with whatever is in `x`, and nothing in C stops you from using it; it's just illegal to do so, and it's your job not to, or else.\n\n\n## Memory Leaks\n\nA **memory leak** happens when dynamic memory is allocated but never freed.\n\nIf a memory leak happens in a loop or in a function that is called frequently it could take up too much memory and cause the computer to slow down.\n\nThere is a risk of a memory leak if a pointer to dynamic memory is lost before the memory can be freed. This can happen accidentally, so it is important to be careful and keep track of pointers to dynamic memory.\n\n### Example 1\n\nThe pointer is overwritten:\n```C\nint x = 5;  \nint *ptr;  \nptr = calloc(2, sizeof(*ptr));  \nptr = &x;\n```\nIn this example, after the pointer is changed to point at `x`, the memory allocated by `calloc()` can no longer be accessed.\n\n### Example 2\n\nThe pointer exists only inside a function:\n```C\nvoid myFunction() {  \n int *ptr;  \n ptr = malloc(sizeof(*ptr));  \n}  \n  \nint main() {  \n myFunction();  \n printf(\"The function has ended\");  \n return 0;  \n}\n```\n\nIn this example, the memory that was allocated inside of the function remains allocated after the function ends but it cannot be accessed anymore. One way to prevent this problem is to free the memory before the function ends.\n\n### Example 3\n\nThe pointer gets lost when reallocation fails:\n```C\nint* ptr;  \nptr = malloc(sizeof(*ptr));  \nptr = realloc(ptr, 2*sizeof(*ptr));\n```\n\nIf `realloc()` is unable to reallocate memory it will return a pointer to `NULL` and the original memory will remain reserved.\n\nIn this example, if `realloc()` fails then the `NULL` pointer is assigned to the `ptr` variable, overwriting the original memory address so that it cannot be accessed anymore.\n",
          "excerpt": "Example: Read in File\n\n\n\nwe have the next line of the file in , but we overwrite that buffer every time we read a new line from the file, so we need to store it somewhere. We use the  variable for thi...",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-07-23T09:44:55.000Z"
        },
        {
          "id": "991-clang-pointers-in-c-md",
          "slug": "991-clang/pointers-in-c",
          "filepath": "991-CLANG/Pointers in C.md",
          "folder": "991-CLANG",
          "filename": "Pointers in C.md",
          "frontmatter": {
            "title": "Pointers in C",
            "date": "2025-07-23",
            "tags": [
              "C"
            ],
            "category": "991-CLANG"
          },
          "content": "- Declaration and Derefrence have the same syntax but different meanings.\n- **void** type cast -> Generic pointer(Means the type is not known yet)\n```C\nvoid print(void *data, char datatype){\n\tif datatype == '--':\n\t\t(int*) data //Type casting it to any datatype you want\n}\n```\n\n- In C array always decays into a pointer it means decau is the process in which an array gets coverted to a pointer.\n\n-  `arr[5]==5[arr]` ??\n*arr[n] means (arr+n) therefore 5[arr] eq *(5+arr)*\n\n",
          "excerpt": "- Declaration and Derefrence have the same syntax but different meanings.\n- void type cast -> Generic pointer(Means the type is not known yet)\n\n\n- In C array always decays into a pointer it means deca...",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-07-23T10:09:59.000Z"
        },
        {
          "id": "991-clang-proxy-server-in-c-md",
          "slug": "991-clang/proxy-server-in-c",
          "filepath": "991-CLANG/Proxy Server in C.md",
          "folder": "991-CLANG",
          "filename": "Proxy Server in C.md",
          "frontmatter": {
            "title": "Socket Programming in C:",
            "date": "2025-07-23",
            "tags": [
              "c"
            ],
            "category": "991-CLANG"
          },
          "content": "This code sets up a **multithreaded proxy server** that handles HTTP GET requests and includes a **caching mechanism** to improve performance. It's designed to accept multiple client connections concurrently using threads.\n\n\n# Socket Programming in C:\n\n\n- ### Client Socket Process:\n\t- Set up a Socket (Prepare to communicate)\n        - Create a socket\n\t    - Determine server IP address and port number\n\t    - Initiate the connection to the server\n\t- Send and receive packets (Exchange data with the server)\n\t    -  Write data (i.e., request) to the socket\n\t    -  Read data (i.e., response) from the socket\n\t    -  Do stuff with the data (e.g., display a Web page)\n\t -  Close the socket.\n\n- ### Server Socket Process:\n\t-  Set up a Socket (Prepare to communicate)\n\t\t-  Create a socket s_listen (i.e., the listening socket)\n\t\t-  Associate servers IP address and port no. with the socket\n\t-  Wait to hear from a client\n\t    - Indicate how many connections can be pending on the socket\n\t    - Accept an incoming connection from a client, create a new socket s_new for the client.\n\t-  Send and receive packets (Exchange data with the client over the new socket s_new)\n\t    - Read data (i.e., client request) from the socket\n\t    - Handle the request\n\t    - Write data (i.e., server response) to the socket\n\t    - Close the socket s_new\n\t- Repeat 2.2-3.4 with the next connection request\n\n## I. Main Server Program - `proxy.c`\n\nLet's start by walking through the `main` function and then follow the execution flow to understand the other functions involved.\n\n### `main(int argc, char * argv[])`\n\n```c\nint main(int argc, char * argv[]) {\n\n\tint client_socketId, client_len; // client_socketId == to store the client socket id\n\tstruct sockaddr_in server_addr, client_addr; // Address of client and server to be assigned\n\n    sem_init(&seamaphore,0,MAX_CLIENTS); // Initializing seamaphore and lock\n    pthread_mutex_init(&lock,NULL); // Initializing lock for cache\n    \n\n\tif(argc == 2)        //checking whether two arguments are received or not\n\t{\n\t\tport_number = atoi(argv[1]);\n\t}\n\telse\n\t{\n\t\tprintf(\"Too few arguments\\n\");\n\t\texit(1);\n\t}\n\n\tprintf(\"Setting Proxy Server Port : %d\\n\",port_number);\n\n    //creating the proxy socket\n\tproxy_socketId = socket(AF_INET, SOCK_STREAM, 0);\n\n\tif( proxy_socketId < 0)\n\t{\n\t\tperror(\"Failed to create socket.\\n\");\n\t\texit(1);\n\t}\n\n\tint reuse =1;\n\tif (setsockopt(proxy_socketId, SOL_SOCKET, SO_REUSEADDR, (const char*)&reuse, sizeof(reuse)) < 0) \n        perror(\"setsockopt(SO_REUSEADDR) failed\\n\");\n\n\tbzero((char*)&server_addr, sizeof(server_addr));  \n\tserver_addr.sin_family = AF_INET;\n\tserver_addr.sin_port = htons(port_number); // Assigning port to the Proxy\n\tserver_addr.sin_addr.s_addr = INADDR_ANY; // Any available adress assigned\n\n    // Binding the socket\n\tif( bind(proxy_socketId, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0 )\n\t{\n\t\tperror(\"Port is not free\\n\");\n\t\texit(1);\n\t}\n\tprintf(\"Binding on port: %d\\n\",port_number);\n\n    // Proxy socket listening to the requests\n\tint listen_status = listen(proxy_socketId, MAX_CLIENTS);\n\n\tif(listen_status < 0 )\n\t{\n\t\tperror(\"Error while Listening !\\n\");\n\t\texit(1);\n\t}\n\n\tint i = 0; // Iterator for thread_id (tid) and Accepted Client_Socket for each thread\n\tint Connected_socketId[MAX_CLIENTS];   // This array stores socket descriptors of connected clients\n\n    // Infinite Loop for accepting connections\n\twhile(1)\n\t{\n\t\t\n\t\tbzero((char*)&client_addr, sizeof(client_addr));\t\t\t// Clears struct client_addr\n\t\tclient_len = sizeof(client_addr); \n\n        // Accepting the connections\n\t\tclient_socketId = accept(proxy_socketId, (struct sockaddr*)&client_addr,(socklen_t*)&client_len);\t// Accepts connection\n\t\tif(client_socketId < 0)\n\t\t{\n\t\t\tfprintf(stderr, \"Error in Accepting connection !\\n\");\n\t\t\texit(1);\n\t\t}\n\t\telse{\n\t\t\tConnected_socketId[i] = client_socketId; // Storing accepted client into array\n\t\t}\n\n\t\t// Getting IP address and port number of client\n\t\tstruct sockaddr_in* client_pt = (struct sockaddr_in*)&client_addr;\n\t\tstruct in_addr ip_addr = client_pt->sin_addr;\n\t\tchar str[INET_ADDRSTRLEN];\t\t\t\t\t\t\t\t\t\t// INET_ADDRSTRLEN: Default ip address size\n\t\tinet_ntop( AF_INET, &ip_addr, str, INET_ADDRSTRLEN );\n\t\tprintf(\"Client is connected with port number: %d and ip address: %s \\n\",ntohs(client_addr.sin_port), str);\n\t\t//printf(\"Socket values of index %d in main function is %d\\n\",i, client_socketId);\n\t\tpthread_create(&tid[i],NULL,thread_fn, (void*)&Connected_socketId[i]); // Creating a thread for each client accepted\n\t\ti++; \n\t}\n\tclose(proxy_socketId);\t\t\t\t\t\t\t\t\t// Close socket\n \treturn 0;\n}\n```\n\n  * **Purpose**: This is the entry point of the proxy server application. It initializes the server, sets up the listening socket, and then enters an infinite loop to accept incoming client connections, creating a new thread for each.\n  * **Parameters**:\n      * `int argc`: The number of command-line arguments provided when the program is run.\n      * `char * argv[]`: An array of **pointers** to strings, where each string is a command-line argument. `argv[0]` is typically the program's name, `argv[1]` the first argument, and so on.\n  * **Pointers and Variables**:\n      * `int client_socketId`: This integer variable will store the **socket descriptor** for each new client connection accepted by the proxy. A socket descriptor is a small integer that uniquely identifies a socket in the operating system.\n      * `int client_len`: An integer to store the size of the client's address structure.\n      * `struct sockaddr_in server_addr`, `struct sockaddr_in client_addr`: These are structures that hold internet socket addresses.\n          * `server_addr`: Will store the proxy server's own IP address and port.\n          * `client_addr`: Will store the connecting client's IP address and port.\n          * **Pointers**: ==When using these structures with socket functions, you often need to cast their **addresses** to `(struct sockaddr*)`. For example, `(struct sockaddr*)&server_addr` means \"take the address of `server_addr` and treat it as a pointer to a generic `sockaddr` structure.\"\n      * `sem_init(&seamaphore, 0, MAX_CLIENTS)`: Initializes a **semaphore**.\n          * `&seamaphore`: The **address** of the `sem_t` variable to initialize.\n          * `0`: Indicates that this semaphore is shared between threads of the same process.\n          * `MAX_CLIENTS`: The initial value (or maximum value) of the semaphore. This means up to `MAX_CLIENTS` threads can proceed without blocking on this semaphore. It limits concurrent client handling.\n      * `pthread_mutex_init(&lock, NULL)`: Initializes a ==**mutex** (mutual exclusion lock).\n          * `&lock`: *The* **address** of the `pthread_mutex_t` variable to initialize.\n          * `NULL`: Uses default mutex attributes. This mutex will be used to protect the shared **cache** from simultaneous access by multiple threads, preventing data corruption.\n      * `port_number = atoi(argv[1])`: If a command-line argument is provided (`argc == 2`), it converts the first argument string (pointed to by `argv[1]`) to an integer and assigns it to `port_number`.\n      * `proxy_socketId = socket(AF_INET, SOCK_STREAM, 0)`: Creates the main **listening socket** for the proxy server.\n          * `AF_INET`: Specifies the address family as IPv4.\n          * `SOCK_STREAM`: Specifies a stream socket, which provides reliable, ordered, and error-checked data delivery (TCP).\n          * `0`: Specifies the default protocol for the given family and type.\n          * The return value is a **socket descriptor** (an `int`). If it's less than `0`, an error occurred.\n      * `setsockopt(proxy_socketId, SOL_SOCKET, SO_REUSEADDR, (const char*)&reuse, sizeof(reuse))`: This sets a socket option.\n          * `proxy_socketId`: The socket to apply the option to.\n          * `SOL_SOCKET`: Specifies the option applies at the socket level.\n          * `SO_REUSEADDR`: Allows the port to be reused immediately after the server closes, even if previous connections are in `TIME_WAIT` state. This is crucial for rapid development and testing.\n          * `(const char*)&reuse`: A **pointer** to an integer (`reuse`) containing the option value (`1` for true).\n          * `sizeof(reuse)`: The size of the option value.\n      * `bzero((char*)&server_addr, sizeof(server_addr))`: Fills the `server_addr` structure with zeros. `(char*)&server_addr` casts the **address** of `server_addr` to a `char*` so `bzero` can operate on its raw bytes.\n      * `server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port_number); server_addr.sin_addr.s_addr = INADDR_ANY;`: Configures the `server_addr` structure:\n          * `sin_family`: Address family (IPv4).\n          * `sin_port`: The port number, converted to network byte order using `htons()`.\n          * `sin_addr.s_addr`: The IP address. `INADDR_ANY` means the server will listen on all available network interfaces.\n      * `bind(proxy_socketId, (struct sockaddr*)&server_addr, sizeof(server_addr))`: Associates the `proxy_socketId` with the `server_addr` (IP address and port). `(struct sockaddr*)&server_addr` is a **pointer** cast.\n      * `listen(proxy_socketId, MAX_CLIENTS)`: Puts the `proxy_socketId` into a listening state, ready to accept incoming connections. `MAX_CLIENTS` specifies the maximum length of the queue of pending connections.\n      * `int Connected_socketId[MAX_CLIENTS]`: An array to store the socket descriptors of currently connected clients. Each element is an `int`.\n      * `while(1)`: An infinite loop, making the server continuously run and accept new connections.\n      * `client_socketId = accept(proxy_socketId, (struct sockaddr*)&client_addr, (socklen_t*)&client_len)`: This is where the server waits for a client to connect.\n          * `proxy_socketId`: The listening socket.\n          * `(struct sockaddr*)&client_addr`: A **pointer** to a `sockaddr_in` structure where the client's address information will be stored.\n          * `(socklen_t*)&client_len`: A **pointer** to an integer that, on input, specifies the size of `client_addr` and, on output, specifies the actual size of the stored client address.\n          * It returns a **new socket descriptor** (`client_socketId`) dedicated to communication with this specific client. If it's less than `0`, an error occurred.\n      * `struct sockaddr_in* client_pt = (struct sockaddr_in*)&client_addr;`: Creates a **pointer** `client_pt` that points to the `client_addr` structure. This makes it easier to access members like `sin_addr`.\n      * `struct in_addr ip_addr = client_pt->sin_addr;`: Accesses the `sin_addr` member (which is of type `struct in_addr`) from the `client_addr` structure using the `client_pt` **pointer**. The `->` operator is used to access members of a structure through a pointer.\n      * `inet_ntop(AF_INET, &ip_addr, str, INET_ADDRSTRLEN)`: Converts the numeric IP address (`ip_addr`, whose **address** is passed) into a human-readable string format, storing it in `str`.\n      * `pthread_create(&tid[i], NULL, thread_fn, (void*)&Connected_socketId[i])`: This is the core of the multithreading. It creates a new thread for each accepted client.\n          * `&tid[i]`: The **address** of the `pthread_t` variable that will store the ID of the new thread.\n          * `NULL`: Uses default thread attributes.\n          * `thread_fn`: The **function pointer** to the function that the new thread will execute. This is the client-handling logic.\n          * `(void*)&Connected_socketId[i]`: The **argument** passed to `thread_fn`. It's a **pointer** to the `client_socketId` (which is stored in `Connected_socketId[i]`), cast to `void*` because `pthread_create` expects a `void*` argument. Inside `thread_fn`, this `void*` will be cast back to an `int*` to get the client's socket descriptor.\n      * `i++`: Increments the thread counter to prepare for the next client.\n      * `close(proxy_socketId)`: Closes the main listening socket when the server is shut down (though in this infinite loop, it's unreachable unless the loop breaks).\n\n-----\n\n### `thread_fn(void* socketNew)`\n\n```c\nvoid* thread_fn(void* socketNew)\n{\n\tsem_wait(&seamaphore);\n\tint p;\n\tsem_getvalue(&seamaphore,&p);\n\tprintf(\"Semaphore value:%d\\n\",p);\n\tint socket = *(int *)socketNew; // Dereferencing the void pointer to get the actual socket ID\n\tint bytes_send_client;\n\tchar *buffer = (char*)calloc(MAX_BYTES, sizeof(char));\n\tbzero(buffer, MAX_BYTES);\n\t\n\tbytes_send_client = recv(socket, buffer, MAX_BYTES, 0);\n\n\tchar *temp_buffer_ptr = NULL; \n\tint len = 0;\n\n\t// This loop will execute as long as there is data to be received\n\t// from the client and the end of the HTTP header (\"\\r\\n\\r\\n\") has\n\t// not been found yet.\n\twhile(bytes_send_client > 0)\n\t{\n\t\tlen = strlen(buffer);\n        //loop until u find \"\\r\\n\\r\\n\" in the buffer\n\t\tif(strstr(buffer, \"\\r\\n\\r\\n\") == NULL)\n\t\t{\t\n\t\t\tbytes_send_client = recv(socket, buffer + len, MAX_BYTES - len, 0);\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tchar *tempReq = (char*)malloc(strlen(buffer)*sizeof(char)+1);\n    //tempReq, buffer both store the http request sent by client\n\tfor (int i = 0; i < strlen(buffer); i++)\n\t{\n\t\ttempReq[i] = buffer[i];\n\t}\n\t\n\t//checking for the request in cache \n\tstruct cache_element* temp = find(tempReq);\n\n\tif( temp != NULL){\n        //request found in cache, so sending the response to client from proxy's cache\n\t\tint size=temp->len/sizeof(char);\n\t\tint pos=0;\n\t\tchar response[MAX_BYTES];\n\t\twhile(posdata[pos];\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tsend(socket,response,MAX_BYTES,0);\n\t\t}\n\t\tprintf(\"Data retrived from the Cache\\n\\n\");\n\t\tprintf(\"%s\\n\\n\",response);\n\t\t// close(socketNew);\n\t\t// sem_post(&seamaphore);\n\t\t// return NULL;\n\t}\n\t\n\t\n\telse if(bytes_send_client > 0)\n\t{\n\t\tlen = strlen(buffer); \n\t\t//Parsing the request\n\t\tParsedRequest* request = ParsedRequest_create();\n\t\t\n        //ParsedRequest_parse returns 0 on success and -1 on failure.On success it stores parsed request in\n        // the request\n\t\tif (ParsedRequest_parse(request, buffer, len) < 0) \n\t\t{\n\t\t   \tprintf(\"Parsing failed\\n\");\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\tbzero(buffer, MAX_BYTES);\n\t\t\tif(!strcmp(request->method,\"GET\"))\t\t\t\t\t\t\t\n\t\t\t{\n                \n\t\t\t\tif( request->host && request->path && (checkHTTPversion(request->version) == 1) )\n\t\t\t\t{\n\t\t\t\t\tbytes_send_client = handle_request(socket, request, tempReq);\t\t// Handle GET request\n\t\t\t\t\tif(bytes_send_client == -1)\n\t\t\t\t\t{\t\n\t\t\t\t\t\tsendErrorMessage(socket, 500);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsendErrorMessage(socket, 500);\t\t\t// 500 Internal Error\n\n\t\t\t}\n            else\n            {\n                printf(\"This code doesn't support any method other than GET\\n\");\n            }\n    \n\t\t}\n        //freeing up the request pointer\n\t\tParsedRequest_destroy(request);\n\n\t}\n\n\telse if( bytes_send_client < 0)\n\t{\n\t\tperror(\"Error in receiving from client.\\n\");\n\t}\n\telse if(bytes_send_client == 0)\n\t{\n\t\tprintf(\"Client disconnected!\\n\");\n\t}\n\n\tshutdown(socket, SHUT_RDWR);\n\tclose(socket);\n\tfree(buffer);\n\tsem_post(&seamaphore);\t\n\t\n\tsem_getvalue(&seamaphore,&p);\n\tprintf(\"Semaphore post value:%d\\n\",p);\n\tfree(tempReq);\n\treturn NULL;\n}\n```\n\n  * **Purpose**: This function is the main logic executed by each new thread. It receives an HTTP request from a client, checks the cache for it, serves from cache if found, otherwise forwards the request to the origin server, receives the response, and then caches it before sending it back to the client.\n  * **Parameters**:\n      * `void* socketNew`: A **generic pointer** (`void*`) to the `client_socketId` for this specific client connection. It needs to be cast back to an `int*` to be used.\n  * **Pointers and Variables**:\n      * `sem_wait(&seamaphore)`: Decrements the **semaphore** count. If the count is zero (meaning `MAX_CLIENTS` threads are already active), the calling thread will block until another thread releases the semaphore. This ensures we don't exceed `MAX_CLIENTS` concurrent connections.\n      * `int socket = *(int *)socketNew;`: This is crucial for **pointer dereferencing**.\n          * `(int *)socketNew`: Casts the `void*` `socketNew` back to an `int*` (a pointer to an integer).\n          * `*(int *)socketNew`: **Dereferences** the `int*` to get the actual integer value that `socketNew` points to, which is the `client_socketId`. This `socket` variable is then used for all communication with this client within the thread.\n      * `char *buffer = (char*)calloc(MAX_BYTES, sizeof(char))`: Dynamically allocates memory for `MAX_BYTES` characters and initializes them all to zero. This `buffer` will be used to receive the HTTP request from the client.\n      * `bytes_send_client = recv(socket, buffer, MAX_BYTES, 0)`: Receives data from the client's `socket` into the `buffer`. `bytes_send_client` stores the number of bytes actually received.\n      * `strstr(buffer, \"\\r\\n\\r\\n\")`: This string function searches for the first occurrence of the HTTP header termination sequence (`\\r\\n\\r\\n`) within the `buffer`. It returns a **pointer** to the first character of the found substring, or `NULL` if not found.\n      * `char *tempReq = (char*)malloc(strlen(buffer)*sizeof(char)+1)`: Dynamically allocates memory for `tempReq`, which will store a copy of the raw HTTP request received from the client. This copy is used as the **key for the cache**.\n      * `struct cache_element* temp = find(tempReq)`: Calls the `find` function (explained later) to check if the `tempReq` (the URL) exists in the cache. `temp` will be a **pointer** to the `cache_element` if found, or `NULL`.\n      * **Cache Hit (`if(temp != NULL)`)**:\n          * If the request is found in the cache, the stored response (`temp->data`) is sent back to the client in chunks of `MAX_BYTES`.\n          * `temp->len`: The length of the cached data.\n          * `temp->data[pos]`: Accessing individual characters of the cached data using array-like syntax with the **pointer** `temp->data`.\n          * `send(socket, response, MAX_BYTES, 0)`: Sends the cached data to the client.\n      * **Cache Miss (`else if(bytes_send_client > 0)`)**:\n          * `ParsedRequest* request = ParsedRequest_create()`: Creates a new `ParsedRequest` object. This function returns a **pointer** to a dynamically allocated `ParsedRequest` structure.\n          * `ParsedRequest_parse(request, buffer, len)`: Parses the raw HTTP request (`buffer`) into the `request` structure. This function populates the fields (method, host, path, headers, etc.) within the `ParsedRequest` structure pointed to by `request`.\n          * `strcmp(request->method, \"GET\")`: Compares the HTTP method (pointed to by `request->method`) to \"GET\".\n          * `request->host`, `request->path`, `request->version`: These are **pointers** to strings within the `ParsedRequest` structure, holding the parsed components of the URL and HTTP version.\n          * `handle_request(socket, request, tempReq)`: If it's a valid GET request, calls `handle_request` to fetch the content from the remote server, send it to the client, and add it to the cache.\n          * `sendErrorMessage(socket, 500)`: Sends an appropriate HTTP error if something goes wrong.\n          * `ParsedRequest_destroy(request)`: Frees the memory allocated for the `ParsedRequest` structure and its internal components.\n      * `shutdown(socket, SHUT_RDWR)`: Disables further sends and receives on the client socket.\n      * `close(socket)`: Closes the client socket.\n      * `free(buffer); free(tempReq);`: Frees the dynamically allocated memory for `buffer` and `tempReq`.\n      * `sem_post(&seamaphore)`: Increments the **semaphore** count, signaling that this thread has finished handling a client and another waiting thread can now proceed.\n      * `sem_getvalue(&seamaphore, &p)`: Retrieves the current value of the semaphore and stores it in `p`. `&p` is the **address** of the integer where the value will be stored.\n      * `return NULL`: Threads typically return `NULL` from their `void*` function.\n\n-----\n\n### `sendErrorMessage(int socket, int status_code)`\n\n```c\nint sendErrorMessage(int socket, int status_code)\n{\n\tchar str[1024];\n\tchar currentTime[50];\n\ttime_t now = time(0);\n\n\tstruct tm data = *gmtime(&now);\n\tstrftime(currentTime,sizeof(currentTime),\"%a, %d %b %Y %H:%M:%S %Z\", &data);\n\n\tswitch(status_code)\n\t{\n\t\t// ... (cases for 400, 403, 404, 500, 501, 505) ...\n\t}\n\treturn 1;\n}\n```\n\n  * **Purpose**: This function constructs and sends an HTTP error response back to the client based on a given HTTP status code.\n  * **Parameters**:\n      * `int socket`: The **socket descriptor** of the client connection to which the error message should be sent.\n      * `int status_code`: The HTTP status code (e.g., 400 for Bad Request).\n  * **Pointers and Variables**:\n      * `char str[1024]`: A local character array (buffer) to build the HTTP error response string.\n      * `char currentTime[50]`: A local character array to store the formatted current timestamp.\n      * `time_t now = time(0)`: Gets the current time in seconds since the Epoch.\n      * `struct tm data = *gmtime(&now)`: Converts the `time_t` value (`now`) into a broken-down time structure (`struct tm`) in Coordinated Universal Time (UTC). `gmtime()` returns a **pointer** to a `struct tm`, and `*` **dereferences** it to get the structure itself.\n      * ` strftime(currentTime, sizeof(currentTime), ...)  `: Formats the `struct tm` data into a human-readable date and time string, storing it in `currentTime`.\n      * `snprintf(str, sizeof(str), ...)`: Formats the full HTTP error response string (including headers and a simple HTML body) into the `str` buffer. It uses `currentTime` (a string **pointer**) to embed the current date.\n      * `send(socket, str, strlen(str), 0)`: Sends the constructed HTTP error response string over the provided `socket`. `strlen(str)` provides the exact length of the string to send.\n\n-----\n\n### `checkHTTPversion(char* msg)`\n\n```c\nint checkHTTPversion(char* msg)\n{\n\t// This Function checks for the HTTP version\n\tif( (strncmp(msg, \"HTTP/1.1\", 8) == 0) || (strncmp(msg, \"HTTP/1.0\", 8) == 0) )\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n```\n\n  * **Purpose**: This simple function validates if the provided string represents a supported HTTP version (either \"HTTP/1.1\" or \"HTTP/1.0\").\n  * **Parameters**:\n      * `char* msg`: A **pointer** to the string containing the HTTP version extracted from the client's request.\n  * **Pointers and Variables**:\n      * `strncmp(msg, \"HTTP/1.1\", 8)`: Compares the first 8 characters of the string pointed to by `msg` with \"HTTP/1.1\". `strncmp` is used for safe comparison of fixed lengths, preventing buffer overflows if `msg` is not null-terminated or shorter than expected.\n      * `strncmp(msg, \"HTTP/1.0\", 8)`: Similar comparison for \"HTTP/1.0\".\n\n-----\n\n### `connectRemoteServer(char* host_addr, int port_num)`\n\n```c\nint connectRemoteServer(char* host_addr, int port_num)\n{\n\t// Creating Socket for remote server ---------------------------\n\tint remoteSocket = socket(AF_INET, SOCK_STREAM, 0);\n\n\tif( remoteSocket < 0)\n\t{\n\t\tprintf(\"Error in Creating Socket.\\n\");\n\t\treturn -1;\n\t}\n\t\n\t// Get host by the name or ip address provided\n\tstruct hostent *host = gethostbyname(host_addr);\t\n\tif(host == NULL)\n\t{\n\t\tfprintf(stderr, \"No such host exists.\\n\");\t\n\t\treturn -1;\n\t}\n\n\t// inserts ip address and port number of host in struct `server_addr`\n\tstruct sockaddr_in server_addr;\n\n\tbzero((char*)&server_addr, sizeof(server_addr));\n\tserver_addr.sin_family = AF_INET;\n\tserver_addr.sin_port = htons(port_num);\n\n\tbcopy((char *)host->h_addr,(char *)&server_addr.sin_addr.s_addr,host->h_length);\n\n\t// Connect to Remote server ----------------------------------------------------\n\tif( connect(remoteSocket, (struct sockaddr*)&server_addr, (socklen_t)sizeof(server_addr)) < 0 )\n\t{\n\t\tfprintf(stderr, \"Error in connecting !\\n\"); \n\t\treturn -1;\n\t}\n\t// free(host_addr); // This line is problematic if host_addr is not dynamically allocated for this specific function call.\n\treturn remoteSocket;\n}\n```\n\n  * **Purpose**: This function is responsible for creating a new socket and establishing a TCP connection to the actual web server (origin server) specified by the client's request.\n  * **Parameters**:\n      * `char* host_addr`: A **pointer** to a string containing the hostname (e.g., \"[www.google.com](https://www.google.com)\") or IP address of the remote server.\n      * `int port_num`: The port number of the remote server (e.g., 80 for HTTP).\n  * **Pointers and Variables**:\n      * `int remoteSocket`: This integer will hold the **socket descriptor** for the connection to the remote server.\n      * `struct hostent *host`: This is a **pointer** to a `struct hostent`. The `gethostbyname()` function takes a hostname (a `char*`) and returns a pointer to this structure, which contains information like the official name of the host, its aliases, and a list of IP addresses.\n      * `struct sockaddr_in server_addr`: This structure holds the remote server's IP address and port number in a format suitable for socket functions.\n      * `bzero((char*)&server_addr, sizeof(server_addr))`: Initializes the `server_addr` structure to all zeros. `(char*)&server_addr` casts the **address** of `server_addr` to a `char*` so `bzero` can operate on its raw bytes.\n      * `server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port_num);`: Sets the address family to IPv4 and converts the `port_num` to network byte order.\n      * `bcopy((char *)host->h_addr,(char *)&server_addr.sin_addr.s_addr,host->h_length)`: Copies the IP address from the `host` structure (obtained via `gethostbyname()`) into `server_addr.sin_addr.s_addr`.\n          * `(char *)host->h_addr`: This is a **pointer** to the first IP address in the list provided by `gethostbyname()`.\n          * `(char *)&server_addr.sin_addr.s_addr`: This is the **address** of the `s_addr` field within `server_addr.sin_addr`, where the IP address will be stored.\n          * `host->h_length`: The length of the address (e.g., 4 bytes for IPv4).\n      * `connect(remoteSocket, (struct sockaddr*)&server_addr, (socklen_t)sizeof(server_addr))`: Attempts to establish a connection using the `remoteSocket` to the `server_addr`. `(struct sockaddr*)&server_addr` is a **pointer** cast to the generic `sockaddr` type.\n\n-----\n\n### `handle_request(int clientSocket, ParsedRequest *request, char *tempReq)`\n\n```c\nint handle_request(int clientSocket, ParsedRequest *request, char *tempReq)\n{\n\tchar *buf = (char*)malloc(sizeof(char)*MAX_BYTES);\n\tstrcpy(buf, \"GET \");\n\tstrcat(buf, request->path);\n\tstrcat(buf, \" \");\n\tstrcat(buf, request->version);\n\tstrcat(buf, \"\\r\\n\");\n\n\tsize_t len = strlen(buf);\n\n\tif (ParsedHeader_set(request, \"Connection\", \"close\") < 0){\n\t\tprintf(\"set header key not work\\n\");\n\t}\n\n\tif(ParsedHeader_get(request, \"Host\") == NULL)\n\t{\n\t\tif(ParsedHeader_set(request, \"Host\", request->host) < 0){\n\t\t\tprintf(\"Set \\\"Host\\\" header key not working\\n\");\n\t\t}\n\t}\n\n\tif (ParsedRequest_unparse_headers(request, buf + len, (size_t)MAX_BYTES - len) < 0) {\n\t\tprintf(\"unparse failed\\n\");\n\t\t//return -1;\t\t\t\t// If this happens Still try to send request without header\n\t}\n\n\tint server_port = 80;\t\t\t\t// Default Remote Server Port\n\tif(request->port != NULL)\n\t\tserver_port = atoi(request->port);\n\n\tint remoteSocketID = connectRemoteServer(request->host, server_port);\n\n\tif(remoteSocketID < 0)\n\t\treturn -1;\n\n\tint bytes_send = send(remoteSocketID, buf, strlen(buf), 0);\n\n\tbzero(buf, MAX_BYTES);\n\n\tbytes_send = recv(remoteSocketID, buf, MAX_BYTES-1, 0);\n\tchar *temp_buffer = (char*)malloc(sizeof(char)*MAX_BYTES); //temp buffer\n\tint temp_buffer_size = MAX_BYTES;\n\tint temp_buffer_index = 0;\n\n\twhile(bytes_send > 0)\n\t{\n\t\tbytes_send = send(clientSocket, buf, bytes_send, 0);\n\t\t\n\t\tfor(int i=0;i<bytes_send;i++){\n\t\t\tif(temp_buffer_index < temp_buffer_size){\n\t\t\t\ttemp_buffer[temp_buffer_index] = buf[i];\n\t\t\t\ttemp_buffer_index++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttemp_buffer_size += MAX_BYTES;\n\t\t\t\ttemp_buffer = (char*)realloc(temp_buffer, temp_buffer_size*sizeof(char)); // Reallocating Memory\n\t\t\t\ttemp_buffer[temp_buffer_index] = buf[i];\n\t\t\t\ttemp_buffer_index++;\n\t\t\t}\n\t\t}\n\t\tbzero(buf, MAX_BYTES);\n\t\tbytes_send = recv(remoteSocketID, buf, MAX_BYTES-1, 0);\n\t}\n\n\ttemp_buffer[temp_buffer_index] = '\\0';\n\tadd_cache_element(temp_buffer,temp_buffer_index,tempReq);\n\n\tfree(temp_buffer);\n\tfree(buf);\n\tclose(remoteSocketID);\n\treturn 1;\n}\n```\n\n  * **Purpose**: This function takes a parsed client request, modifies it for the origin server, sends it, receives the response, and then forwards the response to the client while also adding it to the cache.\n  * **Parameters**:\n      * `int clientSocket`: The **socket descriptor** for the client connection.\n      * `ParsedRequest *request`: A **pointer** to the `ParsedRequest` structure, which holds the parsed components of the client's HTTP request.\n      * `char *tempReq`: A **pointer** to the original, raw HTTP request string from the client. This will be used as the key for caching the response.\n  * **Pointers and Variables**:\n      * `char *buf = (char*)malloc(sizeof(char)*MAX_BYTES)`: Dynamically allocates a buffer to construct the request to the remote server and later to receive the response from it. `buf` is a **pointer** to this allocated memory.\n      * `strcpy(buf, \"GET \"); strcat(buf, request->path); ...`: This sequence constructs the HTTP request line (e.g., \"GET /some/path HTTP/1.1\") using strings pointed to by members of the `request` structure (`request->path`, `request->version`).\n      * `ParsedHeader_set(request, \"Connection\", \"close\")`: This function from `proxy_parse.h` sets or adds an HTTP header. It takes the `ParsedRequest` **pointer**, and **pointers** to the key (\"Connection\") and value (\"close\") strings. This is often done to ensure the connection with the origin server closes after the response, simplifying proxy logic.\n      * `ParsedHeader_get(request, \"Host\")`: This function from `proxy_parse.h` retrieves a header. It returns a **pointer** to a `ParsedHeader` structure if the \"Host\" header is found, otherwise `NULL`. This check ensures that the \"Host\" header is present, which is mandatory for HTTP/1.1 requests.\n      * `ParsedRequest_unparse_headers(request, buf + len, (size_t)MAX_BYTES - len)`: This function from `proxy_parse.h` takes the parsed headers from the `request` structure and converts them back into a raw string format, appending them to `buf` after the request line. `buf + len` is a **pointer arithmetic** expression; it moves the **pointer** `buf` forward by `len` bytes, indicating where the headers should start.\n      * `int remoteSocketID = connectRemoteServer(request->host, server_port)`: Calls the `connectRemoteServer` function to establish a connection to the origin web server. `request->host` is a **pointer** to the hostname string.\n      * `send(remoteSocketID, buf, strlen(buf), 0)`: Sends the complete HTTP request (request line + headers) to the `remoteSocketID`.\n      * `char *temp_buffer = (char*)malloc(sizeof(char)*MAX_BYTES)`: Dynamically allocates a temporary buffer to accumulate the full response received from the remote server.\n      * `temp_buffer = (char*)realloc(temp_buffer, temp_buffer_size*sizeof(char))`: If the incoming response is larger than the current `temp_buffer_size`, `realloc` is used to expand the allocated memory for `temp_buffer`. If `realloc` is successful, `temp_buffer` might point to a new memory location.\n      * `add_cache_element(temp_buffer, temp_buffer_index, tempReq)`: Calls the cache function to add the received response (`temp_buffer` and its length `temp_buffer_index`) with its corresponding request URL (`tempReq`) to the cache.\n      * `free(temp_buffer); free(buf);`: Frees the dynamically allocated memory pointed to by `temp_buffer` and `buf` to prevent memory leaks.\n      * `close(remoteSocketID)`: Closes the socket connection to the remote server.\n\n-----\n\n### Cache Management Functions\n\n#### `find(char* url)`\n\n```c\ncache_element* find(char* url){\n\n// Checks for url in the cache if found returns pointer to the respective cache element or else returns NULL\n    cache_element* site=NULL;\n\t//sem_wait(&cache_lock);\n    int temp_lock_val = pthread_mutex_lock(&lock);\n\tprintf(\"Remove Cache Lock Acquired %d\\n\",temp_lock_val); \n    if(head!=NULL){\n        site = head;\n        while (site!=NULL)\n        {\n            if(!strcmp(site->url,url)){\n\t\t\t\tprintf(\"LRU Time Track Before : %ld\", site->lru_time_track);\n                printf(\"\\nurl found\\n\");\n\t\t\t\t// Updating the time_track\n\t\t\t\tsite->lru_time_track = time(NULL);\n\t\t\t\tprintf(\"LRU Time Track After : %ld\", site->lru_time_track);\n\t\t\t\tbreak;\n            }\n            site=site->next;\n        }       \n    }\n\telse {\n    printf(\"\\nurl not found\\n\");\n\t}\n\t//sem_post(&cache_lock);\n    temp_lock_val = pthread_mutex_unlock(&lock);\n\tprintf(\"Remove Cache Lock Unlocked %d\\n\",temp_lock_val); \n    return site;\n}\n```\n\n  * **Purpose**: Searches for a `cache_element` in the cache (a linked list) using the provided `url` as the key. If found, it updates the `lru_time_track` for that element to reflect its recent use, and returns a pointer to it.\n  * **Parameters**:\n      * `char* url`: A **pointer** to the URL string to search for in the cache.\n  * **Pointers and Variables**:\n      * `cache_element* site=NULL`: A **pointer** of type `cache_element*` used to traverse the cache linked list. It's initialized to `NULL`.\n      * `pthread_mutex_lock(&lock)`: Acquires the **mutex lock**. This is critical because `head` and the cache linked list (`site->next`, `site->lru_time_track`) are shared resources accessed by multiple threads. The lock ensures that only one thread can access or modify the cache at a time, preventing race conditions and data corruption.\n      * `if(head!=NULL)`: Checks if the cache is empty. `head` is a **global pointer** to the first element of the cache linked list.\n      * `site = head`: Starts `site` at the beginning of the linked list.\n      * `while (site!=NULL)`: Loops through each element in the linked list.\n      * `if(!strcmp(site->url,url))`: Compares the `url` stored in the current `cache_element` (`site->url`, a **pointer** to a string) with the input `url` (**pointer** to a string). If they are identical (meaning the URL is found), `strcmp` returns `0`.\n      * `site->lru_time_track = time(NULL)`: If the element is found, its `lru_time_track` is updated to the current time using `time(NULL)`. This marks it as recently used, which is important for the LRU eviction policy. `site->lru_time_track` accesses the `lru_time_track` member of the `cache_element` pointed to by `site`.\n      * `site=site->next`: Moves the `site` **pointer** to the next `cache_element` in the linked list. `site->next` accesses the `next` member (a **pointer** to the next element) of the `cache_element` pointed to by `site`.\n      * `pthread_mutex_unlock(&lock)`: Releases the **mutex lock**, allowing other threads to access the cache.\n\n#### `remove_cache_element()`\n\n```c\nvoid remove_cache_element(){\n    // If cache is not empty searches for the node which has the least lru_time_track and deletes it\n    cache_element * p ;  \t// Cache_element Pointer (Prev. Pointer)\n\tcache_element * q ;\t\t// Cache_element Pointer (Next Pointer)\n\tcache_element * temp;\t// Cache element to remove\n    //sem_wait(&cache_lock);\n    int temp_lock_val = pthread_mutex_lock(&lock);\n\tprintf(\"Remove Cache Lock Acquired %d\\n\",temp_lock_val); \n\tif( head != NULL) { // Cache != empty\n\t\tfor (q = head, p = head, temp =head ; q -> next != NULL; \n\t\t\tq = q -> next) { // Iterate through entire cache and search for oldest time track\n\t\t\tif(( (q -> next) -> lru_time_track) < (temp -> lru_time_track)) {\n\t\t\t\ttemp = q -> next;\n\t\t\t\tp = q;\n\t\t\t}\n\t\t}\n\t\tif(temp == head) { \n\t\t\thead = head -> next; /*Handle the base case*/\n\t\t} else {\n\t\t\tp->next = temp->next;\t\n\t\t}\n\t\tcache_size = cache_size - (temp -> len) - sizeof(cache_element) - \n\t\tstrlen(temp -> url) - 1;     //updating the cache size\n\t\tfree(temp->data);     \t\t\n\t\tfree(temp->url); // Free the removed element \n\t\tfree(temp);\n\t} \n\t//sem_post(&cache_lock);\n    temp_lock_val = pthread_mutex_unlock(&lock);\n\tprintf(\"Remove Cache Lock Unlocked %d\\n\",temp_lock_val); \n}\n```\n\n  * **Purpose**: Implements the LRU (Least Recently Used) cache eviction policy. It finds the `cache_element` that was accessed the longest time ago and removes it from the cache to free up space.\n  * **Parameters**: None (operates on the global `head` and `cache_size`).\n  * **Pointers and Variables**:\n      * `pthread_mutex_lock(&lock)`: Acquires the mutex lock before modifying the cache.\n      * `cache_element * p`, `cache_element * q`, `cache_element * temp`: These are **pointers** used to traverse the linked list and keep track of elements.\n          * `p`: A \"previous\" pointer, always pointing to the element *before* `temp`.\n          * `q`: A \"current\" pointer, iterating through the list to find the element to remove.\n          * `temp`: A \"temporary\" pointer, always pointing to the element currently identified as the least recently used.\n      * `if(head != NULL)`: Checks if the cache is not empty.\n      * `for (q = head, p = head, temp =head ; q -> next != NULL; q = q -> next)`: This loop iterates through the linked list to find the element with the smallest `lru_time_track`.\n          * `q -> next`: Accesses the `next` pointer of the `cache_element` pointed to by `q`.\n          * `q -> next -> lru_time_track`: Accesses the `lru_time_track` of the element pointed to by `q->next`.\n          * `temp -> lru_time_track`: Accesses the `lru_time_track` of the element pointed to by `temp`.\n      * `if(temp == head)`: If the element to be removed (`temp`) is the `head` of the list, then `head` is simply updated to point to the next element.\n      * `else { p->next = temp->next; }`: If `temp` is not the head, `p->next` (the `next` pointer of the element *before* `temp`) is made to point to `temp->next` (the element *after* `temp`), effectively unlinking `temp` from the list.\n      * `cache_size = cache_size - ...`: Decrements the global `cache_size` by the size of the removed element (its `data` length, the size of the `cache_element` structure itself, and the length of its `url`).\n      * `free(temp->data); free(temp->url); free(temp);`: Frees the dynamically allocated memory for the actual data (`temp->data`), the URL string (`temp->url`), and the `cache_element` structure itself (`temp`). This is crucial for preventing memory leaks.\n      * `pthread_mutex_unlock(&lock)`: Releases the mutex lock.\n\n#### `add_cache_element(char* data,int size,char* url)`\n\n```c\nint add_cache_element(char* data,int size,char* url){\n    // Adds element to the cache\n\t// sem_wait(&cache_lock);\n    int temp_lock_val = pthread_mutex_lock(&lock);\n\tprintf(\"Add Cache Lock Acquired %d\\n\", temp_lock_val);\n    int element_size=size+1+strlen(url)+sizeof(cache_element); // Size of the new element which will be added to the cache\n    if(element_size>MAX_ELEMENT_SIZE){\n\t\t//sem_post(&cache_lock);\n        // If element size is greater than MAX_ELEMENT_SIZE we don't add the element to the cache\n        temp_lock_val = pthread_mutex_unlock(&lock);\n\t\tprintf(\"Add Cache Lock Unlocked %d\\n\", temp_lock_val);\n\t\t// free(data); // These free() calls are potentially problematic depending on how 'data' and 'url' were allocated prior to this function call.\n\t\t// printf(\"--\\n\");\n\t\t// free(url);\n        return 0;\n    }\n    else\n    {   while(cache_size+element_size>MAX_SIZE){\n            // We keep removing elements from cache until we get enough space to add the element\n            remove_cache_element();\n        }\n        cache_element* element = (cache_element*) malloc(sizeof(cache_element)); // Allocating memory for the new cache element\n        element->data= (char*)malloc(size+1); // Allocating memory for the response to be stored in the cache element\n\t\tstrcpy(element->data,data); \n        element -> url = (char*)malloc(1+( strlen( url )*sizeof(char)  )); // Allocating memory for the request to be stored in the cache element (as a key)\n\t\tstrcpy( element -> url, url );\n\t\telement->lru_time_track=time(NULL);    // Updating the time_track\n        element->next=head; \n        element->len=size;\n        head=element;\n        cache_size+=element_size;\n        temp_lock_val = pthread_mutex_unlock(&lock);\n\t\tprintf(\"Add Cache Lock Unlocked %d\\n\", temp_lock_val);\n\t\t//sem_post(&cache_lock);\n\t\t// free(data); // Again, these free() calls might be incorrect.\n\t\t// printf(\"--\\n\");\n\t\t// free(url);\n        return 1;\n    }\n    return 0;\n}\n```\n\n  * **Purpose**: Adds a new `cache_element` (HTTP response data and its corresponding URL) to the cache. It ensures that the cache doesn't exceed its `MAX_SIZE` by evicting older elements if necessary, and it also checks if the new element itself is too large to be cached.\n  * **Parameters**:\n      * `char* data`: A **pointer** to the HTTP response data (the content to be cached).\n      * `int size`: The length of the `data` in bytes.\n      * `char* url`: A **pointer** to the URL string (the key for the cache element).\n  * **Pointers and Variables**:\n      * `pthread_mutex_lock(&lock)`: Acquires the mutex lock before modifying the cache.\n      * `int element_size = size + 1 + strlen(url) + sizeof(cache_element)`: Calculates the total size that the new `cache_element` will occupy in memory, including the data, URL string, and the `cache_element` structure itself. `size + 1` accounts for the null terminator for `data`. `strlen(url) + 1` accounts for the null terminator for `url`.\n      * `if(element_size > MAX_ELEMENT_SIZE)`: Checks if the new element is individually too large to be cached. If so, it returns `0` (failure) without adding it.\n      * `while(cache_size + element_size > MAX_SIZE)`: This loop implements cache eviction. If adding the new element would make the cache exceed `MAX_SIZE`, it repeatedly calls `remove_cache_element()` until enough space is freed.\n      * `cache_element* element = (cache_element*) malloc(sizeof(cache_element))`: Dynamically allocates memory for the new `cache_element` structure itself. `element` is a **pointer** to this new structure.\n      * `element->data = (char*)malloc(size+1)`: Dynamically allocates memory for the actual response data (`data`) within the new `cache_element`. `element->data` is a **pointer** to this memory. `strcpy(element->data, data)` copies the content.\n      * `element->url = (char*)malloc(1 + (strlen(url) * sizeof(char)))`: Dynamically allocates memory for the URL string within the new `cache_element`. `element->url` is a **pointer** to this memory. `strcpy(element->url, url)` copies the URL.\n      * `element->lru_time_track = time(NULL)`: Sets the `lru_time_track` of the new element to the current time, marking it as recently added/used.\n      * `element->next = head`: This adds the new element to the *front* of the linked list (a common way to implement a simple LRU where the head is the most recently added). `element->next` points to what was previously the `head`.\n      * `head = element`: Updates the global `head` **pointer** to point to the newly added element, making it the new beginning of the list.\n      * `cache_size += element_size`: Updates the global `cache_size`.\n      * `pthread_mutex_unlock(&lock)`: Releases the mutex lock.\n\n-----\n\n## II. Proxy Parse Library - `proxy_parse.c`\n\nThis library provides functions to parse HTTP requests into a structured format and unparse them back into raw strings.\n\n### Structures\n\n```c\n// (Implicitly defined in proxy_parse.h, but important to understand)\nstruct ParsedHeader {\n    char *key;      // Pointer to the header key (e.g., \"Host\")\n    char *value;    // Pointer to the header value (e.g., \"www.example.com\")\n    size_t keylen;  // Length of the key string\n    size_t valuelen; // Length of the value string\n};\n\nstruct ParsedRequest {\n    char *buf;      // Pointer to the original raw request line (e.g., \"GET http://www.example.com/ HTTP/1.1\")\n    size_t buflen;  // Length of the raw request line\n    char *method;   // Pointer to the HTTP method (e.g., \"GET\")\n    char *protocol; // Pointer to the protocol (e.g., \"http\")\n    char *host;     // Pointer to the host (e.g., \"www.example.com\")\n    char *port;     // Pointer to the port (e.g., \"80\")\n    char *path;     // Pointer to the path (e.g., \"/index.html\")\n    char *version;  // Pointer to the HTTP version (e.g., \"HTTP/1.1\")\n    struct ParsedHeader *headers; // Pointer to an array of ParsedHeader structures\n    size_t headerslen;   // Allocated capacity for headers array\n    size_t headersused;  // Number of headers actually used\n};\n```\n\n  * **`ParsedHeader`**: Represents a single HTTP header, storing its key and value as dynamically allocated strings.\n      * `char *key`, `char *value`: **Pointers** to dynamically allocated character arrays that store the header's key and value strings.\n  * **`ParsedRequest`**: Represents the entire parsed HTTP request. It holds pointers to various components of the request line and an array of `ParsedHeader` structures for the request headers.\n      * `char *buf`: A **pointer** to a dynamically allocated string holding the *request line* from the original HTTP request (e.g., \"GET [http://www.example.com/](http://www.example.com/) HTTP/1.1\").\n      * `char *method`, `char *protocol`, `char *host`, `char *port`, `char *path`, `char *version`: These are all **pointers** to character arrays (strings). During parsing, these pointers will be made to point to specific parts within the `buf` (or newly allocated memory for `path`), essentially \"slicing\" the request line into its components.\n      * `struct ParsedHeader *headers`: A **pointer** to an array of `ParsedHeader` structures. This array is dynamically resized as needed.\n\n-----\n\n### `debug(const char * format, ...)`\n\n```c\nvoid debug(const char * format, ...) {\n  va_list args;\n  if (DEBUG) {\n   va_start(args, format);\n   vfprintf(stderr, format, args);\n   va_end(args);\n  }\n}\n```\n\n  * **Purpose**: A debugging utility function that prints formatted output to `stderr` if the `DEBUG` macro is defined (usually `DEBUG` is set to `1`).\n  * **Parameters**:\n      * `const char * format`: A **pointer** to a format string, similar to `printf`.\n      * `...`: Ellipsis, indicating a variable number of arguments (like `printf`).\n  * **Pointers and Variables**:\n      * `va_list args`: A special type from `<stdarg.h>` used to handle variable argument lists.\n      * `va_start(args, format)`: Initializes `args` to point to the first optional argument.\n      * `vfprintf(stderr, format, args)`: Prints the formatted output to `stderr` using the variable argument list.\n      * `va_end(args)`: Cleans up the `va_list`.\n\n-----\n\n### `ParsedHeader_set(struct ParsedRequest *pr, const char * key, const char * value)`\n\n```c\nint ParsedHeader_set(struct ParsedRequest *pr,\n      const char * key, const char * value)\n{\n  struct ParsedHeader *ph;\n  ParsedHeader_remove (pr, key); // Remove existing header with same key\n\n  if (pr->headerslen <= pr->headersused+1) {\n   pr->headerslen = pr->headerslen * 2;\n   pr->headers =\n     (struct ParsedHeader *)realloc(pr->headers,\n    pr->headerslen * sizeof(struct ParsedHeader));\n   if (!pr->headers)\n     return -1;\n  }\n\n  ph = pr->headers + pr->headersused;\n  pr->headersused += 1;\n  \n  ph->key = (char *)malloc(strlen(key)+1);\n  memcpy(ph->key, key, strlen(key));\n  ph->key[strlen(key)] = '\\0';\n\n  ph->value = (char *)malloc(strlen(value)+1);\n  memcpy(ph->value, value, strlen(value));\n  ph->value[strlen(value)] = '\\0';\n\n  ph->keylen = strlen(key)+1;\n  ph->valuelen = strlen(value)+1;\n  return 0;\n}\n```\n\n  * **Purpose**: Adds or updates an HTTP header (key-value pair) within a `ParsedRequest` structure. If a header with the same key already exists, it's removed first.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure where the header will be set.\n      * `const char * key`: A **pointer** to the string representing the header key (e.g., \"Host\").\n      * `const char * value`: A **pointer** to the string representing the header value (e.g., \"[www.example.com](https://www.example.com)\").\n  * **Pointers and Variables**:\n      * `struct ParsedHeader *ph`: A **pointer** used to refer to the new `ParsedHeader` element being added to the array.\n      * `ParsedHeader_remove(pr, key)`: Calls another function (explained below) to remove any existing header with the same `key`.\n      * `if (pr->headerslen <= pr->headersused+1)`: Checks if the allocated array for headers (`pr->headers`) needs to be resized.\n          * `pr->headerslen`: The currently allocated capacity of the `headers` array.\n          * `pr->headersused`: The number of header slots currently occupied.\n      * `pr->headers = (struct ParsedHeader *)realloc(pr->headers, pr->headerslen * sizeof(struct ParsedHeader))`: If resizing is needed, `realloc` attempts to resize the `headers` array (pointed to by `pr->headers`). If successful, `pr->headers` might point to a new memory location.\n      * `ph = pr->headers + pr->headersused`: Uses **pointer arithmetic** to get a **pointer** to the next available slot in the `headers` array where the new header will be stored.\n      * `pr->headersused += 1`: Increments the count of used header slots.\n      * `ph->key = (char *)malloc(strlen(key)+1); memcpy(ph->key, key, strlen(key)); ph->key[strlen(key)] = '\\0';`: Dynamically allocates memory for the header `key` string, copies the content from the input `key` (pointed to by `key`), and null-terminates it. `ph->key` becomes a **pointer** to this new memory.\n      * `ph->value = (char *)malloc(strlen(value)+1); memcpy(ph->value, value, strlen(value)); ph->value[strlen(value)] = '\\0';`: Similar dynamic allocation and copying for the header `value`. `ph->value` becomes a **pointer** to this new memory.\n      * `ph->keylen`, `ph->valuelen`: Store the lengths of the `key` and `value` strings.\n\n-----\n\n### `ParsedHeader_get(struct ParsedRequest *pr, const char * key)`\n\n```c\nstruct ParsedHeader* ParsedHeader_get(struct ParsedRequest *pr,\n           const char * key)\n{\n  size_t i = 0;\n  struct ParsedHeader * tmp;\n  while(pr->headersused > i)\n  {\n   tmp = pr->headers + i;\n   if(tmp->key && key && strcmp(tmp->key, key) == 0)\n   {\n     return tmp;\n   }\n   i++;\n  }\n  return NULL;\n}\n```\n\n  * **Purpose**: Searches for a specific header by its `key` within a `ParsedRequest` structure's headers array.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure to search within.\n      * `const char * key`: A **pointer** to the header key string to look for.\n  * **Pointers and Variables**:\n      * `struct ParsedHeader * tmp`: A **pointer** to a `ParsedHeader` structure, used to iterate through the `headers` array.\n      * `while(pr->headersused > i)`: Loops through each header currently stored in the `pr->headers` array.\n      * `tmp = pr->headers + i`: Uses **pointer arithmetic** to get a **pointer** to the `i`-th `ParsedHeader` element in the `headers` array.\n      * `strcmp(tmp->key, key) == 0`: Compares the `key` string stored in the current header (`tmp->key`, a **pointer**) with the input `key` (a **pointer**).\n\n-----\n\n### `ParsedHeader_remove(struct ParsedRequest *pr, const char *key)`\n\n```c\nint ParsedHeader_remove(struct ParsedRequest *pr, const char *key)\n{\n  struct ParsedHeader *tmp;\n  tmp = ParsedHeader_get(pr, key);\n  if(tmp == NULL)\n   return -1;\n\n  free(tmp->key);\n  free(tmp->value);\n  tmp->key = NULL;\n  return 0;\n}\n```\n\n  * **Purpose**: Removes a specific header by its `key` from a `ParsedRequest` structure. It frees the memory associated with that header's key and value strings.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure from which to remove the header.\n      * `const char *key`: A **pointer** to the key string of the header to remove.\n  * **Pointers and Variables**:\n      * `struct ParsedHeader *tmp`: A **pointer** to the `ParsedHeader` structure that `ParsedHeader_get` finds.\n      * `free(tmp->key); free(tmp->value);`: Frees the dynamically allocated memory for the header's key and value strings, which `tmp->key` and `tmp->value` point to.\n      * `tmp->key = NULL;`: Sets the `key` pointer to `NULL` to indicate that this header slot is now \"empty\" or invalid, though it doesn't shift the array elements.\n\n-----\n\n### `ParsedHeader_create(struct ParsedRequest *pr)`\n\n```c\nvoid ParsedHeader_create(struct ParsedRequest *pr)\n{\n  pr->headers =\n  (struct ParsedHeader *)malloc(sizeof(struct ParsedHeader)*DEFAULT_NHDRS);\n  pr->headerslen = DEFAULT_NHDRS;\n  pr->headersused = 0;\n}\n```\n\n  * **Purpose**: Initializes the `headers` array within a `ParsedRequest` structure.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure to initialize.\n  * **Pointers and Variables**:\n      * `pr->headers = (struct ParsedHeader *)malloc(...)`: Dynamically allocates an initial array of `DEFAULT_NHDRS` `ParsedHeader` structures. `pr->headers` is then made to **point** to the beginning of this allocated block.\n\n-----\n\n### `ParsedHeader_lineLen(struct ParsedHeader * ph)`\n\n```c\nsize_t ParsedHeader_lineLen(struct ParsedHeader * ph)\n{\n  if(ph->key != NULL)\n  {\n   return strlen(ph->key)+strlen(ph->value)+4;\n  }\n  return 0;\n}\n```\n\n  * **Purpose**: Calculates the length of a single header line when unparsed into a string (e.g., \"Key: Value\\\\r\\\\n\").\n  * **Parameters**:\n      * `struct ParsedHeader * ph`: A **pointer** to the `ParsedHeader` structure.\n  * **Pointers and Variables**:\n      * `strlen(ph->key)`: Gets the length of the string pointed to by `ph->key`.\n      * `strlen(ph->value)`: Gets the length of the string pointed to by `ph->value`.\n      * `+4`: Accounts for the \": \" (2 bytes) and \"\\\\r\\\\n\" (2 bytes).\n\n-----\n\n### `ParsedHeader_headersLen(struct ParsedRequest *pr)`\n\n```c\nsize_t ParsedHeader_headersLen(struct ParsedRequest *pr)\n{\n  if (!pr || !pr->buf)\n   return 0;\n\n  size_t i = 0;\n  int len = 0;\n  while(pr->headersused > i)\n  {\n   len += ParsedHeader_lineLen(pr->headers + i);\n   i++;\n  }\n  len += 2; // For the final \"\\r\\n\" after all headers\n  return len;\n}\n```\n\n  * **Purpose**: Calculates the total length of all headers in a `ParsedRequest` when they are unparsed into a single string, including the final blank line (`\\r\\n`).\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure.\n  * **Pointers and Variables**:\n      * `pr->headers + i`: Uses **pointer arithmetic** to get a **pointer** to the `i`-th `ParsedHeader` in the array.\n      * `ParsedHeader_lineLen(...)`: Calls the previously explained function to get the length of each individual header line.\n\n-----\n\n### `ParsedHeader_printHeaders(struct ParsedRequest * pr, char * buf, size_t len)`\n\n```c\nint ParsedHeader_printHeaders(struct ParsedRequest * pr, char * buf,\n         size_t len)\n{\n  char * current = buf;\n  struct ParsedHeader * ph;\n  size_t i = 0;\n\n  if(len < ParsedHeader_headersLen(pr))\n  {\n   debug(\"buffer for printing headers too small\\n\");\n   return -1;\n  }\n\n  while(pr->headersused > i)\n  {\n   ph = pr->headers+i;\n   if (ph->key) {\n     memcpy(current, ph->key, strlen(ph->key));\n     memcpy(current+strlen(ph->key), \": \", 2);\n     memcpy(current+strlen(ph->key) +2 , ph->value,\n       strlen(ph->value));\n     memcpy(current+strlen(ph->key) +2+strlen(ph->value) ,\n       \"\\r\\n\", 2);\n     current += strlen(ph->key)+strlen(ph->value)+4;\n   }\n   i++;\n  }\n  memcpy(current, \"\\r\\n\",2);\n  return 0;\n}\n```\n\n  * **Purpose**: Writes the parsed HTTP headers from a `ParsedRequest` structure into a provided character buffer, formatting them as `Key: Value\\r\\n`.\n  * **Parameters**:\n      * `struct ParsedRequest * pr`: A **pointer** to the `ParsedRequest` structure containing the headers.\n      * `char * buf`: A **pointer** to the buffer where the headers will be written.\n      * `size_t len`: The available length of the `buf`.\n  * **Pointers and Variables**:\n      * `char * current = buf`: A **pointer** that tracks the current position in the `buf` where data should be written. It starts at the beginning of `buf` and is incremented after each part of the header is copied.\n      * `struct ParsedHeader * ph`: A **pointer** to the current `ParsedHeader` being processed.\n      * `ph = pr->headers + i`: Uses **pointer arithmetic** to get the address of the `i`-th header in the `headers` array.\n      * `memcpy(current, ph->key, strlen(ph->key))`: Copies the header key (pointed to by `ph->key`) into the `current` position of the `buf`.\n      * `current += strlen(ph->key)`: Moves `current` **pointer** forward by the length of the copied key. Similar pointer arithmetic is used for copying the \": \", value, and \"\\\\r\\\\n\".\n\n-----\n\n### `ParsedHeader_destroyOne(struct ParsedHeader * ph)`\n\n```c\nvoid ParsedHeader_destroyOne(struct ParsedHeader * ph)\n{\n  if(ph->key != NULL)\n  {\n   free(ph->key);\n   ph->key = NULL;\n   free(ph->value);\n   ph->value = NULL;\n   ph->keylen = 0;\n   ph->valuelen = 0;\n  }\n}\n```\n\n  * **Purpose**: Frees the dynamically allocated memory for the `key` and `value` strings within a single `ParsedHeader` structure.\n  * **Parameters**:\n      * `struct ParsedHeader * ph`: A **pointer** to the `ParsedHeader` structure to destroy.\n  * **Pointers and Variables**:\n      * `free(ph->key); free(ph->value);`: Frees the memory blocks that `ph->key` and `ph->value` point to.\n      * `ph->key = NULL; ph->value = NULL;`: Sets the pointers to `NULL` after freeing, which is good practice to prevent dangling pointers.\n\n-----\n\n### `ParsedHeader_destroy(struct ParsedRequest * pr)`\n\n```c\nvoid ParsedHeader_destroy(struct ParsedRequest * pr)\n{\n  size_t i = 0;\n  while(pr->headersused > i)\n  {\n   ParsedHeader_destroyOne(pr->headers + i);\n   i++;\n  }\n  pr->headersused = 0;\n\n  free(pr->headers);\n  pr->headerslen = 0;\n}\n```\n\n  * **Purpose**: Frees all dynamically allocated memory associated with the `headers` array within a `ParsedRequest` structure.\n  * **Parameters**:\n      * `struct ParsedRequest * pr`: A **pointer** to the `ParsedRequest` structure whose headers are to be destroyed.\n  * **Pointers and Variables**:\n      * `ParsedHeader_destroyOne(pr->headers + i)`: Calls `ParsedHeader_destroyOne` for each individual header in the `headers` array (accessed using **pointer arithmetic** `pr->headers + i`).\n      * `free(pr->headers)`: Frees the main memory block that holds the array of `ParsedHeader` structures, which `pr->headers` points to.\n\n-----\n\n### `ParsedHeader_parse(struct ParsedRequest * pr, char * line)`\n\n```c\nint ParsedHeader_parse(struct ParsedRequest * pr, char * line)\n{\n  char * key;\n  char * value;\n  char * index1;\n  char * index2;\n\n  index1 = index(line, ':'); // Find the colon separating key and value\n  if(index1 == NULL) { /* ... error ... */ }\n  key = (char *)malloc((index1-line+1)*sizeof(char));\n  memcpy(key, line, index1-line);\n  key[index1-line]='\\0';\n\n  index1 += 2; // Move past \": \"\n  index2 = strstr(index1, \"\\r\\n\"); // Find the end of the header line\n  value = (char *) malloc((index2-index1+1)*sizeof(char));\n  memcpy(value, index1, (index2-index1));\n  value[index2-index1] = '\\0';\n\n  ParsedHeader_set(pr, key, value);\n  free(key);\n  free(value);\n  return 0;\n}\n```\n\n  * **Purpose**: Parses a single raw HTTP header line (e.g., \"Host: [www.example.com](https://www.example.com)\\\\r\\\\n\") into its key and value components, and then adds them to the `ParsedRequest` structure.\n  * **Parameters**:\n      * `struct ParsedRequest * pr`: A **pointer** to the `ParsedRequest` structure to add the parsed header to.\n      * `char * line`: A **pointer** to the raw header line string.\n  * **Pointers and Variables**:\n      * `char * key`, `char * value`: **Pointers** that will temporarily hold the extracted key and value strings.\n      * `char * index1`, `char * index2`: **Pointers** used to mark positions within the `line` string.\n      * `index1 = index(line, ':')`: Finds the first occurrence of `':'` in the `line` string. `index` returns a **pointer** to that character.\n      * `key = (char *)malloc((index1-line+1)*sizeof(char))`: Dynamically allocates memory for the `key` string. `index1-line` calculates the length of the key by finding the difference in memory addresses between `index1` and `line`.\n      * `memcpy(key, line, index1-line); key[index1-line]='\\0';`: Copies the key characters from `line` into the `key` buffer and null-terminates it.\n      * `index1 += 2`: Moves `index1` **pointer** past the `\": \"` characters to the start of the value.\n      * `index2 = strstr(index1, \"\\r\\n\")`: Finds the end of the header line (`\\r\\n`) starting from `index1`. `strstr` returns a **pointer** to the `\\r\\n`.\n      * `value = (char *) malloc((index2-index1+1)*sizeof(char))`: Dynamically allocates memory for the `value` string based on the length between `index1` and `index2`.\n      * `memcpy(value, index1, (index2-index1)); value[index2-index1] = '\\0';`: Copies the value characters and null-terminates them.\n      * `ParsedHeader_set(pr, key, value)`: Calls the function to add this parsed key-value pair to the `ParsedRequest` structure.\n      * `free(key); free(value);`: Frees the temporary memory allocated for `key` and `value` strings.\n\n-----\n\n### `ParsedRequest_destroy(struct ParsedRequest *pr)`\n\n```c\nvoid ParsedRequest_destroy(struct ParsedRequest *pr)\n{\n  if(pr->buf != NULL)\n  {\n   free(pr->buf);\n  }\n  if (pr->path != NULL) {\n   free(pr->path);\n  }\n  if(pr->headerslen > 0)\n  {\n   ParsedHeader_destroy(pr);\n  }\n  free(pr);\n}\n```\n\n  * **Purpose**: Frees all dynamically allocated memory associated with a `ParsedRequest` structure and its internal components.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure to destroy.\n  * **Pointers and Variables**:\n      * `free(pr->buf); free(pr->path);`: Frees the memory blocks pointed to by `pr->buf` (the request line) and `pr->path` (if it was separately allocated).\n      * `ParsedHeader_destroy(pr)`: Calls the function to free all headers within the `ParsedRequest`.\n      * `free(pr)`: Frees the `ParsedRequest` structure itself, which `pr` points to.\n\n-----\n\n### `ParsedRequest_create()`\n\n```c\nstruct ParsedRequest* ParsedRequest_create()\n{\n  struct ParsedRequest *pr;\n  pr = (struct ParsedRequest *)malloc(sizeof(struct ParsedRequest));\n  if (pr != NULL)\n  {\n   ParsedHeader_create(pr);\n   pr->buf = NULL;\n   pr->method = NULL;\n   pr->protocol = NULL;\n   pr->host = NULL;\n   pr->path = NULL;\n   pr->version = NULL;\n   pr->buf = NULL;\n   pr->buflen = 0;\n  }\n  return pr;\n}\n```\n\n  * **Purpose**: Allocates memory for and initializes a new `ParsedRequest` structure.\n  * **Parameters**: None.\n  * **Pointers and Variables**:\n      * `struct ParsedRequest *pr`: A **pointer** that will point to the newly allocated `ParsedRequest` structure.\n      * `pr = (struct ParsedRequest *)malloc(sizeof(struct ParsedRequest))`: Dynamically allocates memory for the `ParsedRequest` structure.\n      * `ParsedHeader_create(pr)`: Initializes the `headers` array within the new `ParsedRequest` structure.\n      * `pr->buf = NULL; pr->method = NULL; ...`: Initializes all other **pointers** within the `ParsedRequest` structure to `NULL` to ensure they start in a defined state.\n\n-----\n\n### `ParsedRequest_unparse(struct ParsedRequest *pr, char *buf, size_t buflen)`\n\n```c\nint ParsedRequest_unparse(struct ParsedRequest *pr, char *buf,\n       size_t buflen)\n{\n  if (!pr || !pr->buf)\n   return -1;\n\n  size_t tmp;\n  if (ParsedRequest_printRequestLine(pr, buf, buflen, &tmp) < 0)\n   return -1;\n  if (ParsedHeader_printHeaders(pr, buf+tmp, buflen-tmp) < 0)\n   return -1;\n  return 0;\n}\n```\n\n  * **Purpose**: Reconstructs the entire raw HTTP request string (request line + headers) from a `ParsedRequest` structure into a provided buffer.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure.\n      * `char *buf`: A **pointer** to the destination buffer.\n      * `size_t buflen`: The maximum size of the destination buffer.\n  * **Pointers and Variables**:\n      * `size_t tmp`: A variable to store the length of the request line printed. `&tmp` passes the **address** of `tmp` so `ParsedRequest_printRequestLine` can modify its value.\n      * `ParsedRequest_printRequestLine(pr, buf, buflen, &tmp)`: Prints the request line into `buf` and updates `tmp` with its length.\n      * `ParsedHeader_printHeaders(pr, buf+tmp, buflen-tmp)`: Prints the headers into `buf` starting *after* the request line. `buf+tmp` is **pointer arithmetic** that moves the pointer to the correct starting position.\n\n-----\n\n### `ParsedRequest_unparse_headers(struct ParsedRequest *pr, char *buf, size_t buflen)`\n\n```c\nint ParsedRequest_unparse_headers(struct ParsedRequest *pr, char *buf,\n         size_t buflen)\n{\n  if (!pr || !pr->buf)\n   return -1;\n\n  if (ParsedHeader_printHeaders(pr, buf, buflen) < 0)\n   return -1;\n  return 0;\n}\n```\n\n  * **Purpose**: Reconstructs only the HTTP headers from a `ParsedRequest` structure into a provided buffer.\n  * **Parameters**: Same as `ParsedRequest_unparse`, but it only deals with headers.\n  * **Pointers and Variables**:\n      * `ParsedHeader_printHeaders(pr, buf, buflen)`: Directly calls `ParsedHeader_printHeaders` to write the headers into `buf`.\n\n-----\n\n### `ParsedRequest_totalLen(struct ParsedRequest *pr)`\n\n```c\nsize_t ParsedRequest_totalLen(struct ParsedRequest *pr)\n{\n  if (!pr || !pr->buf)\n   return 0;\n  return ParsedRequest_requestLineLen(pr)+ParsedHeader_headersLen(pr);\n}\n```\n\n  * **Purpose**: Calculates the total length of the entire HTTP request (request line + headers) if it were unparsed into a single string.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure.\n  * **Pointers and Variables**:\n      * Calls `ParsedRequest_requestLineLen(pr)` and `ParsedHeader_headersLen(pr)` to get the lengths of the respective parts and sums them.\n\n-----\n\n### `ParsedRequest_parse(struct ParsedRequest * parse, const char *buf, int buflen)`\n\n```c\nint\nParsedRequest_parse(struct ParsedRequest * parse, const char *buf,\n      int buflen)\n{\n  char *full_addr;\n  char *saveptr; // For strtok_r\n  char *index;\n  char *currentHeader;\n\n  // ... checks for valid buffer, copies to tmp_buf ...\n\n  index = strstr(tmp_buf, \"\\r\\n\"); // Find end of request line\n  // ... copy request line to parse->buf ...\n\n  /* Parse request line */\n  parse->method = strtok_r(parse->buf, \" \", &saveptr);\n  // ... error checks for method ...\n\n  full_addr = strtok_r(NULL, \" \", &saveptr);\n  // ... error checks for full_addr ...\n\n  parse->version = full_addr + strlen(full_addr) + 1; // Pointer arithmetic to get version\n  // ... error checks for version ...\n\n  parse->protocol = strtok_r(full_addr, \"://\", &saveptr);\n  // ... error checks for protocol ...\n\n  parse->host = strtok_r(NULL, \"/\", &saveptr);\n  // ... error checks for host ...\n\n  parse->path = strtok_r(NULL, \" \", &saveptr);\n  // ... handling for path ...\n\n  parse->host = strtok_r(parse->host, \":\", &saveptr); // Separate host and port\n  parse->port = strtok_r(NULL, \"/\", &saveptr);\n\n  // ... error checks for host and port ...\n \n  /* Parse headers */\n  currentHeader = strstr(tmp_buf, \"\\r\\n\")+2; // Start after first \\r\\n\n  while (currentHeader[0] != '\\0' &&\n    !(currentHeader[0] == '\\r' && currentHeader[1] == '\\n')) {\n  \n   if (ParsedHeader_parse(parse, currentHeader)) { /* ... handle error ... */ }\n\n   currentHeader = strstr(currentHeader, \"\\r\\n\"); // Find next header line\n   // ... error checks ...\n   currentHeader += 2;\n  }\n  free(tmp_buf);\n  return ret;\n}\n```\n\n  * **Purpose**: This is the core parsing function. It takes a raw HTTP request buffer and populates a `ParsedRequest` structure with its components (method, URL parts, version, and headers).\n  * **Parameters**:\n      * `struct ParsedRequest * parse`: A **pointer** to the `ParsedRequest` structure to populate.\n      * `const char *buf`: A **pointer** to the raw HTTP request string.\n      * `int buflen`: The length of the raw request buffer.\n  * **Pointers and Variables**:\n      * `char *tmp_buf = (char *)malloc(buflen + 1);`: Creates a mutable, null-terminated copy of the input `buf`. This is important because `strtok_r` modifies the string it operates on. `tmp_buf` is a **pointer** to this copy.\n      * `char *saveptr`: A **pointer** used by `strtok_r` to maintain its internal state, allowing it to be re-entrant (safe for use in multithreaded environments).\n      * `char *index`: A **pointer** used to find substrings like `\\r\\n` within `tmp_buf`.\n      * `char *currentHeader`: A **pointer** that iterates through the header lines in `tmp_buf`.\n      * `parse->method = strtok_r(parse->buf, \" \", &saveptr)`: `strtok_r` is used repeatedly to break down the request line and URL into their individual components. It modifies `parse->buf` in place and returns **pointers** to the start of each token (e.g., \"GET\", \"http\", \"[www.example.com](https://www.example.com)\"). These **pointers** are then assigned to `parse->method`, `parse->protocol`, `parse->host`, `parse->path`, `parse->port`, and `parse->version`.\n          * **Important**: Many of these `parse->` members directly **point** into the `parse->buf` (or `tmp_buf` initially). This means they are *not* separately allocated strings but rather \"views\" into a larger string. `parse->path` is an exception as it may be allocated separately if it's the root path.\n      * `parse->version = full_addr + strlen(full_addr) + 1;`: This is an example of **pointer arithmetic**. `full_addr` points to \"[http://www.example.com/some/path](https://www.google.com/search?q=http://www.example.com/some/path)\". `strlen(full_addr)` gets its length. Adding `strlen(full_addr) + 1` moves the pointer past this part and the space, directly to the \"HTTP/1.1\" string which becomes `parse->version`.\n      * `ParsedHeader_parse(parse, currentHeader)`: This function is called in a loop for each header line found. It parses individual header lines and adds them to the `ParsedRequest` structure.\n      * `free(tmp_buf)`: Frees the temporary copy of the request buffer.\n\n-----\n\n### `ParsedRequest_requestLineLen(struct ParsedRequest *pr)`\n\n```c\nsize_t ParsedRequest_requestLineLen(struct ParsedRequest *pr)\n{\n  if (!pr || !pr->buf)\n   return 0;\n\n  size_t len =\n   strlen(pr->method) + 1 + strlen(pr->protocol) + 3 +\n   strlen(pr->host) + 1 + strlen(pr->version) + 2;\n  if(pr->port != NULL)\n  {\n   len += strlen(pr->port)+1;\n  }\n  /* path is at least a slash */\n  len += strlen(pr->path);\n  return len;\n}\n```\n\n  * **Purpose**: Calculates the length of the HTTP request line if it were unparsed into a string.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure.\n  * **Pointers and Variables**:\n      * It uses `strlen()` on the various **pointers** within the `ParsedRequest` structure (`pr->method`, `pr->protocol`, `pr->host`, `pr->version`, `pr->port`, `pr->path`) to sum up their lengths and add fixed lengths for spaces, \"://\", and \"\\\\r\\\\n\".\n\n-----\n\n### `ParsedRequest_printRequestLine(struct ParsedRequest *pr, char * buf, size_t buflen, size_t *tmp)`\n\n```c\nint ParsedRequest_printRequestLine(struct ParsedRequest *pr,\n         char * buf, size_t buflen,\n         size_t *tmp)\n{\n  char * current = buf;\n\n  if(buflen < ParsedRequest_requestLineLen(pr)) { /* ... error ... */ }\n  memcpy(current, pr->method, strlen(pr->method));\n  current += strlen(pr->method);\n  current[0] = ' ';\n  current += 1;\n\n  // ... similar memcpy and pointer arithmetic for protocol, host, port, path, version ...\n\n  *tmp = current-buf; // Calculate total length written\n  return 0;\n}\n```\n\n  * **Purpose**: Writes the components of the HTTP request line (method, URL parts, version) from a `ParsedRequest` structure into a provided character buffer, formatted as a standard HTTP request line.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure.\n      * `char * buf`: A **pointer** to the destination buffer.\n      * `size_t buflen`: The maximum size of the destination buffer.\n      * `size_t *tmp`: A **pointer** to a `size_t` variable where the total length of the written request line will be stored.\n  * **Pointers and Variables**:\n      * `char * current = buf`: A **pointer** that keeps track of the current writing position within the `buf`.\n      * `memcpy(current, pr->method, strlen(pr->method))`: Copies the string pointed to by `pr->method` into the `current` position of `buf`.\n      * `current += strlen(pr->method)`: Advances the `current` **pointer** by the length of the copied string. This pattern is repeated for all parts of the request line (`pr->protocol`, `pr->host`, `pr->port`, `pr->path`, `pr->version`), along with adding spaces, \"://\", and \"\\\\r\\\\n\".\n      * `*tmp = current-buf;`: After writing all parts of the request line, this line calculates the total number of bytes written. It subtracts the starting **address** of `buf` from the final **address** of `current`. The result is then stored in the `size_t` variable pointed to by `tmp` (using **dereferencing**).\n\n-----\n\nThis detailed explanation covers the core functions, global variables, and the extensive use of pointers in both the main proxy server logic and the `proxy_parse` library. Understanding how pointers are used for memory management (malloc, realloc, free), accessing structure members (`->`), string manipulation (`strcpy`, `strcat`, `strstr`, `strtok_r`), and passing data to threads is fundamental to grasping this C code.",
          "excerpt": "This code sets up a multithreaded proxy server that handles HTTP GET requests and includes a caching mechanism to improve performance. It's designed to accept multiple client connections concurrently ...",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-07-23T10:12:02.000Z"
        }
      ]
    },
    {
      "name": "991-CLANG/ALGS",
      "path": "991-CLANG/ALGS",
      "noteCount": 3,
      "notes": [
        {
          "id": "991-clang-algs-bfs-md",
          "slug": "991-clang/algs/bfs",
          "filepath": "991-CLANG/ALGS/BFS.md",
          "folder": "991-CLANG/ALGS",
          "filename": "BFS.md",
          "frontmatter": {
            "title": "Def:",
            "date": "2025-08-17",
            "tags": [
              "python",
              "do"
            ],
            "category": "991-CLANG/ALGS"
          },
          "content": "## Def:\nBreadth-First Search (BFS) is ==a graph traversal algorithm that explores a graph level by level==\n\n![[Pasted image 20250817174830.png]]\n### ALGORITHM \n```python\nvisited = [False] * GRID_SIZE\ndef BFS(GRID, STARTING):\n\tqueue = [STARTING]\n\twhile(!queue.isEmpty()):\n\t\tNEW_NODE = queue.pop()\n\t\tif not visited:\n\t\t\tvisit(NEW_NODE) #DO SOMETHING\n\t\t\tvisited[NEW_NODE] = TRUE\n\t\t\tfor w in GRID.NEIGHBORS(NEW_NODE):\n\t\t\t\tif !visited(w):\n\t\t\t\t\tqueue.append(w)\n```\n\n### FLOOD FILL\n- **PYTHON**\n```python \nfrom collections import deque\nclass Solution:\n    \n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        start = image[sr][sc]\n        visited = set()\n        queue = deque([(sr, sc)])\n        while(q):\n            row,col = queue.popleft()\n            visited.add(row,col)\n            image[row][col] = color\n            for row,col in neighbours(image,row,col,start):\n                if(row,col) not in visited:\n                    queue.append((row,col))\n        return image\n    def neighbours(image,row,col,start):\n        indices = [(row-1,col),(row+1,col),(row,col-1),(row,col+1)]\n        return [(row,col) for row,col in indices if isValid(image,row,col) and image[row,col] == start]\n    def isValid(image,row,col):\n        return row > 0 and col>0 and row<len(image) and col<len(image[0])\n\n\n        \n```",
          "excerpt": "Def:\nBreadth-First Search (BFS) is ==a graph traversal algorithm that explores a graph level by level==\n\n![[Pasted image 20250817174830.png]]\nALGORITHM \n\n\nFLOOD FILL\n- PYTHON",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-08-17T13:16:03.586Z"
        },
        {
          "id": "991-clang-algs-dfs-md",
          "slug": "991-clang/algs/dfs",
          "filepath": "991-CLANG/ALGS/DFS.md",
          "folder": "991-CLANG/ALGS",
          "filename": "DFS.md",
          "frontmatter": {
            "title": "DFS",
            "date": "2025-08-18",
            "tags": [
              "python"
            ],
            "category": "991-CLANG/ALGS"
          },
          "content": "### Using recursion\n```python\nmarksed = [False] * GRIDSIZE\ndef dfs(G,v):\n\tvisit(v)\n\tmarked[v] = True\n\tfor w in neighbours(G,v):\n\t\tif not marked[w]:\n\t\t\tdfs(G,w)\n```\n\n### Using Stack\n```python\nmarksed = [False] * GRIDSIZE\ndef dfs(G,v):\n\tstack = [v]\n\twhile stackNotEmpty():\n\t\tv = stack.pop()\n\t\tif not marked[w]:\n\t\t\t\tvisit(v)\n\t\t\t\tmarked[v] = True\n\t\t\t\tfor w in neighbours(G,v):\n\t\t\t\t\tif not marked[w]:\n\t\t\t\t\t\tstack.append(w)\n```",
          "excerpt": "Using recursion\n\n\nUsing Stack",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-08-18T12:54:33.805Z"
        },
        {
          "id": "991-clang-algs-dijkstra-algorithm-md",
          "slug": "991-clang/algs/dijkstra-algorithm",
          "filepath": "991-CLANG/ALGS/Dijkstra Algorithm.md",
          "folder": "991-CLANG/ALGS",
          "filename": "Dijkstra Algorithm.md",
          "frontmatter": {
            "title": "Dijkstra Algorithm",
            "date": "2025-09-04",
            "category": "991-CLANG/ALGS"
          },
          "content": "\n\n### 1. Dijkstra's Algorithm: Finding the Shortest Path\n\nImagine you're standing in a city and want to find the shortest walking time to every other location. Dijkstra's algorithm is a methodical way to do this.\n\n**The Core Idea**: Start at a source point and explore outwards. Always prioritize exploring from the location you've reached that has the shortest total travel time from your start. It's a \"greedy\" approach because you always choose the path that seems best at the moment.\n\n**The Key Components**:\n* **Nodes (Vertices)**: These are the locations (e.g., intersections in a city).\n* **Edges**: These are the paths connecting the locations (e.g., streets).\n* **Weights**: This is the \"cost\" to travel an edge (e.g., the time it takes to walk down a street). For Dijkstra's to work, these weights **must not be negative**.\n\n**The Steps**:\n1.  **Initialization**:\n    * Pick a starting node. The distance to this node is 0.\n    * The distance to every other node is initially unknown, so we mark it as infinity.\n    * Keep track of all nodes you haven't visited yet.\n\n2.  **The Loop**:\n    * From your set of unvisited nodes, pick the one with the smallest known distance from the start. Let's call this the `current_node`.\n    * For the `current_node`, look at all its directly connected neighbors.\n    * For each neighbor, calculate the distance from the start point *through* the `current_node`. This is `(distance to current_node) + (weight of the edge to the neighbor)`.\n    * If this new calculated distance is shorter than the neighbor's previously known distance, update it.\n    * Once you've checked all neighbors, mark the `current_node` as visited. You're done with it because you've found the guaranteed shortest path to it.\n    * Repeat this process until you've visited all nodes (or just the destination node if you only need one path).\n\n\n\n---\n\n### 2. Priority Queues: The Engine for Dijkstra's\n\nHow do you efficiently perform the step \"pick the unvisited node with the smallest known distance\"? If you have thousands of nodes, searching through a list every time is very slow. This is where a priority queue comes in.\n\n**What it is**: A priority queue is a special data structure where every element has a \"priority.\" When you ask for an element, it **always gives you the one with the highest (or lowest) priority**.\n\n**How it helps Dijkstra's**:\n* You store the nodes to visit in a priority queue.\n* The \"priority\" of each node is its **total distance from the start**.\n* When Dijkstra's algorithm needs the next node to visit, it simply asks the priority queue for the element with the lowest priority (the shortest distance). This is extremely fast.\n\nSo, the priority queue acts as an efficient to-do list, ensuring the algorithm always explores the most promising node next without wasting time searching.\n\n### APPLY IN AOC day 17\n[[Day 17]]\n",
          "excerpt": "1. Dijkstra's Algorithm: Finding the Shortest Path\n\nImagine you're standing in a city and want to find the shortest walking time to every other location. Dijkstra's algorithm is a methodical way to do...",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-09-04T16:36:20.452Z"
        }
      ]
    },
    {
      "name": "991-CLANG/DS",
      "path": "991-CLANG/DS",
      "noteCount": 2,
      "notes": [
        {
          "id": "991-clang-ds-priority-queue-md",
          "slug": "991-clang/ds/priority-queue",
          "filepath": "991-CLANG/DS/Priority Queue.md",
          "folder": "991-CLANG/DS",
          "filename": "Priority Queue.md",
          "frontmatter": {
            "title": "Priority Queue",
            "date": "2025-09-05",
            "tags": [
              "c",
              "include",
              "define"
            ],
            "category": "991-CLANG/DS"
          },
          "content": "\n\n> [!NOTE] Def:\n> Priority queue is an abstract data type(ADT) in the computer science which is designed to the operate much like the regular queue except that each element has the certain priority. The priority can determines the order in which elements are dequeued - elements with the higher priority are removed from queue before those with lower priority\n\n```c\ntypedef struct {\n    int items[MAX];\n    int size;\n} PriorityQueue;\n\n```\n\n### 1. Enqueue Operation\n\nThis operation can be used to add the new element to the priority queue with the given priority.\n\n****Algorithm****\n\n> - Add the element to end of the heap.\n> - Restore the heap property by the comparing the added element with its parent. If it can violates the heap property, swap them.\n> - Continues this process up the heap until the correct position is found or root is reached.\n\n### 2. Dequeue (Extract - Min/Max)\n\nThis operation can be used to removes and return the elements with the highest max in the max-heap and min in the min-heap of the priority queue.\n\n****Algorithms****\n\n> 1. Replace the root of heap with the last element in the heap.\n> 2. Reduce the size of the heap by the one.\n> 3. Restore the heap property by the recursively comparing the new root with its children and swapping it\n> 4. with the higher priority child in the max-heap or the lower priority child in the min heap.\n> 5. Continues this process down the heap until the correct position is found or the leaf is reached.\n\n### 3. Peek\n\nThis operation can be used to returns the element with the highest priority without the removing it from the priority queue.\n\n****Algorithm****\n\n> 1. Return the element at the root of the heap.\n\n### 4. Increase/Decrease Key\n\nThis operation can be used to change the priority of the element in the priority queue.\n\n****Algorithm****\n\n> 1. Locate the element whose the priority needs to be updated.\n> 2. Update the priority of the element.\n> 3. If the priority is increased in the max-heap or decreased in the min-heap and it can restore the heap property by the heapifying up from the element.\n> 4. If the priority is decreased in the max-heap or increased in the min-heap and restore the heap property by the heapifying down from element.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define maximum size of the priority queue\n#define MAX 100\n\n// Define PriorityQueue structure\ntypedef struct {\n    int items[MAX];\n    int size;\n} PriorityQueue;\n\n// Define swap function to swap two integers\nvoid swap(int* a, int* b)\n{\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\n// Define heapifyUp function to maintain heap property\n// during insertion\nvoid heapifyUp(PriorityQueue* pq, int index)\n{\n    if (index\n        && pq->items[(index - 1) / 2] > pq->items[index]) {\n        swap(&pq->items[(index - 1) / 2],\n             &pq->items[index]);\n        heapifyUp(pq, (index - 1) / 2);\n    }\n}\n\n// Define enqueue function to add an item to the queue\nvoid enqueue(PriorityQueue* pq, int value)\n{\n    if (pq->size == MAX) {\n        printf(\"Priority queue is full\\n\");\n        return;\n    }\n\n    pq->items[pq->size++] = value;\n    heapifyUp(pq, pq->size - 1);\n}\n\n// Define heapifyDown function to maintain heap property\n// during deletion\nint heapifyDown(PriorityQueue* pq, int index)\n{\n    int smallest = index;\n    int left = 2 * index + 1;\n    int right = 2 * index + 2;\n\n    if (left < pq->size\n        && pq->items[left] < pq->items[smallest])\n        smallest = left;\n\n    if (right < pq->size\n        && pq->items[right] < pq->items[smallest])\n        smallest = right;\n\n    if (smallest != index) {\n        swap(&pq->items[index], &pq->items[smallest]);\n        heapifyDown(pq, smallest);\n    }\n}\n\n// Define dequeue function to remove an item from the queue\nint dequeue(PriorityQueue* pq)\n{\n    if (!pq->size) {\n        printf(\"Priority queue is empty\\n\");\n        return -1;\n    }\n\n    int item = pq->items[0];\n    pq->items[0] = pq->items[--pq->size];\n    heapifyDown(pq, 0);\n    return item;\n}\n\n// Define peek function to get the top item from the queue\nint peek(PriorityQueue* pq)\n{\n    if (!pq->size) {\n        printf(\"Priority queue is empty\\n\");\n        return -1;\n    }\n    return pq->items[0];\n}\n\n// Define main function\nint main()\n{\n    // Initialize priority queue\n    PriorityQueue pq = { { 0 }, 0 };\n    // Add items to the queue\n    enqueue(&pq, 3);\n    enqueue(&pq, 2);\n    enqueue(&pq, 15);\n    enqueue(&pq, 5);\n    enqueue(&pq, 4);\n    enqueue(&pq, 45);\n\n    // Dequeue an item and print it\n    printf(\"%d dequeued from queue\\n\", dequeue(&pq));\n    // Print the top item of the queue\n    printf(\"Top element is %d\\n\", peek(&pq));\n\n    return 0;\n}\n```",
          "excerpt": "> [!NOTE] Def:\n> Priority queue is an abstract data type(ADT) in the computer science which is designed to the operate much like the regular queue except that each element has the certain priority. Th...",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-09-05T07:26:27.731Z"
        },
        {
          "id": "991-clang-ds-linked-list-md",
          "slug": "991-clang/ds/linked-list",
          "filepath": "991-CLANG/DS/Linked List.md",
          "folder": "991-CLANG/DS",
          "filename": "Linked List.md",
          "frontmatter": {
            "title": "1 **What is a Linked List?**",
            "date": "2025-11-14",
            "tags": [
              "c",
              "include"
            ],
            "category": "991-CLANG/DS"
          },
          "content": "\n# 1 **What is a Linked List?**\n\nA **Linked List** is a linear data structure where elements (called **nodes**) are stored in **non-contiguous memory locations**.\n\nEach node contains:\n\n1. **Data**\n2. **Pointer to the next node**\n\n```\n[Data | Next]  [Data | Next]  [Data | Next]  NULL\n```\n\n---\n\n# 2 **Why Linked List?**\n\n###  Advantages\n\n* **Dynamic size** (grows/shrinks at runtime)\n* **Efficient insertion/deletion** (O(1) if position known)\n* No need for contiguous memory (unlike arrays)\n* Useful for implementing stacks, queues, graphs.\n\n###  Disadvantages\n\n* No random access (must traverse sequentially)\n* Extra memory for storing pointers\n* Slower traversal due to pointer overhead\n* Not cache-friendly\n\n---\n\n# 3 **Types of Linked Lists**\n\n---\n\n##  3.1 **Singly Linked List**\n\nEach node has:\n\n* data\n* pointer to **next** node\n\n```\n+------+------+\n| Data | Next | --->  +------+------+\n+------+------         | Data | Next | ---> NULL\n```\n\n### Pointer structure (C):\n\n```c\nstruct Node {\n    int data;\n    struct Node* next;\n};\n```\n\n---\n\n##  3.2 **Doubly Linked List**\n\nEach node has:\n\n* data\n* pointer to previous node\n* pointer to next node\n\n```\nNULL  [Prev | Data | Next]  [Prev | Data | Next]  NULL\n```\n\n### Structure:\n\n```c\nstruct Node {\n    int data;\n    struct Node* prev;\n    struct Node* next;\n};\n```\n\n---\n\n##  3.3 **Circular Linked List**\n\nLast node points back to the **head**, not NULL.\n\n### Circular Singly:\n\n```\nA  B  C  D  A (head)\n```\n\n### Circular Doubly:\n\n```\n A  B  C  D  (back to A)\n```\n\n### Structure similar to singly/doubly  only last node links to head.\n\n---\n\n---\n\n# 4 **SINGLY LINKED LIST  Full Implementation in C**\n\n---\n\n##  4.1 Node Structure\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n```\n\n---\n\n##  4.2 Insert at Beginning\n\n```c\nstruct Node* insertAtBeginning(struct Node* head, int value) {\n    struct Node* newNode = malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = head;\n    return newNode;\n}\n```\n\n---\n\n##  4.3 Insert at End\n\n```c\nstruct Node* insertAtEnd(struct Node* head, int value) {\n    struct Node* newNode = malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n\n    if (head == NULL) return newNode;\n\n    struct Node* temp = head;\n    while (temp->next != NULL)\n        temp = temp->next;\n\n    temp->next = newNode;\n    return head;\n}\n```\n\n---\n\n##  4.4 Insert at Position\n\n```c\nstruct Node* insertAtPosition(struct Node* head, int value, int pos) {\n    if (pos == 1)\n        return insertAtBeginning(head, value);\n\n    struct Node* newNode = malloc(sizeof(struct Node));\n    newNode->data = value;\n\n    struct Node* temp = head;\n    for (int i = 1; i < pos - 1 && temp != NULL; i++)\n        temp = temp->next;\n\n    if (temp == NULL) {\n        printf(\"Position out of bounds\\n\");\n        return head;\n    }\n\n    newNode->next = temp->next;\n    temp->next = newNode;\n\n    return head;\n}\n```\n\n---\n\n##  4.5 Delete from Beginning\n\n```c\nstruct Node* deleteFromBeginning(struct Node* head) {\n    if (head == NULL) return NULL;\n\n    struct Node* temp = head;\n    head = head->next;\n    free(temp);\n    return head;\n}\n```\n\n---\n\n##  4.6 Delete from End\n\n```c\nstruct Node* deleteFromEnd(struct Node* head) {\n    if (head == NULL) return NULL;\n\n    if (head->next == NULL) {\n        free(head);\n        return NULL;\n    }\n\n    struct Node* temp = head;\n    while (temp->next->next != NULL)\n        temp = temp->next;\n\n    free(temp->next);\n    temp->next = NULL;\n\n    return head;\n}\n```\n\n---\n\n##  4.7 Delete at Position\n\n```c\nstruct Node* deleteAtPosition(struct Node* head, int pos) {\n    if (pos == 1)\n        return deleteFromBeginning(head);\n\n    struct Node* temp = head;\n    for (int i = 1; i < pos - 1 && temp != NULL; i++)\n        temp = temp->next;\n\n    if (temp == NULL || temp->next == NULL) {\n        printf(\"Position invalid\\n\");\n        return head;\n    }\n\n    struct Node* target = temp->next;\n    temp->next = target->next;\n    free(target);\n\n    return head;\n}\n```\n\n---\n\n##  4.8 Searching in Linked List\n\n```c\nvoid search(struct Node* head, int key) {\n    int pos = 1;\n    while (head != NULL) {\n        if (head->data == key) {\n            printf(\"Found at position %d\\n\", pos);\n            return;\n        }\n        head = head->next;\n        pos++;\n    }\n    printf(\"Not found\\n\");\n}\n```\n\n---\n\n##  4.9 Display List\n\n```c\nvoid display(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d  \", head->data);\n        head = head->next;\n    }\n    printf(\"NULL\\n\");\n}\n```\n\n---\n##  4.10 Reverse a List\n\n```c\nvoid reverseList(struct Node** headRef) {\n  struct Node* prev = NULL;\n  struct Node* current = *headRef;\n  struct Node* next = NULL;\n\n  while (current != NULL) {\n    next = current->next;\n    current->next = prev;\n    prev = current;\n    current = next;\n  }\n  *headRef = prev;\n}\n```\n\n---\n\n\n# 5 **DOUBLY LINKED LIST  Main Operations**\n\n(Short version; can expand if you want)\n\n---\n\n##  5.1 Structure\n\n```c\nstruct Node {\n    int data;\n    struct Node* prev;\n    struct Node* next;\n};\n```\n\n---\n\n##  5.2 Insert at Beginning\n\n```c\nstruct Node* insertAtBeginning(struct Node* head, int value) {\n    struct Node* newNode = malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->prev = NULL;\n    newNode->next = head;\n\n    if (head != NULL)\n        head->prev = newNode;\n\n    return newNode;\n}\n```\n\n---\n\n##  5.3 Insert at End\n\n```c\nstruct Node* insertAtEnd(struct Node* head, int value) {\n    struct Node* newNode = malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n\n    if (head == NULL) {\n        newNode->prev = NULL;\n        return newNode;\n    }\n\n    struct Node* temp = head;\n    while (temp->next != NULL)\n        temp = temp->next;\n\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n```\n\n---\n\n# 6 **CIRCULAR LINKED LIST (Concept)**\n\n### Changes:\n\n* Last node points back to **head**.\n* Useful for round-robin scheduling, music playlists, queues.\n\n### Example:\n\n```\nhead  A  B  C  (back to head)\n```\n\n---\n\n# 7 **Linked List vs Array**\n\n| Feature         | Array             | Linked List |\n| --------------- | ----------------- | ----------- |\n| Memory          | Contiguous        | Anywhere    |\n| Insert/Delete   | Expensive (shift) | O(1)        |\n| Access          | O(1) random       | O(n)        |\n| Memory overhead | Low               | High        |\n| Cache-friendly  | Yes               | No          |\n\n---\n\n# 8 **Real-life Applications**\n\n* Undo/Redo in editors\n* Playlist navigation\n* Browser forward/back history\n* Queues/stacks implementation\n* Graph adjacency lists\n* Memory management (free list)\n\n---\n\n",
          "excerpt": "1 What is a Linked List?\n\nA Linked List is a linear data structure where elements (called nodes) are stored in non-contiguous memory locations.\n\nEach node contains:\n\n1. Data\n2. Pointer to the next n...",
          "createdAt": "1970-01-01T00:00:00.000Z",
          "modifiedAt": "2025-11-14T11:09:02.580Z"
        }
      ]
    },
    {
      "name": "991-CLANG/imgs",
      "path": "991-CLANG/imgs",
      "noteCount": 0,
      "notes": []
    }
  ],
  "notes": [
    {
      "id": "101-advent-of-code-2023-day-1-md",
      "slug": "101-advent-of-code/2023/day-1",
      "filepath": "101-ADVENT OF CODE/2023/Day 1.md",
      "folder": "101-ADVENT OF CODE/2023",
      "filename": "Day 1.md",
      "frontmatter": {
        "title": "Day 1",
        "date": "2025-07-24",
        "tags": [
          "adventofcode",
          "aoc2023",
          "programming",
          "challenges",
          "puzzle",
          "coding",
          "algorithms"
        ],
        "category": "101-ADVENT OF CODE/2023",
        "description": "Solutions and notes for Day 1 of the Advent of Code 2023 programming challenge covering both parts of the puzzle."
      },
      "content": "### PART 1\n\n```C\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n        return 1;\n    }\n\n    FILE *fptr;\n    fptr = fopen(argv[1], \"r\");\n    if (fptr == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char line[1028];\n    int sum = 0;\n\n    while (fgets(line, sizeof(line), fptr)) {\n        // Remove trailing newline character if present\n        line[strcspn(line, \"\\n\")] = 0;\n        printf(\"Processing line: %s\\n\", line); // Changed from original printf\n\n        int left = -1;\n        int right = -1;\n\n        for (int i = 0; i < strlen(line); i++) {\n            if (isdigit(line[i])) {\n                if (left == -1) {\n                    left = line[i] - '0'; // Use '0' instead of 0x30 for clarity\n                    right = line[i] - '0';\n                } else {\n                    right = line[i] - '0';\n                }\n            }\n        }\n\n        // Handle lines with no digits\n        if (left != -1) {\n            int digit = left * 10 + right;\n            printf(\"Extracted Digit: %d\\n\", digit);\n            sum += digit;\n        } else {\n            printf(\"No digits found in this line.\\n\");\n        }\n    }\n\n    printf(\"Final Sum: %d \\n\", sum); // Changed from original printf\n\n    fclose(fptr);\n    return 0;\n}\n```\n\n\n### PART 2\n\n```C\n\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char str[10];\n    int i;\n} lookup_t;\n\nlookup_t gTable[] = {\n    {\"zero\", 0},\n    {\"one\", 1},\n    {\"two\", 2},\n    {\"three\", 3},\n    {\"four\", 4},\n    {\"five\", 5},\n    {\"six\", 6},\n    {\"seven\", 7},\n    {\"eight\", 8},\n    {\"nine\", 9}\n};\n\n#define GTABLE_SIZE (sizeof(gTable) / sizeof(gTable[0]))\n\nint match(char *pattern) {\n    for (int i = 0; i < GTABLE_SIZE; i++) {\n        if (!strncmp(gTable[i].str, pattern, strlen(gTable[i].str))) {\n            return gTable[i].i;\n        }\n    }\n    return -1;\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n        return 1;\n    }\n\n    FILE *fptr;\n    fptr = fopen(argv[1], \"r\");\n    if (fptr == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char line[1028];\n    int sum = 0;\n\n    while (fgets(line, sizeof(line), fptr)) {\n        line[strcspn(line, \"\\n\")] = 0;\n        printf(\"Processing line: %s\\n\", line);\n\n        int left = -1;\n        int right = -1;\n\n        for (int i = 0; i < strlen(line); i++) {\n            int current_digit = -1;\n\n            if (isdigit(line[i])) {\n                current_digit = line[i] - '0';\n            } else {\n                int matched_word_value = match(&line[i]);\n                if (matched_word_value != -1) {\n                    current_digit = matched_word_value;\n                }\n            }\n\n            if (current_digit != -1) {\n                if (left == -1) {\n                    left = current_digit;\n                }\n                right = current_digit;\n            }\n        }\n\n        if (left != -1) {\n            int calibration_value = left * 10 + right;\n            printf(\"Extracted Calibration Value: %d\\n\", calibration_value);\n            sum += calibration_value;\n        } else {\n            printf(\"No valid digits (numeric or word) found in this line.\\n\");\n        }\n    }\n\n    printf(\"Final Sum of Calibration Values: %d \\n\", sum);\n\n    fclose(fptr);\n    return 0;\n}\n```\n\n\n",
      "excerpt": "Solutions and notes for Day 1 of the Advent of Code 2023 programming challenge covering both parts of the puzzle.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-07-24T07:13:22.000Z"
    },
    {
      "id": "101-advent-of-code-2023-day-10-md",
      "slug": "101-advent-of-code/2023/day-10",
      "filepath": "101-ADVENT OF CODE/2023/Day 10.md",
      "folder": "101-ADVENT OF CODE/2023",
      "filename": "Day 10.md",
      "frontmatter": {
        "title": "Day 10",
        "date": "2025-08-17",
        "tags": [
          "advent-of-code",
          "aoc-2023",
          "day-10",
          "pipe-maze",
          "algorithms",
          "coding-challenge"
        ],
        "category": "101-ADVENT OF CODE/2023",
        "description": "Implementation and notes for Part 1 of the Day 10 Pipe Maze puzzle from the 2023 Advent of Code challenge."
      },
      "content": "### PART 1\n```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_DIM 200\n\ntypedef struct {\n  int x;\n  int y;\n} Point;\n\n// QUEUE IMPLIMENTATION\n\nPoint queue[MAX_DIM * MAX_DIM];\nint front = 0;\nint rear = -1;\nint queue_size = 0;\n\nvoid enqueue(Point p) {\n  rear = (rear + 1) % (MAX_DIM * MAX_DIM);\n  queue[rear] = p;\n  queue_size++;\n}\n\nPoint dequeue() {\n  Point p = queue[front];\n  front = (front + 1) % (MAX_DIM * MAX_DIM);\n  queue_size--;\n  return p;\n}\nint is_queue_empty() { return queue_size == 0; }\n\nint main(int argc, char *argv[]) {\n  char grid[MAX_DIM][MAX_DIM];\n  int visited[MAX_DIM][MAX_DIM] = {0};\n  int num_rows = 0, num_cols = 0;\n\n  if (argc < 2) {\n    fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n    return 1;\n  }\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  while (fgets(grid[num_rows], MAX_DIM, fptr) != NULL) {\n    grid[num_rows][strcspn(grid[num_rows], \"\\n\")] =\n        '\\0'; // Remove newline character\n    if (num_cols == 0) {\n      num_cols = strlen(grid[num_rows]);\n    }\n    num_rows++;\n  }\n  fclose(fptr);\n\n  int start_x = -1, start_y = -1;\n\n  for (int i = 0; i < num_rows; i++) {\n    for (int j = 0; j < num_cols; j++) {\n      if (grid[i][j] == 'S') {\n        start_x = j;\n        start_y = i;\n        break;\n      }\n    }\n    if (start_y != -1)\n      break;\n  }\n  // BFS\n  Point start = {start_x, start_y};\n  enqueue(start);\n  visited[start_y][start_x] = 1;\n  int loop_count = 0;\n\n  while (!is_queue_empty()) {\n    Point current = dequeue();\n    loop_count++;\n    int x = current.x;\n    int y = current.y;\n    char current_char = grid[y][x];\n    // 1. check up\n    if (y > 0 && !visited[y - 1][x] && strchr(\"S|JL\", current_char) &&\n        strchr(\"|7F\", grid[y - 1][x])) {\n      visited[y - 1][x] = 1;\n      Point next = {x, y - 1};\n      enqueue(next);\n    }\n    // 2. check down\n    if (y < num_rows - 1 && !visited[y + 1][x] &&\n        strchr(\"S|7F\", current_char) && strchr(\"|JL\", grid[y + 1][x])) {\n      visited[y + 1][x] = 1;\n      Point next = {x, y + 1};\n      enqueue(next);\n    }\n    // 3. check left\n    if (x > 0 && !visited[y][x - 1] && strchr(\"S-J7\", current_char) &&\n        strchr(\"-LF\", grid[y][x - 1])) {\n      visited[y][x - 1] = 1;\n      Point next = {x - 1, y};\n      enqueue(next);\n    }\n    // 4. check right\n    if (x < num_cols - 1 && !visited[y][x + 1] &&\n        strchr(\"S-LF\", current_char) && strchr(\"-J7\", grid[y][x + 1])) {\n      visited[y][x + 1] = 1;\n      Point next = {x + 1, y};\n      enqueue(next);\n    }\n  }\n\n  printf(\"Number of loops: %d\\n\", loop_count / 2);\n  return 0;\n}\n\n```",
      "excerpt": "Implementation and notes for Part 1 of the Day 10 Pipe Maze puzzle from the 2023 Advent of Code challenge.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-08-17T11:55:32.110Z"
    },
    {
      "id": "101-advent-of-code-2023-day-13-md",
      "slug": "101-advent-of-code/2023/day-13",
      "filepath": "101-ADVENT OF CODE/2023/Day 13.md",
      "folder": "101-ADVENT OF CODE/2023",
      "filename": "Day 13.md",
      "frontmatter": {
        "title": "Part 2",
        "date": "2025-09-01",
        "tags": [
          "advent-of-code",
          "aoc-2023",
          "symmetry",
          "two-pointers",
          "grid",
          "transpose",
          "pattern-matching",
          "algorithms"
        ],
        "category": "101-ADVENT OF CODE/2023",
        "description": "A logic overview for detecting grid reflection symmetry using a two-pointer approach and matrix transposition for Advent of Code 2023."
      },
      "content": "### Pattern Matching and Symmetry Detection\n- **%% Basically a two pointer problem %%\n\n## The Approach\n1. Parse the input into a grid.\n2. Checking a Potential Reflection\n\t- Take 2 Pointers i and i+1 and check if same. \n\t- if eq then check i-1 and i+2 till the end of line.\n3. Continue for rows and columns both\n4. Use transpose the grid to reuse the function.\n\n```python\ndef find_horizontal_mirror(grid):\n\n    for i in range(len(grid) - 1):\n        top_ptr = i\n        bottom_ptr = i + 1\n        is_perfect_mirror = True\n\n        while top_ptr >= 0 and bottom_ptr < len(grid):\n            if grid[top_ptr] != grid[bottom_ptr]:\n                is_perfect_mirror = False\n                break\n            \n            top_ptr -= 1\n            bottom_ptr += 1\n            \n        if is_perfect_mirror:\n            return i + 1\n            \n    return 0\n\ndef solve(filename=\"input.txt\"):\n\n    try:\n        with open(filename, 'r') as file:\n            # Patterns are separated by blank lines.\n            patterns = file.read().strip().split('\\n\\n')\n    except FileNotFoundError:\n        print(f\"Error: Input file '{filename}' not found.\")\n        return\n\n    total_summary = 0\n\n    for pattern_str in patterns:\n        # Convert each pattern block into a grid (list of strings).\n        grid = pattern_str.splitlines()\n\n        # 1. Check for a horizontal mirror.\n        horizontal_rows = find_horizontal_mirror(grid)\n        if horizontal_rows > 0:\n            total_summary += 100 * horizontal_rows\n            continue # Move to the next pattern once the mirror is found.\n\n        # 2. If no horizontal mirror, check for a vertical one by transposing.\n        transposed_grid = [\"\".join(col) for col in zip(*grid)]\n\n        vertical_cols = find_horizontal_mirror(transposed_grid)\n        if vertical_cols > 0:\n            total_summary += vertical_cols\n\n    return total_summary\n\nif __name__ == \"__main__\":\n    # You will need to create an 'input.txt' file with your puzzle input.\n    result = solve()\n    if result is not None:\n        print(f\"The final summary for Part 1 is: {result}\")\n\n```\n\n\n# Part 2\n```\n\n```",
      "excerpt": "A logic overview for detecting grid reflection symmetry using a two-pointer approach and matrix transposition for Advent of Code 2023.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-09-01T13:19:30.229Z"
    },
    {
      "id": "101-advent-of-code-2023-day-17-md",
      "slug": "101-advent-of-code/2023/day-17",
      "filepath": "101-ADVENT OF CODE/2023/Day 17.md",
      "folder": "101-ADVENT OF CODE/2023",
      "filename": "Day 17.md",
      "frontmatter": {
        "title": "pseudo code",
        "date": "2025-09-05",
        "tags": [
          "advent of code",
          "dijkstra",
          "pathfinding",
          "algorithms",
          "graph-theory",
          "optimization"
        ],
        "category": "101-ADVENT OF CODE/2023",
        "description": "A walkthrough of adapting Dijkstra's algorithm with state tracking to solve the movement constraints of Advent of Code 2023 Day 17."
      },
      "content": "\n### The Problem: Advent of Code 2023, Day 17\n\n**The Goal**: Find the path from the top-left corner to the bottom-right corner with the minimum total heat loss.\n\n**The Twist (The Constraints)**: This isn't a simple pathfinding problem. Your movement is restricted:\n* You cannot reverse direction (e.g., if you moved right, your next move can't be left).\n* **Crucible Constraint (Part 1)**: You can move at most **three** steps in a single direction before you **must** turn 90 degrees left or right.\n\nThis constraint changes everything. The shortest path to a grid cell is meaningless if you arrive there having already moved three steps in the same direction, as your options for the next move are now limited.\n\n\n---\n\n###  The Solution: Combining Dijkstra's with State\n\nTo solve this, we must adapt Dijkstra's algorithm. The key is to realize that a \"node\" in our graph isn't just a position `(row, col)`. It has to include the information needed to follow the rules.\n\n#### Step 1: Redefine the \"Node\" as a \"State\"\n\nA state must uniquely identify a point in our search and contain enough information to determine the next valid moves. A good state representation is a tuple:\n\n`state = (row, col, direction, consecutive_steps)`\n\n* `row, col`: Your current grid coordinates.\n* `direction`: The direction you entered this cell from (e.g., North, East, South, West).\n* `consecutive_steps`: How many steps in a row you've taken in that `direction`.\n\n#### Step 2: Adapt Dijkstra's with the New State\n\nWe will use a priority queue, but instead of storing `(distance, row, col)`, we'll store the full state information, prioritized by heat loss:\n\n`Priority Queue Item: (total_heat_loss, row, col, direction, consecutive_steps)`\n\nWe also need a `visited` set to avoid processing the exact same *state* twice. Notice this is a set of states, not just coordinates. `visited.add((row, col, direction, steps))`\n\n#### Step 3: Detailed Walkthrough of the Algorithm\n\n1.  **Initialization**:\n    * Create an empty priority queue.\n    * Create an empty `visited` set.\n    * The starting point is `(0, 0)`. You can start by moving Right or Down. So, push two initial states onto the queue. (Note: The puzzle is about the heat loss of the *entered* cell, so the starting cell `(0,0)` has 0 cost).\n        * `pq.push((grid[0][1], 0, 1, EAST, 1))`\n        * `pq.push((grid[1][0], 1, 0, SOUTH, 1))`\n\n2.  **The Main Loop**:\n    * **Pop the state with the lowest heat loss**. Let's say we pop `(10, 3, 4, NORTH, 2)`. This means we've reached cell `(3, 4)` with a total heat loss of 10, having come from the south (moved North) for 2 consecutive steps.\n    * **Check if visited**. If `(3, 4, NORTH, 2)` is in our `visited` set, we've already found a better or equal path to this exact state. `continue` to the next item in the queue. Otherwise, add it to `visited`.\n    * **Check for Goal**. Is `(row, col)` the bottom-right corner? If yes, we're done! The `total_heat_loss` is our answer.\n    * **Generate Next Moves (Neighbors)**. From our current state `(row=3, col=4, dir=NORTH, steps=2)`, what can we do next?\n        * **Turn Left (move West)**: This is a valid turn. The new state would be at `(3, 3)`. The number of steps resets to 1.\n            * New state: `(row=3, col=3, dir=WEST, steps=1)`\n            * New heat loss: `10 + grid[3][3]`\n            * Push `(10 + grid[3][3], 3, 3, WEST, 1)` to the queue.\n        * **Turn Right (move East)**: This is also a valid turn. The new state would be at `(3, 5)`. Steps reset to 1.\n            * New state: `(row=3, col=5, dir=EAST, steps=1)`\n            * New heat loss: `10 + grid[3][5]`\n            * Push `(10 + grid[3][5], 3, 5, EAST, 1)` to the queue.\n        * **Go Straight (move North)**: Can we continue North? Yes, because our current `steps=2` is less than the max of 3.\n            * New state: `(row=2, col=4, dir=NORTH, steps=3)`\n            * New heat loss: `10 + grid[2][4]`\n            * Push `(10 + grid[2][4], 2, 4, NORTH, 3)` to the queue.\n\n    * **Repeat**: The loop continues, always processing the state with the absolute minimum heat loss found so far across all possible paths, until the destination is reached.\n\n## pseudo code\n\n\n```\n// Define constants for directions for clarity\n// For example: 0:North, 1:East, 2:South, 3:West\nDIRECTIONS = [( -1, 0 ), ( 0, 1 ), ( 1, 0 ), ( 0, -1 )]\n\nfunction solve(grid):\n    // The priority queue stores tuples of:\n    // (total_heat_loss, row, col, direction_index, consecutive_steps)\n    priority_queue = new PriorityQueue()\n\n    // The visited set stores tuples of:\n    // (row, col, direction_index, consecutive_steps)\n    // to avoid redundant computations for the exact same state.\n    visited = new Set()\n\n    // Get grid dimensions\n    height = number of rows in grid\n    width = number of columns in grid\n\n    // -- Initialization --\n    // We start at (0,0) but haven't moved yet. We can either go\n    // East (1) or South (2) as our first move.\n    // The starting cell's heat loss is not counted.\n    // So, we push the states for the first move onto the queue.\n    \n    // Move East from start\n    if (0, 1) is a valid coordinate:\n        heat_loss = grid[0][1]\n        priority_queue.push((heat_loss, 0, 1, 1, 1)) // dir=East, steps=1\n\n    // Move South from start\n    if (1, 0) is a valid coordinate:\n        heat_loss = grid[1][0]\n        priority_queue.push((heat_loss, 1, 0, 2, 1)) // dir=South, steps=1\n\n    // -- Main Dijkstra Loop --\n    while priority_queue is not empty:\n        // 1. Pop the state with the minimum heat loss\n        (heat_loss, r, c, dir, steps) = priority_queue.pop()\n\n        // 2. Check if we reached the destination\n        if r == height - 1 and c == width - 1:\n            return heat_loss // We found the shortest path!\n\n        // 3. Check if we have already processed this exact state\n        if (r, c, dir, steps) is in visited:\n            continue\n        visited.add((r, c, dir, steps))\n\n        // 4. Explore next possible moves (neighbors in the state graph)\n\n        // -- A) Continue Straight --\n        // Check if we can continue in the same direction (steps < 3)\n        if steps < 3:\n            // Calculate next position\n            nr = r + DIRECTIONS[ddir][0]\n            nc = c + DIRECTIONS[dir][1]\n\n            // Check if the new position is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                new_heat_loss = heat_loss + grid[nr][nc]\n                new_state = (new_heat_loss, nr, nc, dir, steps + 1)\n                priority_queue.push(new_state)\n\n        // -- B) Turn Left & Right --\n        // We can always turn. We iterate through all four directions.\n        for new_dir in range(4):\n            // We cannot go in the same direction (handled above) or reverse.\n            // The reverse of dir `d` is `(d + 2) % 4`.\n            if new_dir == dir or new_dir == (dir + 2) % 4:\n                continue\n\n            // Calculate next position based on the new direction\n            nr = r + DIRECTIONS[new_dir][0]\n            nc = c + DIRECTIONS[new_dir][1]\n            \n            // Check if the new position is within grid bounds\n            if 0 <= nr < height and 0 <= nc < width:\n                new_heat_loss = heat_loss + grid[nr][nc]\n                // After a turn, consecutive steps reset to 1\n                new_state = (new_heat_loss, nr, nc, new_dir, 1)\n                priority_queue.push(new_state)\n\n    return -1 // Should not be reached if a path exists\n```",
      "excerpt": "A walkthrough of adapting Dijkstra's algorithm with state tracking to solve the movement constraints of Advent of Code 2023 Day 17.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-09-05T08:26:30.569Z"
    },
    {
      "id": "101-advent-of-code-2023-day-2-md",
      "slug": "101-advent-of-code/2023/day-2",
      "filepath": "101-ADVENT OF CODE/2023/Day 2.md",
      "folder": "101-ADVENT OF CODE/2023",
      "filename": "Day 2.md",
      "frontmatter": {
        "title": "Day 2",
        "date": "2025-08-17",
        "tags": [
          "advent-of-code",
          "aoc-2023",
          "programming-challenge",
          "puzzle-solving",
          "coding",
          "algorithms"
        ],
        "category": "101-ADVENT OF CODE/2023",
        "description": "Progress and solutions for Day 2 of the Advent of Code 2023 programming challenge, covering both Part 1 and Part 2."
      },
      "content": "\n### PART 1\n\n```c\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n// Define a struct to hold the maximum allowed cube counts for the entire game\ntypedef struct {\n  int red;\n  int green;\n  int blue;\n} CubeLimits;\n\n// Define a struct to hold the current cube counts observed within a single set\ntypedef struct {\n  int red;\n  int green;\n  int blue;\n} CurrentSetCubes;\n\nint process_set(char *set_str, const CubeLimits *limits) {\n  char *color_token;\n  char *rest_of_colors_ptr; // For strtok_r state\n\n  // Initialize current cube counts for this set to zero\n  CurrentSetCubes current_cubes = {0, 0, 0};\n\n  // Tokenize the set string by commas to get individual color-count pairs\n  color_token = strtok_r(set_str, \",\", &rest_of_colors_ptr);\n  while (color_token != NULL) {\n    int count = 0;\n    char color_name[10]; // To store \"red\", \"blue\", \"green\"\n\n    // Trim leading whitespace from color_token (e.g., \" 3 blue\" -> \"3 blue\")\n    while (*color_token == ' ') {\n      color_token++;\n    }\n\n    // Parse the count and color name from the token\n    if (sscanf(color_token, \"%d %s\", &count, color_name) == 2) {\n      // Accumulate the counts into the CurrentSetCubes struct\n      if (strcmp(color_name, \"red\") == 0) {\n        current_cubes.red += count;\n      } else if (strcmp(color_name, \"green\") == 0) {\n        current_cubes.green += count;\n      } else if (strcmp(color_name, \"blue\") == 0) {\n        current_cubes.blue += count;\n      }\n      // Note: No 'else' for unrecognized colors, they are ignored as per AoC\n      // problem\n    }\n    // Get the next color-count pair\n    color_token = strtok_r(NULL, \",\", &rest_of_colors_ptr);\n  }\n\n  // After accumulating all counts for this set, check against the limits\n  if (current_cubes.red > limits->red || current_cubes.green > limits->green ||\n      current_cubes.blue > limits->blue) {\n    return 0; // This set is impossible because one or more colors exceed limits\n  }\n\n  return 1; // All accumulated counts in this set are within limits, so the set\n            // is possible\n}\n\nint is_game_possible(char *sets_string, int game_id, const CubeLimits *limits) {\n  char *set_token;\n  char *rest_of_sets_ptr; // For strtok_r state\n  // Tokenize the sets string by semicolons to get individual sets\n  set_token = strtok_r(sets_string, \";\", &rest_of_sets_ptr);\n  while (set_token != NULL) {\n    // Process each set and check if it's possible\n    if (!process_set(set_token, limits)) { // Pass limits to process_set\n      // If any set is impossible, the entire game is impossible\n      return 0;\n    }\n    // Get the next set\n    set_token = strtok_r(NULL, \";\", &rest_of_sets_ptr);\n  }\n  return 1; // All sets in the game are possible, so the game is possible\n}\n\nchar *parse_game_line(char *line_copy, int *game_id_out) {\n  char *token;\n  char *game_id_end_ptr; // For strtok_r state\n  // Extract the \"Game X\" part\n  token = strtok_r(line_copy, \":\", &game_id_end_ptr);\n  if (token == NULL) {\n    return NULL; // Error: No game ID part found\n  }\n\n  // Skip \"Game \" and convert the rest to an integer\n  *game_id_out = atoi(token + strlen(\"Game \"));\n\n  // Get the rest of the string containing the sets\n  // Using an empty string as delimiter for strtok_r effectively gets the rest\n  // of the string\n  return strtok_r(NULL, \"\", &game_id_end_ptr);\n}\n\nint main() {\n  FILE *file;\n  char line[512]; // Assuming a max line length of 511 characters + null\n                  // terminator\n  int sum_of_possible_game_ids = 0;\n\n  // Initialize the CubeLimits struct with the maximum allowed values\n  CubeLimits max_limits = {.red = 12, .green = 13, .blue = 14};\n\n  // Open the input file\n  // Ensure 'input.txt' is in the same directory as your compiled executable\n  file = fopen(\"input.txt\", \"r\");\n  if (file == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  // Read the file line by line\n  while (fgets(line, sizeof(line), file) != NULL) {\n    // Remove trailing newline character if present\n    line[strcspn(line, \"\\n\")] = 0;\n\n    // Create a mutable copy of the line for strtok_r to modify\n    char *line_copy = strdup(line);\n    if (line_copy == NULL) {\n      perror(\"Failed to duplicate line\");\n      fclose(file);\n      return 1;\n    }\n\n    int game_id = 0;\n    char *sets_string = NULL;\n\n    // Parse the game line to get ID and sets string\n    sets_string = parse_game_line(line_copy, &game_id);\n\n    if (sets_string == NULL) {\n      fprintf(stderr, \"Error parsing line: %s\\n\", line);\n      free(line_copy);\n      continue; // Skip to the next line\n    }\n\n    // Check if the entire game is possible based on its sets, passing the\n    // limits\n    if (is_game_possible(sets_string, game_id, &max_limits)) {\n      sum_of_possible_game_ids += game_id;\n    }\n\n    free(line_copy); // Free the duplicated line for the current iteration\n  }\n\n  fclose(file); // Close the file after processing all lines\n\n  printf(\"Sum of IDs of possible games: %d\\n\", sum_of_possible_game_ids);\n\n  return 0;\n}\n\n```\n\n### Part 2\n```c\n\n#include <stdio.h>\n#include <stdlib.h> // For atoi, strdup, free\n#include <string.h>\n\n// Define a struct to hold the cube counts observed within a single set\ntypedef struct {\n  int red;\n  int green;\n  int blue;\n} SetCubes; // Renamed from CurrentSetCubes for clarity in Part B context\n\n// Define a struct to hold the minimum required cube counts for the entire game\n// In Part B, this stores the maximum observed count for each color across all\n// sets\ntypedef struct {\n  int red;\n  int green;\n  int blue;\n} GameMinCubes;\n\n/**\n * @brief Processes a single set of cubes (e.g., \"3 blue, 4 red\") and returns\n * the counts.\n *\n * This function tokenizes the set string by commas to get individual\n * color-count pairs. It accumulates the counts for red, green, and blue into a\n * SetCubes struct.\n *\n * @param set_str The string representing a single set of cubes. This string\n * will be modified.\n * @return A SetCubes struct containing the accumulated counts for this set.\n */\nSetCubes process_set(char *set_str) {\n  char *color_token;\n  char *rest_of_colors_ptr; // For strtok_r state\n\n  // Initialize current cube counts for this set to zero\n  SetCubes current_set_cubes = {0, 0, 0};\n\n  // Tokenize the set string by commas to get individual color-count pairs\n  color_token = strtok_r(set_str, \",\", &rest_of_colors_ptr);\n  while (color_token != NULL) {\n    int count = 0;\n    char color_name[10]; // To store \"red\", \"blue\", \"green\"\n\n    // Trim leading whitespace from color_token (e.g., \" 3 blue\" -> \"3 blue\")\n    while (*color_token == ' ') {\n      color_token++;\n    }\n\n    // Parse the count and color name from the token\n    if (sscanf(color_token, \"%d %s\", &count, color_name) == 2) {\n      // Accumulate the counts into the SetCubes struct\n      if (strcmp(color_name, \"red\") == 0) {\n        current_set_cubes.red += count;\n      } else if (strcmp(color_name, \"green\") == 0) {\n        current_set_cubes.green += count;\n      } else if (strcmp(color_name, \"blue\") == 0) {\n        current_set_cubes.blue += count;\n      }\n      // Note: No 'else' for unrecognized colors, they are ignored as per AoC\n      // problem\n    }\n    // Get the next color-count pair\n    color_token = strtok_r(NULL, \",\", &rest_of_colors_ptr);\n  }\n\n  return current_set_cubes;\n}\n\n/**\n * @brief Calculates the \"power\" of a game for Advent of Code Day 2 Part B.\n *\n * The power is the product of the minimum number of red, green, and blue cubes\n * required for the game to be possible. This means finding the maximum count\n * for each color across all sets in the game.\n *\n * @param sets_string The string containing all sets for a game (e.g., \"3 blue,\n * 4 red; 1 red, ...\").\n * @param game_id The ID of the current game (used for error\n * reporting/debugging).\n * @return The power of the game (min_red * min_green * min_blue).\n */\nlong long calculate_game_power(char *sets_string, int game_id) {\n  char *set_token;\n  char *rest_of_sets_ptr; // For strtok_r state\n\n  // Initialize minimum required cubes for the game to 0\n  // These will store the maximum observed count for each color across all sets\n  GameMinCubes min_required_cubes = {0, 0, 0};\n\n  // Tokenize the sets string by semicolons to get individual sets\n  set_token = strtok_r(sets_string, \";\", &rest_of_sets_ptr);\n  while (set_token != NULL) {\n    // Process each set to get its cube counts\n    SetCubes current_set_cubes = process_set(set_token);\n\n    // Update the minimum required cubes for the game if current set has higher\n    // counts This effectively finds the maximum count of each color across all\n    // sets\n    if (current_set_cubes.red > min_required_cubes.red) {\n      min_required_cubes.red = current_set_cubes.red;\n    }\n    if (current_set_cubes.green > min_required_cubes.green) {\n      min_required_cubes.green = current_set_cubes.green;\n    }\n    if (current_set_cubes.blue > min_required_cubes.blue) {\n      min_required_cubes.blue = current_set_cubes.blue;\n    }\n\n    // Get the next set\n    set_token = strtok_r(NULL, \";\", &rest_of_sets_ptr);\n  }\n\n  // Calculate the power of the game: product of the maximum observed counts\n  return (long long)min_required_cubes.red * min_required_cubes.green *\n         min_required_cubes.blue;\n}\n\n/**\n * @brief Parses a game line to extract the game ID and the sets string.\n *\n * @param line_copy A mutable copy of the full game line. This string will be\n * modified.\n * @param game_id_out Pointer to an integer where the extracted game ID will be\n * stored.\n * @return A pointer to the start of the sets string (after \"Game X:\"), or NULL\n * on error.\n */\nchar *parse_game_line(char *line_copy, int *game_id_out) {\n  char *token;\n  char *game_id_end_ptr; // For strtok_r state\n\n  // Extract the \"Game X\" part\n  token = strtok_r(line_copy, \":\", &game_id_end_ptr);\n  if (token == NULL) {\n    return NULL; // Error: No game ID part found\n  }\n\n  // Skip \"Game \" and convert the rest to an integer\n  *game_id_out = atoi(token + strlen(\"Game \"));\n\n  // Get the rest of the string containing the sets\n  // Using an empty string as delimiter for strtok_r effectively gets the rest\n  // of the string\n  return strtok_r(NULL, \"\", &game_id_end_ptr);\n}\n\nint main() {\n  FILE *file;\n  char line[512]; // Assuming a max line length of 511 characters + null\n                  // terminator\n  long long total_power_sum = 0; // Changed to long long for sum of powers\n\n  // Open the input file\n  // Ensure 'input.txt' is in the same directory as your compiled executable\n  file = fopen(\"input.txt\", \"r\");\n  if (file == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  // Read the file line by line\n  while (fgets(line, sizeof(line), file) != NULL) {\n    // Remove trailing newline character if present\n    line[strcspn(line, \"\\n\")] = 0;\n\n    // Create a mutable copy of the line for strtok_r to modify\n    char *line_copy = strdup(line);\n    if (line_copy == NULL) {\n      perror(\"Failed to duplicate line\");\n      fclose(file);\n      return 1;\n    }\n\n    int game_id = 0;\n    char *sets_string = NULL;\n\n    // Parse the game line to get ID and sets string\n    sets_string = parse_game_line(line_copy, &game_id);\n\n    if (sets_string == NULL) {\n      fprintf(stderr, \"Error parsing line: %s\\n\", line);\n      free(line_copy);\n      continue; // Skip to the next line\n    }\n\n    // Calculate the power of the current game\n    total_power_sum += calculate_game_power(sets_string, game_id);\n\n    free(line_copy); // Free the duplicated line for the current iteration\n  }\n\n  fclose(file); // Close the file after processing all lines\n\n  printf(\"Sum of the powers of all games: %lld\\n\",\n         total_power_sum); // Use %lld for long long\n\n  return 0;\n}\n\n```",
      "excerpt": "Progress and solutions for Day 2 of the Advent of Code 2023 programming challenge, covering both Part 1 and Part 2.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-08-17T11:50:15.189Z"
    },
    {
      "id": "101-advent-of-code-2023-day-4-md",
      "slug": "101-advent-of-code/2023/day-4",
      "filepath": "101-ADVENT OF CODE/2023/Day 4.md",
      "folder": "101-ADVENT OF CODE/2023",
      "filename": "Day 4.md",
      "frontmatter": {
        "title": "Day 4",
        "date": "2025-08-17",
        "tags": [
          "advent-of-code",
          "aoc2023",
          "programming",
          "puzzles",
          "coding-challenge",
          "day4"
        ],
        "category": "101-ADVENT OF CODE/2023",
        "description": "Solutions and progress for the Day 4 puzzles of the 2023 Advent of Code programming challenge."
      },
      "content": "### PART 1\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n    return 1;\n  }\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  char line[1028];\n  int total_points = 0;\n\n  while (fgets(line, sizeof(line), fptr)) {\n    line[strcspn(line, \"\\n\")] = 0;\n\n    char *line_copy = strdup(line); // Create a copy for strtok\n    if (!line_copy) {\n      // Handle memory allocation error\n      perror(\"Memory allocation failed\");\n      fclose(fptr);\n      return 1;\n    }\n\n    // Split the line into winning and my numbers strings\n    char *winning_numbers_str = strtok(line_copy, \"|\");\n    char *my_numbers_str = strtok(NULL, \"|\");\n\n    // Skip \"Card X:\" part\n    strtok(winning_numbers_str, \":\");\n    winning_numbers_str = strtok(NULL, \":\");\n\n    // Arrays to hold the numbers (assuming max 20 numbers for safety)\n    int winning_numbers[50];\n    int my_numbers[50];\n    int winning_count = 0;\n    int my_count = 0;\n\n    // Populate winning_numbers array\n    char *token = strtok(winning_numbers_str, \" \");\n    while (token != NULL) {\n      winning_numbers[winning_count++] = atoi(token);\n      token = strtok(NULL, \" \");\n    }\n\n    // Populate my_numbers array\n    token = strtok(my_numbers_str, \" \");\n    while (token != NULL) {\n      my_numbers[my_count++] = atoi(token);\n      token = strtok(NULL, \" \");\n    }\n\n    int matches_per_card = 0;\n    for (int i = 0; i < my_count; i++) {\n      for (int j = 0; j < winning_count; j++) {\n        if (my_numbers[i] == winning_numbers[j]) {\n          matches_per_card++;\n        }\n      }\n    }\n\n    int card_points = 0;\n    if (matches_per_card > 0) {\n      // card_points = (int)pow(2, matches_per_card - 1);\n      card_points = 1 << (matches_per_card - 1);\n    }\n\n    total_points += card_points;\n\n    free(line_copy);\n  }\n  fclose(fptr);\n\n  printf(\"Total points: %d\\n\", total_points);\n\n  return 0;\n}\n\n```\n\n### PART 2\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint countMatches(int *winning_numbers, int winning_count, int *my_numbers,\n                 int my_count);\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n    return 1;\n  }\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  char ch;\n  int lineCount = 0;\n  while ((ch = fgetc(fptr)) != EOF) {\n    if (ch == '\\n') {\n      lineCount++;\n    }\n  }\n  rewind(fptr); // Rewind file pointer\n\n  int cardCopies[lineCount];\n  for (int i = 0; i < lineCount; i++) {\n    cardCopies[i] = 1; // Initialize with 1 copy\n  }\n\n  char line[1028];\n\n  while (fgets(line, sizeof(line), fptr)) {\n    line[strcspn(line, \"\\n\")] = 0; // Remove newline\n\n    char *line_copy = strdup(line); // Copy for strtok\n    if (!line_copy) {\n      perror(\"Memory allocation failed\");\n      fclose(fptr);\n      return 1;\n    }\n\n    char *card_and_winning_str = strtok(line_copy, \"|\");\n    char *my_numbers_str_raw = strtok(NULL, \"|\");\n\n    char *card_part = strtok(card_and_winning_str, \":\");\n    char *winning_numbers_str_raw = strtok(NULL, \":\");\n\n    int cardIndex = -1;\n    if (card_part != NULL) {\n      char *index_str = strchr(card_part, ' ');\n      if (index_str != NULL && *(index_str + 1) != '\\0') {\n        index_str++;\n        cardIndex = atoi(index_str);\n      }\n    }\n\n    if (cardIndex == -1 || cardIndex < 1 || cardIndex > lineCount) {\n      fprintf(stderr, \"Error: Invalid card index %d\\n\", cardIndex);\n      free(line_copy);\n      fclose(fptr);\n      return 1;\n    }\n    int currentCardArrayIndex = cardIndex - 1; // 0-based index\n\n    int winning_numbers_arr[50];\n    int my_numbers_arr[50];\n    int winning_count = 0;\n    int my_count = 0;\n\n    // Copies for independent strtok parsing\n    char *winning_numbers_copy_for_parsing = NULL;\n    if (winning_numbers_str_raw != NULL) {\n      winning_numbers_copy_for_parsing = strdup(winning_numbers_str_raw);\n      if (!winning_numbers_copy_for_parsing) {\n        perror(\"Memory allocation failed\");\n        free(line_copy);\n        fclose(fptr);\n        return 1;\n      }\n    }\n\n    char *my_numbers_copy_for_parsing = NULL;\n    if (my_numbers_str_raw != NULL) {\n      my_numbers_copy_for_parsing = strdup(my_numbers_str_raw);\n      if (!my_numbers_copy_for_parsing) {\n        perror(\"Memory allocation failed\");\n        free(line_copy);\n        free(winning_numbers_copy_for_parsing);\n        fclose(fptr);\n        return 1;\n      }\n    }\n\n    char *token = strtok(winning_numbers_copy_for_parsing, \" \");\n    while (token != NULL && winning_count < 50) {\n      if (strlen(token) > 0) {\n        winning_numbers_arr[winning_count++] = atoi(token);\n      }\n      token = strtok(NULL, \" \");\n    }\n\n    token = strtok(my_numbers_copy_for_parsing, \" \");\n    while (token != NULL && my_count < 50) {\n      if (strlen(token) > 0) {\n        my_numbers_arr[my_count++] = atoi(token);\n      }\n      token = strtok(NULL, \" \");\n    }\n\n    int matches = countMatches(winning_numbers_arr, winning_count,\n                               my_numbers_arr, my_count);\n\n    int num_current_card_copies = cardCopies[currentCardArrayIndex];\n\n    for (int i = 1; i <= matches; i++) {\n      if (currentCardArrayIndex + i < lineCount) {\n        cardCopies[currentCardArrayIndex + i] += num_current_card_copies;\n      }\n    }\n\n    // Free duplicated strings\n    free(line_copy);\n    free(winning_numbers_copy_for_parsing);\n    free(my_numbers_copy_for_parsing);\n  }\n  fclose(fptr);\n\n  int total_cards_part2 = 0;\n  for (int i = 0; i < lineCount; i++) {\n    total_cards_part2 += cardCopies[i];\n  }\n  printf(\"Total : %d\\n\", total_cards_part2);\n\n  return 0;\n}\n\nint countMatches(int *winning_numbers, int winning_count, int *my_numbers,\n                 int my_count) {\n  int matches = 0;\n  for (int i = 0; i < winning_count; i++) {\n    for (int j = 0; j < my_count; j++) {\n      if (winning_numbers[i] == my_numbers[j]) {\n        matches++;\n      }\n    }\n  }\n  return matches;\n}\n\n```",
      "excerpt": "Solutions and progress for the Day 4 puzzles of the 2023 Advent of Code programming challenge.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-08-17T11:51:00.530Z"
    },
    {
      "id": "101-advent-of-code-2023-day-5-md",
      "slug": "101-advent-of-code/2023/day-5",
      "filepath": "101-ADVENT OF CODE/2023/Day 5.md",
      "folder": "101-ADVENT OF CODE/2023",
      "filename": "Day 5.md",
      "frontmatter": {
        "title": "Day 5",
        "date": "2025-08-17",
        "tags": [
          "advent-of-code",
          "aoc-2023",
          "coding-challenges",
          "programming",
          "puzzle-solving",
          "algorithms",
          "day-5"
        ],
        "category": "101-ADVENT OF CODE/2023",
        "description": "Progress tracking and scratchpad for the Day 5 puzzle of the Advent of Code 2023 programming challenge."
      },
      "content": "### PART 1\n```python\ndef lookup(thing, mapping):\n    \"\"\"\n    Finds the mapped value for a given 'thing' based on a list of maps.\n    \"\"\"\n    for dest_start, src_start, length in mapping:\n        if src_start <= thing < src_start + length:\n            return dest_start + (thing - src_start)\n    return thing\n\ndef parse_input_file(filepath):\n    \"\"\"\n    Parses the input file to extract seeds and all mapping tables.\n    \"\"\"\n    with open(filepath) as f:\n        data = f.read().strip()\n\n    sections = data.split('\\n\\n')\n    \n    # Parse seeds\n    seeds_line = sections[0]\n    seed_numbers = [int(num) for num in seeds_line.split(': ')[1].split()]\n    \n    # Parse maps\n    parsed_maps = []\n    for section in sections[1:]:\n        lines = section.split('\\n')[1:] # Skip the \"map:\" line\n        current_map = []\n        for line in lines:\n            current_map.append(tuple(map(int, line.split())))\n        parsed_maps.append(current_map)\n\n    return seed_numbers, parsed_maps\n\ndef main():\n    \"\"\"\n    Main function to run the optimization logic.\n    \"\"\"\n    seed_array, maps = parse_input_file(\"input.txt\")\n    print(f\"Seeds: {seed_array}\")\n\n    # The most crucial optimization: Process seeds by ranges.\n    # We no longer generate a massive list of individual seeds.\n    final_min = float('inf')\n\n    # Iterate over the seed ranges from PART B\n    for i in range(0, len(seed_array), 2):\n        start_seed = seed_array[i]\n        range_length = seed_array[i+1]\n        \n        # Iterate through each seed in the current range\n        for j in range(start_seed, start_seed + range_length):\n            current_value = j\n            for mapping in maps:\n                current_value = lookup(current_value, mapping)\n            \n            if current_value < final_min:\n                final_min = current_value\n\n    print(f\"\\nFinal minimum location: {final_min}\")\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n### PART 2\n???",
      "excerpt": "Progress tracking and scratchpad for the Day 5 puzzle of the Advent of Code 2023 programming challenge.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-08-17T11:53:40.708Z"
    },
    {
      "id": "101-advent-of-code-2023-day-6-md",
      "slug": "101-advent-of-code/2023/day-6",
      "filepath": "101-ADVENT OF CODE/2023/Day 6.md",
      "folder": "101-ADVENT OF CODE/2023",
      "filename": "Day 6.md",
      "frontmatter": {
        "title": "Day 6",
        "date": "2025-08-17",
        "tags": [
          "advent-of-code",
          "aoc2023",
          "day6",
          "coding-challenge",
          "programming",
          "puzzle-solving"
        ],
        "category": "101-ADVENT OF CODE/2023",
        "description": "Progress and solution notes for Part 1 of the Day 6 puzzle from Advent of Code 2023."
      },
      "content": "### PART 1\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n  long int time = 48876981;\n  long int distance = 255128811171623;\n\n  int count = 0;\n  for (long int j = 0; j <= time; j++) {\n    long int mydist = j * (time - j);\n    if (mydist > distance)\n      count++;\n  }\n\n  printf(\"%d \\n\", count);\n  return 0;\n}\n```",
      "excerpt": "Progress and solution notes for Part 1 of the Day 6 puzzle from Advent of Code 2023.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-08-17T11:53:28.361Z"
    },
    {
      "id": "101-advent-of-code-2023-day-7-md",
      "slug": "101-advent-of-code/2023/day-7",
      "filepath": "101-ADVENT OF CODE/2023/Day 7.md",
      "folder": "101-ADVENT OF CODE/2023",
      "filename": "Day 7.md",
      "frontmatter": {
        "title": "Day 7",
        "date": "2025-08-17",
        "tags": [
          "adventofcode",
          "aoc2023",
          "programming",
          "puzzles",
          "codingchallenge",
          "day7"
        ],
        "category": "101-ADVENT OF CODE/2023",
        "description": "Solutions and progress for Day 7 of the Advent of Code 2023 programming challenge."
      },
      "content": "### PART 1\n```c\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DELIMITERS \" \"\n#define EXCEPTION_FORMAT \"Error: Format.\\n\"\n#define HAND_SIZE 5\n#define PLAYER_LIST_CAPACITY 1024\n\nenum Card {\n  CARD_TWO,\n  CARD_THREE,\n  CARD_FOUR,\n  CARD_FIVE,\n  CARD_SIX,\n  CARD_SEVEN,\n  CARD_EIGHT,\n  CARD_NINE,\n  CARD_TEN,\n  CARD_JACK,\n  CARD_QUEEN,\n  CARD_KING,\n  CARD_ACE,\n  CARD_NONE\n};\nstruct Hand {\n  int frequency[CARD_NONE];\n  int count;\n  int max_frequency;\n};\n\nenum HandType {\n  HAND_TYPE_HIGH_CARD,\n  HAND_TYPE_ONE_PAIR,\n  HAND_TYPE_TWO_PAIR,\n  HAND_TYPE_THREE_OF_A_KIND,\n  HAND_TYPE_FULL_HOUSE,\n  HAND_TYPE_FOUR_OF_A_KIND,\n  HAND_TYPE_FIVE_OF_A_KIND,\n  HAND_TYPE_NONE\n};\n\nstruct Player {\n  enum Card cards[HAND_SIZE];\n  enum HandType handType;\n  int bid;\n};\n\nstruct PlayerList {\n  struct Player items[PLAYER_LIST_CAPACITY];\n  int count;\n};\n\ntypedef const void *Object;\ntypedef char *String;\ntypedef enum Card Card;\ntypedef enum HandType HandType;\ntypedef struct Hand *Hand;\ntypedef struct Player *Player;\ntypedef struct PlayerList *PlayerList;\n\nCard getCardFromString(char symbol) {\n  switch (symbol) {\n  case '2':\n    return CARD_TWO;\n  case '3':\n    return CARD_THREE;\n  case '4':\n    return CARD_FOUR;\n  case '5':\n    return CARD_FIVE;\n  case '6':\n    return CARD_SIX;\n  case '7':\n    return CARD_SEVEN;\n  case '8':\n    return CARD_EIGHT;\n  case '9':\n    return CARD_NINE;\n  case 'T':\n    return CARD_TEN;\n  case 'J':\n    return CARD_JACK;\n  case 'Q':\n    return CARD_QUEEN;\n  case 'K':\n    return CARD_KING;\n  case 'A':\n    return CARD_ACE;\n  default:\n    return CARD_NONE; // Invalid card\n  }\n}\n\nHandType hand_get_type(Hand hand) {\n  if (hand->max_frequency == 5) {\n    return HAND_TYPE_FIVE_OF_A_KIND;\n  } else if (hand->max_frequency == 4) {\n    return HAND_TYPE_FOUR_OF_A_KIND;\n  } else if (hand->max_frequency == 3 && hand->count == 2) {\n    return HAND_TYPE_FULL_HOUSE;\n  } else if (hand->max_frequency == 3) {\n    return HAND_TYPE_THREE_OF_A_KIND;\n  } else if (hand->max_frequency == 2 && hand->count == 3) {\n    return HAND_TYPE_TWO_PAIR;\n  } else if (hand->max_frequency == 2) {\n    return HAND_TYPE_ONE_PAIR;\n  } else {\n    return HAND_TYPE_HIGH_CARD;\n  }\n}\n\nint player_compare(Object left, Object right) {\n  if (!left && !right) {\n    return 0;\n  }\n\n  if (!left) {\n    return -1;\n  }\n\n  if (!right) {\n    return 1;\n  }\n\n  const struct Player *leftPlayer = left;\n  const struct Player *rightPlayer = right;\n  int handDifference = rightPlayer->handType - leftPlayer->handType;\n\n  if (handDifference) {\n    return handDifference;\n  }\n\n  for (int i = 0; i < HAND_SIZE; i++) {\n    int cardDifference = rightPlayer->cards[i] - leftPlayer->cards[i];\n    if (cardDifference) {\n      return cardDifference;\n    }\n  }\n\n  return 0;\n}\n\nvoid player_list_sort(PlayerList instance) {\n  qsort(instance->items, instance->count, sizeof *instance->items,\n        player_compare);\n}\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n    return 1;\n  }\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  char line[1028];\n\n  struct PlayerList players;\n  players.count = 0;\n\n  while (fgets(line, sizeof(line), fptr)) {\n\n    String cards = strtok(line, \" \");\n    char *bid = strtok(NULL, \" \");\n\n    struct Hand hand = {0};\n    Player player = players.items + players.count;\n    players.count++;\n\n    for (int i = 0; i < HAND_SIZE; i++) {\n      Card drawnCard = getCardFromString(cards[i]);\n      if (drawnCard == CARD_NONE) {\n        fprintf(stderr, EXCEPTION_FORMAT);\n        fclose(fptr);\n        return 1;\n      }\n      // hand add\n      int frequency = hand.frequency[drawnCard];\n      if (!frequency) {\n        hand.count++;\n      }\n      frequency++;\n\n      hand.frequency[drawnCard] = frequency;\n\n      if (frequency > hand.max_frequency) {\n        hand.max_frequency = frequency;\n      }\n\n      player->cards[i] = drawnCard;\n    }\n\n    HandType handType = hand_get_type(&hand);\n\n    if (!bid || handType == HAND_TYPE_NONE) {\n      fprintf(stderr, EXCEPTION_FORMAT);\n\n      return 1;\n    }\n    player->handType = handType;\n    player->bid = atoi(bid);\n  }\n\n  player_list_sort(&players);\n  long sum = 0;\n\n  for (int i = 0; i < players.count; i++) {\n    sum += (players.count - i) * players.items[i].bid;\n  }\n\n  printf(\"%ld\\n\", sum);\n  return 0;\n}\n\n```\n\n### PART 2\n```c\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define EXCEPTION_FORMAT \"Error: Format.\\n\"\n#define HAND_SIZE 5\n#define PLAYER_LIST_CAPACITY 1024\n\nenum Card {\n  CARD_JOKER,\n  CARD_TWO,\n  CARD_THREE,\n  CARD_FOUR,\n  CARD_FIVE,\n  CARD_SIX,\n  CARD_SEVEN,\n  CARD_EIGHT,\n  CARD_NINE,\n  CARD_TEN,\n  CARD_QUEEN,\n  CARD_KING,\n  CARD_ACE,\n  CARD_NONE\n};\nstruct Hand {\n  int frequency[CARD_NONE];\n  int count;\n  int max_frequency;\n};\n\nenum HandType {\n  HAND_TYPE_HIGH_CARD,\n  HAND_TYPE_ONE_PAIR,\n  HAND_TYPE_TWO_PAIR,\n  HAND_TYPE_THREE_OF_A_KIND,\n  HAND_TYPE_FULL_HOUSE,\n  HAND_TYPE_FOUR_OF_A_KIND,\n  HAND_TYPE_FIVE_OF_A_KIND,\n  HAND_TYPE_NONE\n};\n\nstruct Player {\n  enum Card cards[HAND_SIZE];\n  enum HandType handType;\n  int bid;\n};\n\nstruct PlayerList {\n  struct Player items[PLAYER_LIST_CAPACITY];\n  int count;\n};\n\ntypedef const void *Object;\ntypedef char *String;\ntypedef enum Card Card;\ntypedef enum HandType HandType;\ntypedef struct Hand *Hand;\ntypedef struct Player *Player;\ntypedef struct PlayerList *PlayerList;\n\nCard getCardFromString(char symbol) {\n  switch (symbol) {\n  case '2':\n    return CARD_TWO;\n  case '3':\n    return CARD_THREE;\n  case '4':\n    return CARD_FOUR;\n  case '5':\n    return CARD_FIVE;\n  case '6':\n    return CARD_SIX;\n  case '7':\n    return CARD_SEVEN;\n  case '8':\n    return CARD_EIGHT;\n  case '9':\n    return CARD_NINE;\n  case 'T':\n    return CARD_TEN;\n  case 'J':\n    return CARD_JOKER;\n  case 'Q':\n    return CARD_QUEEN;\n  case 'K':\n    return CARD_KING;\n  case 'A':\n    return CARD_ACE;\n  default:\n    return CARD_NONE; // Invalid card\n  }\n}\n\nHandType hand_get_type(Hand hand) {\n  int jokers = hand->frequency[CARD_JOKER];\n\n  // Find the highest frequency among non-joker cards.\n  int max_freq_no_jokers = 0;\n  for (int i = 0; i < CARD_NONE; i++) {\n    if (i == CARD_JOKER)\n      continue;\n    if (hand->frequency[i] > max_freq_no_jokers) {\n      max_freq_no_jokers = hand->frequency[i];\n    }\n  }\n\n  // The best possible group size is the max frequency of any card plus the\n  // number of jokers.\n  int effective_max_freq = max_freq_no_jokers + jokers;\n\n  if (effective_max_freq == 5) {\n    return HAND_TYPE_FIVE_OF_A_KIND;\n  }\n  if (effective_max_freq == 4) {\n    return HAND_TYPE_FOUR_OF_A_KIND;\n  }\n\n  // If we have jokers, they will merge with another group, reducing the number\n  // of distinct card groups.\n  int distinct_groups = hand->count;\n  if (jokers > 0) {\n    distinct_groups--;\n  }\n\n  if (effective_max_freq == 3) {\n    // A group of 3 and a group of 2 (e.g., KKKQQ or T55J5).\n    if (distinct_groups == 2) {\n      return HAND_TYPE_FULL_HOUSE;\n    }\n    // A group of 3 and two singles (e.g., KKKQJ).\n    return HAND_TYPE_THREE_OF_A_KIND;\n  }\n\n  if (effective_max_freq == 2) {\n    // Two groups of 2 (e.g., KKQQJ).\n    if (distinct_groups == 3) {\n      return HAND_TYPE_TWO_PAIR;\n    }\n    // One group of 2 (e.g., KKQJ2).\n    return HAND_TYPE_ONE_PAIR;\n  }\n\n  return HAND_TYPE_HIGH_CARD;\n}\n\nint player_compare(Object left, Object right) {\n  if (!left && !right) {\n    return 0;\n  }\n\n  if (!left) {\n    return -1;\n  }\n\n  if (!right) {\n    return 1;\n  }\n\n  const struct Player *leftPlayer = left;\n  const struct Player *rightPlayer = right;\n  int handDifference = rightPlayer->handType - leftPlayer->handType;\n\n  if (handDifference) {\n    return handDifference;\n  }\n\n  for (int i = 0; i < HAND_SIZE; i++) {\n    int cardDifference = rightPlayer->cards[i] - leftPlayer->cards[i];\n\n    if (cardDifference) {\n      return cardDifference;\n    }\n  }\n\n  return 0;\n}\n\nvoid player_list_sort(PlayerList instance) {\n  qsort(instance->items, instance->count, sizeof *instance->items,\n        player_compare);\n}\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n    return 1;\n  }\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  char line[1028];\n\n  struct PlayerList players;\n  players.count = 0;\n\n  while (fgets(line, sizeof(line), fptr)) {\n\n    String cards = strtok(line, \" \");\n    char *bid = strtok(NULL, \" \");\n\n    struct Hand hand = {0};\n    Player player = players.items + players.count;\n    players.count++;\n\n    for (int i = 0; i < HAND_SIZE; i++) {\n      Card drawnCard = getCardFromString(cards[i]);\n      if (drawnCard == CARD_NONE) {\n        fprintf(stderr, EXCEPTION_FORMAT);\n        fclose(fptr);\n        return 1;\n      }\n      // hand add\n      int frequency = hand.frequency[drawnCard];\n      if (!frequency) {\n        hand.count++;\n      }\n      frequency++;\n\n      hand.frequency[drawnCard] = frequency;\n\n      if (frequency > hand.max_frequency) {\n        hand.max_frequency = frequency;\n      }\n\n      player->cards[i] = drawnCard;\n    }\n\n    HandType handType = hand_get_type(&hand);\n\n    if (!bid || handType == HAND_TYPE_NONE) {\n      fprintf(stderr, EXCEPTION_FORMAT);\n\n      return 1;\n    }\n    player->handType = handType;\n    player->bid = atoi(bid);\n  }\n\n  player_list_sort(&players);\n  long sum = 0;\n\n  for (int i = 0; i < players.count; i++) {\n    sum += (players.count - i) * players.items[i].bid;\n  }\n\n  printf(\"%ld\\n\", sum);\n  return 0;\n}\n\n```",
      "excerpt": "Solutions and progress for Day 7 of the Advent of Code 2023 programming challenge.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-08-17T11:54:23.464Z"
    },
    {
      "id": "101-advent-of-code-2023-day-8-md",
      "slug": "101-advent-of-code/2023/day-8",
      "filepath": "101-ADVENT OF CODE/2023/Day 8.md",
      "folder": "101-ADVENT OF CODE/2023",
      "filename": "Day 8.md",
      "frontmatter": {
        "title": "Day 8",
        "date": "2025-08-17",
        "tags": [
          "advent-of-code",
          "aoc-2023",
          "coding-challenge",
          "puzzles",
          "algorithms",
          "day-8"
        ],
        "category": "101-ADVENT OF CODE/2023",
        "description": "Solutions and progress for the Day 8 challenge of the 2023 Advent of Code programming event."
      },
      "content": "### PART 1\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Define a struct to hold the key and the two values\ntypedef struct {\n  char key[4];\n  char left[4];\n  char right[4];\n} Node;\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n    return 1;\n  }\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  char line[1028];\n  Node *map = NULL;\n  int num_nodes = 0;\n\n  // Read and store the direction line (first line)\n  char *token = fgets(line, sizeof(line), fptr);\n  if (token) {\n    line[strcspn(line, \"\\n\")] = 0; // Remove trailing newline\n    printf(\"Direction: %s\\n\", line);\n  }\n  char *direction = malloc(1024 * sizeof(char));\n  strcpy(direction, token);\n\n  // Skip the empty line\n  fgets(line, sizeof(line), fptr);\n\n  // Loop through the rest of the lines and parse them\n  while (fgets(line, sizeof(line), fptr)) {\n    if (line[0] == '\\n') {\n      continue; // Skip any empty lines\n    }\n\n    // Dynamically resize the array to store the new node\n    map = realloc(map, sizeof(Node) * (num_nodes + 1));\n    if (map == NULL) {\n      perror(\"Memory allocation failed\");\n      fclose(fptr);\n      // Free any previously allocated memory\n      for (int i = 0; i < num_nodes; i++) {\n        free(map);\n      }\n      return 1;\n    }\n\n    // Use a comprehensive set of delimiters\n    char *key_token = strtok(line, \" =(),\\n\");\n    char *left_token = strtok(NULL, \" =(),\\n\");\n    char *right_token = strtok(NULL, \" =(),\\n\");\n\n    // Ensure all three parts are found before storing\n    if (key_token && left_token && right_token) {\n      strcpy(map[num_nodes].key, key_token);\n      strcpy(map[num_nodes].left, left_token);\n      strcpy(map[num_nodes].right, right_token);\n      num_nodes++;\n    }\n  }\n\n  char *current = \"AAA\";\n  int j = 0;\n  int steps = 0;\n  // char currentDir = direction[j];\n  // printf(\"%c\\n\", currentDir);\n  while (strcmp(current, \"ZZZ\") != 0) {\n    for (int i = 0; i < num_nodes; i++) {\n      if (strcmp(map[i].key, current) == 0) {\n\n        if (j >= strlen(direction)) {\n          j = 0;\n        }\n        char currentDir = direction[j];\n\n        if (currentDir == 'L') {\n          current = map[i].left;\n        } else if (currentDir == 'R') {\n          current = map[i].right;\n        }\n        j++;\n        steps++;\n        printf(\"%d\\n\", steps);\n        break;\n      }\n    }\n  }\n  printf(\"Steps: %d\\n\", steps);\n  fclose(fptr);\n\n  // Clean up dynamically allocated memory\n  free(map);\n\n  return 0;\n}\n****\n```\n### PART 2\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Define a struct to hold the key and the two values\ntypedef struct {\n  char key[4];\n  char left[4];\n  char right[4];\n} Node;\n\n// FIND NODE\nNode *find_node(Node *map, int num_nodes, const char *key) {\n  for (int i = 0; i < num_nodes; i++) {\n    if (strcmp(map[i].key, key) == 0) {\n      return &map[i];\n    }\n  }\n  return NULL;\n}\n\nlong long gcd(long long a, long long b) {\n  while (b) {\n    long long temp = a % b;\n    a = b;\n    b = temp;\n  }\n  return a;\n}\n\nlong long lcm(long long a, long long b) {\n  if (a == 0 || b == 0)\n    return 0;\n  return (a * b) / gcd(a, b);\n}\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    fprintf(stderr, \"Usage: %s <input_file>\\n\", argv[0]);\n    return 1;\n  }\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  char line[1028];\n  Node *map = NULL;\n  int num_nodes = 0;\n  char direction[1024];\n\n  if (fgets(line, sizeof(line), fptr)) {\n    line[strcspn(line, \"\\n\")] = 0;\n    strcpy(direction, line);\n  } else {\n    fclose(fptr);\n    return 1;\n  }\n\n  fgets(line, sizeof(line), fptr);\n\n  // Loop through the rest of the lines and parse them\n  while (fgets(line, sizeof(line), fptr)) {\n    if (line[0] == '\\n')\n      continue;\n\n    map = realloc(map, sizeof(Node) * (num_nodes + 1));\n    if (map == NULL) {\n      perror(\"Memory allocation failed\");\n      fclose(fptr);\n      free(map);\n      return 1;\n    }\n\n    char *key_token = strtok(line, \" =(),\\n\");\n    char *left_token = strtok(NULL, \" =(),\\n\");\n    char *right_token = strtok(NULL, \" =(),\\n\");\n\n    if (key_token && left_token && right_token) {\n      strcpy(map[num_nodes].key, key_token);\n      strcpy(map[num_nodes].left, left_token);\n      strcpy(map[num_nodes].right, right_token);\n      num_nodes++;\n    }\n  }\n  fclose(fptr);\n\n  // 1. Find all starting nodes (ending with 'A')\n  const char *start_nodes[num_nodes];\n  int num_start_nodes = 0;\n  for (int i = 0; i < num_nodes; i++) {\n    if (map[i].key[2] == 'A') {\n      start_nodes[num_start_nodes++] = map[i].key;\n    }\n  }\n\n  long long steps_to_z[num_start_nodes];\n  int direction_length = strlen(direction);\n\n  // 2. Calculate steps for each path to reach a 'Z' ending node\n  for (int i = 0; i < num_start_nodes; i++) {\n    const char *current_key = start_nodes[i];\n    long long steps = 0;\n\n    while (current_key[2] != 'Z') {\n      Node *current_node = find_node(map, num_nodes, current_key);\n      if (!current_node) {\n        fprintf(stderr, \"Error: Node '%s' not found!\\n\", current_key);\n        break;\n      }\n\n      char current_dir = direction[steps % direction_length];\n\n      if (current_dir == 'L') {\n        current_key = current_node->left;\n      } else if (current_dir == 'R') {\n        current_key = current_node->right;\n      }\n      steps++;\n    }\n    steps_to_z[i] = steps;\n  }\n\n  // 3. Find the LCM of all path lengths\n  long long total_steps = steps_to_z[0];\n  for (int i = 1; i < num_start_nodes; i++) {\n    total_steps = lcm(total_steps, steps_to_z[i]);\n  }\n\n  printf(\"Total steps to reach all 'Z' nodes simultaneously: %lld\\n\",\n         total_steps);\n\n  free(map);\n\n  return 0;\n}\n\n```",
      "excerpt": "Solutions and progress for the Day 8 challenge of the 2023 Advent of Code programming event.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-08-17T11:55:09.641Z"
    },
    {
      "id": "101-advent-of-code-2024-day-1-md",
      "slug": "101-advent-of-code/2024/day-1",
      "filepath": "101-ADVENT OF CODE/2024/Day 1.md",
      "folder": "101-ADVENT OF CODE/2024",
      "filename": "Day 1.md",
      "frontmatter": {
        "title": "Day 1",
        "date": "2025-11-13",
        "tags": [
          "python"
        ],
        "category": "101-ADVENT OF CODE/2024"
      },
      "content": "```python\nl1 = []\nl2 = []\ntotal = 0\nwith open(\"input.txt\",\"r\") as file:\n    for line in file.readlines():\n        a = line.strip().split(\"  \")\n        l1.append(int(a[0].strip()))\n        l2.append(int(a[1].strip()))\n        l1.sort()\n        l2.sort()\nfor i in l1:\n    count = l2.count(i)\n    val = count * i\n    total += val\nprint(total)\n\n```\n\n\n```python\nl1 = []\nl2 = []\ntotal = 0\nwith open(\"input.txt\",\"r\") as file:\n    for line in file.readlines():\n        a = line.strip().split(\"  \")\n        l1.append(int(a[0].strip()))\n        l2.append(int(a[1].strip()))\n        l1.sort()\n        l2.sort()\nfor i in l1:\n    count = l2.count(i)\n    val = count * i\n    total += val\nprint(total)\n\n```",
      "excerpt": "",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-11-13T12:52:50.174Z"
    },
    {
      "id": "101-advent-of-code-2024-day-2-md",
      "slug": "101-advent-of-code/2024/day-2",
      "filepath": "101-ADVENT OF CODE/2024/Day 2.md",
      "folder": "101-ADVENT OF CODE/2024",
      "filename": "Day 2.md",
      "frontmatter": {
        "title": "----------------------------------------------------------------------",
        "date": "2025-11-13",
        "tags": [
          "python"
        ],
        "category": "101-ADVENT OF CODE/2024"
      },
      "content": "\n```python\nimport os\n\ndef is_safe_report(levels):\n    \"\"\"\n    Checks if a list of levels meets the Part 1 safety criteria:\n    1. Strictly monotonic (all increasing or all decreasing).\n    2. All adjacent differences are in [1, 3].\n    \"\"\"\n    if len(levels) < 2:\n        return True # Trivial case: 0 or 1 element is always safe\n\n    is_strictly_increasing = True\n    is_strictly_decreasing = True\n    \n    for i in range(len(levels) - 1):\n        diff = levels[i+1] - levels[i]\n        abs_diff = abs(diff)\n        \n        # CRITERION 2: Check difference constraint (must be 1 to 3 for ALL pairs)\n        if not (1 <= abs_diff <= 3):\n            return False # Failed the difference test immediately\n        \n        # CRITERION 1: Update strict monotonicity flags\n        if diff <= 0:\n            is_strictly_increasing = False\n        \n        if diff >= 0:\n            is_strictly_decreasing = False\n    \n    # Must be EITHER strictly increasing OR strictly decreasing (and passed diff test)\n    return is_strictly_increasing or is_strictly_decreasing\n\n# ----------------------------------------------------------------------\ndef is_part2_safe(report):\n    \"\"\"\n    Checks if a report is safe under Part 2 rules:\n    The original report OR any version with one element removed must be safe by Part 1 rules.\n    \"\"\"\n    # 1. Check if the original report is already safe (covers Part 1 solution)\n    if is_safe_report(report):\n        return True\n\n    # 2. Check every possible sub-report by removing one element\n    for i in range(len(report)):\n        # Create a new list by skipping the element at index i\n        # report[:i] is the left part, report[i+1:] is the right part\n        sub_report = report[:i] + report[i+1:]\n        \n        if is_safe_report(sub_report):\n            return True # Found a safe sub-report, no need to check others\n\n    return False # Neither the original nor any single-removal version was safe\n\ndef solve_part2():\n    safe_reports_count = 0\n    file_path = \"input.txt\" # Ensure your puzzle input is in 'input.txt'\n    \n    try:\n        with open(file_path, 'r') as file:\n            for line in file:\n                cleaned_line = line.strip()\n                if not cleaned_line:\n                    continue\n\n                try:\n                    # Convert the line to a list of integers\n                    levels = [int(x) for x in cleaned_line.split()]\n                except ValueError:\n                    print(f\"Skipping line due to non-integer content: '{cleaned_line}'\")\n                    continue\n                \n                # Check the Part 2 safety rule\n                if is_part2_safe(levels):\n                    safe_reports_count += 1\n\n    except FileNotFoundError:\n        print(f\"Error: Input file '{file_path}' not found.\")\n        return None\n    \n    return safe_reports_count\n\n# --- Run the solution ---\nfinal_answer = solve_part2()\n\nif final_answer is not None:\n    print(f\"The number of Part 2 safe reports is: {final_answer}\")\n\n# --- Example Check (for verification) ---\n# Example from Part 1 description (7 6 4 2 1 and 1 3 6 7 9 were safe)\n# The Part 2 test requires the original report OR a single-removal report to be safe.\n# Let's test the original unsafe examples to see if they become safe in Part 2.\nprint(\"\\n--- Example Verification ---\")\nexample_reports_part2 = [\n    [7, 6, 4, 2, 1],  # Safe in Part 1 -> Safe in Part 2 (Expected: True)\n    [1, 2, 7, 8, 9],  # Unsafe (diff 5). Removing 7 makes [1, 2, 8, 9] (diffs 1, 6, 1) -> Unsafe. Removing 2 makes [1, 7, 8, 9] (diffs 6, 1, 1) -> Unsafe. It might remain Unsafe.\n    [9, 7, 6, 2, 1],  # Unsafe (diff 4). Removing 6 makes [9, 7, 2, 1] (diffs 2, 5, 1) -> Unsafe. Removing 2 makes [9, 7, 6, 1] (diffs 2, 1, 5) -> Unsafe. It might remain Unsafe.\n    [1, 3, 2, 4, 5],  # Unsafe (not monotonic). Removing 3 makes [1, 2, 4, 5] (Safe). -> Safe in Part 2\n    [8, 6, 4, 4, 1],  # Unsafe (diff 0). Removing one 4 makes [8, 6, 4, 1] (Safe). -> Safe in Part 2\n    [1, 3, 6, 7, 9]   # Safe in Part 1 -> Safe in Part 2 (Expected: True)\n]\n\n# We don't have the final example count for Part 2, but let's count our checks.\nexample_part2_safe_count = sum(is_part2_safe(r) for r in example_reports_part2)\n\nprint(f\"Example Part 2 safe count: {example_part2_safe_count} (Expected value depends on which sub-reports become safe)\")\n\n```",
      "excerpt": "",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-11-13T12:53:13.448Z"
    },
    {
      "id": "101-advent-of-code-2024-day-3-md",
      "slug": "101-advent-of-code/2024/day-3",
      "filepath": "101-ADVENT OF CODE/2024/Day 3.md",
      "folder": "101-ADVENT OF CODE/2024",
      "filename": "Day 3.md",
      "frontmatter": {
        "title": "Day 3",
        "date": "2025-11-13",
        "tags": [
          "cpp",
          "include"
        ],
        "category": "101-ADVENT OF CODE/2024"
      },
      "content": "```cpp\n#include <fstream>\n#include <iostream>\n#include <regex>\n#include <string>\n\nint main() {\n  std::ifstream file(\"input.txt\");\n  std::string content;\n  char ch;\n  while (file.get(ch)) {\n    content += ch;\n  }\n\n  std::regex mul_pattern(R\"(mul\\((\\d{1,3}),(\\d{1,3})\\))\");\n  std::smatch match;\n  std::string::const_iterator searchStart(content.cbegin());\n  int part1_sum = 0;\n\n  while (regex_search(searchStart, content.cend(), match, mul_pattern)) {\n    int x = stoi(match[1]);\n    int y = stoi(match[2]);\n    part1_sum += x * y;\n    searchStart = match.suffix().first;\n  }\n  std::cout << \"Part 1: \" << part1_sum << std::endl;\n\n  std::regex full_pattern(R\"(mul\\((\\d{1,3}),(\\d{1,3})\\)|do\\(\\)|don't\\(\\))\");\n  searchStart = content.cbegin();\n  int part2_sum = 0;\n  bool enabled = true;\n\n  while (regex_search(searchStart, content.cend(), match, full_pattern)) {\n    std::string matched = match[0];\n\n    if (matched == \"do()\") {\n      enabled = true;\n    } else if (matched == \"don't()\") {\n      enabled = false;\n    } else if (enabled) {\n      int x = stoi(match[1]);\n      int y = stoi(match[2]);\n      part2_sum += x * y;\n    }\n\n    searchStart = match.suffix().first;\n  }\n\n  std::cout << \"Part 2: \" << part2_sum << std::endl;\n}\n\n```",
      "excerpt": "",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-11-13T12:53:54.035Z"
    },
    {
      "id": "101-advent-of-code-2024-day-4-md",
      "slug": "101-advent-of-code/2024/day-4",
      "filepath": "101-ADVENT OF CODE/2024/Day 4.md",
      "folder": "101-ADVENT OF CODE/2024",
      "filename": "Day 4.md",
      "frontmatter": {
        "title": "Day 4",
        "date": "2025-11-13",
        "tags": [
          "python"
        ],
        "category": "101-ADVENT OF CODE/2024"
      },
      "content": "```python\ngrid = []\nwith open(\"input.txt\", 'r') as f:\n   grid =  [line.strip() for line in f if line.strip()]\n\nR = len(grid)\nC = len(grid[0])\n\ndef isInside(r,c):\n    return 0 <= r < R and 0 <= c < C\n\ndirections = [(0,1),(1,0),(0,-1),(-1,0),(1,1),(1,-1),(-1,1),(-1,-1)]\n\nword = \"XMAS\"\ncount = 0\n\nfor r in range(R):\n    for c in range(C):\n        if grid[r][c] == 'X':\n\n            for dir_r, dir_c in directions:\n                match_x = True\n                for step in range(1,4):\n                    nr,nc = r + dir_r * step, c + dir_c * step\n                    if not isInside(nr,nc) or grid[nr][nc] != word[step]:\n                        match_x = False\n                        break\n                if match_x:\n                    count += 1\n\ndef solve_part2(grid):\n    R = len(grid)\n    C = len(grid[0])\n    count = 0\n\n    # The 4 diagonal offset coordinates (dr, dc)\n    DIAGONALS = [(-1, -1), (-1, 1), (1, -1), (1, 1)] # Top-L, Top-R, Bottom-L, Bottom-R\n\n    for r in range(1, R - 1): # 'A' must be at least one step from the edge\n        for c in range(1, C - 1):\n            \n            if grid[r][c] == 'A':\n                # The 4 surrounding diagonal characters\n                chars = []\n                for dr, dc in DIAGONALS:\n                    chars.append(grid[r + dr][c + dc])\n\n                # The four diagonal characters are at indices 0, 1, 2, 3\n                # chars[0] = Top-Left (TL)\n                # chars[1] = Top-Right (TR)\n                # chars[2] = Bottom-Left (BL)\n                # chars[3] = Bottom-Right (BR)\n                \n                # We need exactly two 'M's and two 'S's\n                if sorted(chars) == ['M', 'M', 'S', 'S']:\n                    \n                    # We only care about the diagonals pairing up:\n                    # 1. TL-BR and TR-BL (M.A.S on one diagonal, S.A.M on the other)\n                    # OR\n                    # 2. TL-TR and BL-BR (M's on top row, S's on bottom, or vice-versa)\n                    \n                    # Combination 1: Diagonal MAS/SAM\n                    # e.g., M-S and S-M pairings\n                    if (chars[0] != chars[3]) and (chars[1] != chars[2]):\n                        count += 1\n                        \n                    # Combination 2: Horizontal M/S rows\n                    # e.g., M-M and S-S pairings\n                    elif (chars[0] == chars[1]) and (chars[2] == chars[3]):\n                        count += 1\n                        \n    return count\n               \nprint(solve_part2(grid))\n\n```",
      "excerpt": "",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-11-13T12:54:24.405Z"
    },
    {
      "id": "101-advent-of-code-2024-day-6-md",
      "slug": "101-advent-of-code/2024/day-6",
      "filepath": "101-ADVENT OF CODE/2024/Day 6.md",
      "folder": "101-ADVENT OF CODE/2024",
      "filename": "Day 6.md",
      "frontmatter": {
        "title": "Day 6",
        "date": "2025-11-13",
        "tags": [
          "cpp",
          "include"
        ],
        "category": "101-ADVENT OF CODE/2024"
      },
      "content": "```cpp\n#include <iostream>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\n// Represents the grid and guard's state\nstruct GuardSim {\n  vector<string> grid;\n  int startRow, startCol, startDir;\n  int rows, cols;\n\n  // Directions: 0: Up, 1: Right, 2: Down, 3: Left\n  // Change in (row, col) for each direction\n  const vector<pair<int, int>> moves = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n\n  // Constructor to parse the input grid\n  GuardSim(const vector<string> &inputGrid) {\n    grid = inputGrid;\n    rows = grid.size();\n    cols = grid[0].size();\n    findStart();\n  }\n\n  // Finds the guard's starting position and direction\n  void findStart() {\n    for (int r = 0; r < rows; ++r) {\n      for (int c = 0; c < cols; ++c) {\n        char ch = grid[r][c];\n        if (ch == '^') {\n          startRow = r;\n          startCol = c;\n          startDir = 0;\n          return;\n        }\n        if (ch == '>') {\n          startRow = r;\n          startCol = c;\n          startDir = 1;\n          return;\n        }\n        if (ch == 'v') {\n          startRow = r;\n          startCol = c;\n          startDir = 2;\n          return;\n        }\n        if (ch == '<') {\n          startRow = r;\n          startCol = c;\n          startDir = 3;\n          return;\n        }\n      }\n    }\n  }\n\n  // Checks if a position is within the grid boundaries\n  bool isOutOfBounds(int r, int c) {\n    return r < 0 || r >= rows || c < 0 || c >= cols;\n  }\n\n  /**\n   * Simulates the guard's path.\n   * detectsLoop:\n   * - If true (for Part 2), returns 1 if a loop is found, 0 otherwise.\n   * - If false (for Part 1), returns the count of visited tiles.\n   */\n  int simulate(bool detectsLoop) {\n    int r = startRow;\n    int c = startCol;\n    int dir = startDir;\n\n    // Set to store visited positions (row, col)\n    set<pair<int, int>> visitedPos;\n\n    // Set to store visited states (row, col, dir) for loop detection\n    set<tuple<int, int, int>> visitedStates;\n\n    // Safety break for very long loops, though state-based detection is primary\n    for (int step = 0; step < 1000000; ++step) {\n\n      if (detectsLoop) {\n        // --- Part 2 Logic: Loop Detection ---\n        tuple<int, int, int> state = {r, c, dir};\n        if (visitedStates.count(state)) {\n          return 1; // Loop detected!\n        }\n        visitedStates.insert(state);\n      } else {\n        // --- Part 1 Logic: Position Counting ---\n        visitedPos.insert({r, c});\n      }\n\n      // 1. Calculate next position\n      int nextR = r + moves[dir].first;\n      int nextC = c + moves[dir].second;\n\n      // 2. Check for exit\n      if (isOutOfBounds(nextR, nextC)) {\n        // Guard exits the grid\n        return detectsLoop ? 0 : visitedPos.size();\n      }\n\n      // 3. Check for obstacle\n      if (grid[nextR][nextC] == '#') {\n        // Turn right\n        dir = (dir + 1) % 4;\n      } else {\n        // Move forward\n        r = nextR;\n        c = nextC;\n      }\n    }\n\n    // Should only be reached if loop detected or safety break hit\n    return detectsLoop ? 1 : visitedPos.size();\n  }\n};\n\nint main() {\n  vector<string> inputGrid;\n  string line;\n\n  cout << \"Paste your puzzle input and press Ctrl+D (Linux/macOS) or Ctrl+Z \"\n          \"(Windows) to end:\"\n       << endl;\n  while (getline(cin, line)) {\n    if (!line.empty()) {\n      inputGrid.push_back(line);\n    }\n  }\n\n  if (inputGrid.empty()) {\n    cerr << \"No input provided!\" << endl;\n    return 1;\n  }\n\n  // --- Part 1 ---\n  GuardSim simPart1(inputGrid);\n  int part1_answer = simPart1.simulate(false);\n  cout << \"-----------------------------------\" << endl;\n  cout << \"Part 1 Answer: \" << part1_answer << endl;\n\n  // --- Part 2 ---\n  int loopFormingObstacles = 0;\n  vector<pair<int, int>> emptyTiles;\n\n  // Find all potential spots to add an obstacle\n  for (int r = 0; r < simPart1.rows; ++r) {\n    for (int c = 0; c < simPart1.cols; ++c) {\n      if (simPart1.grid[r][c] == '.') {\n        emptyTiles.push_back({r, c});\n      }\n    }\n  }\n\n  // Test each empty tile\n  for (const auto &tile : emptyTiles) {\n    // Create a copy of the grid and add the new obstacle\n    vector<string> modifiedGrid = inputGrid;\n    modifiedGrid[tile.first][tile.second] = '#';\n\n    // Run simulation on the modified grid\n    GuardSim simPart2(modifiedGrid);\n    if (simPart2.simulate(true) == 1) {\n      loopFormingObstacles++;\n    }\n  }\n\n  cout << \"Part 2 Answer: \" << loopFormingObstacles << endl;\n  cout << \"-----------------------------------\" << endl;\n\n  return 0;\n}\n\n```",
      "excerpt": "",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-11-13T12:54:45.019Z"
    },
    {
      "id": "101-advent-of-code-2024-day-7-md",
      "slug": "101-advent-of-code/2024/day-7",
      "filepath": "101-ADVENT OF CODE/2024/Day 7.md",
      "folder": "101-ADVENT OF CODE/2024",
      "filename": "Day 7.md",
      "frontmatter": {
        "title": "Day 7",
        "date": "2025-11-13",
        "tags": [
          "python"
        ],
        "category": "101-ADVENT OF CODE/2024"
      },
      "content": "```python\ntotal  = 0\n\ndef concat(a,b):\n    return int(str(a)+str(b))\n\n\ndef canReach(currentTotal,remaining,target):\n    if len(remaining)==0:\n        return currentTotal==target\n    \n    next = remaining[0]\n    rest = remaining[1:]\n    \n    withAdd = canReach(currentTotal+next,rest,target)\n    withMul = canReach(currentTotal*next,rest,target)\n\n    concatTotal = concat(currentTotal,next)\n    withConcat = canReach(concatTotal,rest,target)\n\n    return (withAdd or withMul or withConcat)\n\n\nwith open(\"input.txt\") as f:\n    for line in f:\n        target,rest = line.split(':')\n        target = int(target)\n        numbers = [int(x) for x in rest.split()]\n\n        firstNum = numbers[0]\n        remaining = numbers[1:]\n        \n        if canReach(firstNum,remaining,target):\n            total = total + target\n\nprint(\"total:\",total)\n\n```\n",
      "excerpt": "",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-11-13T12:55:11.048Z"
    },
    {
      "id": "200-next-next-docs-md",
      "slug": "200-next/next-docs",
      "filepath": "200-NEXT/Next-Docs.md",
      "folder": "200-NEXT",
      "filename": "Next-Docs.md",
      "frontmatter": {
        "title": "Error Handling",
        "date": "2025-05-11",
        "tags": [
          "react",
          "nextjs",
          "server-actions",
          "useactionstate",
          "streaming",
          "suspense",
          "error-handling",
          "server-components"
        ],
        "category": "200-NEXT",
        "description": "Learn to manage expected errors in Server Actions using the useActionState hook while understanding streaming, suspense, and server component constraints."
      },
      "content": "## Error Handling\n\nHandling Expected Errors from Server Actions\n\n> const [state, FormAction, pending] = useActionState( createUser, initialState )\n\nUse the useActionState hook to manage the state of Server Actions, including handling errors. This approach avoids try/catch blocks for expected errors,\n\n---\n\n## Loading UI and Streaming\n\n![](https://beta.appflowy.cloud/api/file_storage/5280cd98-0615-4f27-b162-2f7e8f5d0dbe/v1/blob/4a0e06d7%2D04e2%2D5c99%2Dad75%2D23e1bca86797/BFFaB5ByU4F_iBPosiusqdFuvURpyyVtgLUCjzb3GzM=.png)  \n\n## Streaming without Suspense :\n\n![](https://beta.appflowy.cloud/api/file_storage/5280cd98-0615-4f27-b162-2f7e8f5d0dbe/v1/blob/4a0e06d7%2D04e2%2D5c99%2Dad75%2D23e1bca86797/A_pHbXVkPtxSnZP7hHGt5B29KtuQXnszy7a83yibT5Y=.png)\n\n## Streaming with Suspense :\n\n![](https://beta.appflowy.cloud/api/file_storage/5280cd98-0615-4f27-b162-2f7e8f5d0dbe/v1/blob/4a0e06d7%2D04e2%2D5c99%2Dad75%2D23e1bca86797/DebToGILPUo3iTRI7BbPfDmGHY-k9MSnIeShyb4UQt4=.png)\n## Streaming with Suspense :\n\n![](https://beta.appflowy.cloud/api/file_storage/5280cd98-0615-4f27-b162-2f7e8f5d0dbe/v1/blob/4a0e06d7%2D04e2%2D5c99%2Dad75%2D23e1bca86797/DebToGILPUo3iTRI7BbPfDmGHY-k9MSnIeShyb4UQt4=.png)\n## Server Components:\n\nwe can't use state, because state can change, but Server Components can't re-render. And we can't use effects because effects only run _after_ the render, on the client, and Server Components never make it to the client.\n\nIt also means that we have a bit more flexibility when it comes to the rules. For example, in traditional React, we need to put side effects inside a `useEffect` callback or an event handler or something, so that they don't repeat on every render. But if the component only runs _once_, we don't have to worry about that!\n\n\n\n",
      "excerpt": "Learn to manage expected errors in Server Actions using the useActionState hook while understanding streaming, suspense, and server component constraints.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-05-11T10:03:21.000Z"
    },
    {
      "id": "200-next-projectlearnings-middleware-md",
      "slug": "200-next/projectlearnings/middleware",
      "filepath": "200-NEXT/ProjectLearnings/Middleware.md",
      "folder": "200-NEXT/ProjectLearnings",
      "filename": "Middleware.md",
      "frontmatter": {
        "title": "***Used in ChatPulse***",
        "date": "2025-05-13",
        "tags": [
          "chatpulse",
          "javascript",
          "typescript",
          "middleware",
          "nextjs",
          "markdown"
        ],
        "category": "200-NEXT/ProjectLearnings",
        "description": "Code implementation of a simple JavaScript or TypeScript middleware used within the ChatPulse project for Markdown processing."
      },
      "content": "___\n## ***Used in ChatPulse***\n\nHere is your code converted to Markdown with syntax highlighting for JavaScript/TypeScript:\n\n```typescript\nimport { headers } from 'next/headers';\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\nimport { auth } from './lib/auth';\n\nconst publicPaths = [\n  '/',\n  '/signin',\n  '/api/auth',\n  '/info',\n  '/banner.png',\n];\n\nexport async function middleware(request: NextRequest) {\n  const { pathname } = request.nextUrl;\n\n  const isPublicPath = publicPaths.some(\n    (path) =>\n      pathname === path ||\n      pathname.startsWith(`${path}/`) ||\n      pathname.startsWith('/api/auth/')\n  );\n\n  const isAuthRoute = pathname.startsWith('/signin');\n\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (isAuthRoute && session) {\n    return NextResponse.redirect(new URL('/home', request.url));\n  }\n\n  if (!isPublicPath && !session) {\n    const signInUrl = new URL('/signin', request.url);\n    signInUrl.searchParams.set('callbackUrl', request.url);\n    return NextResponse.redirect(signInUrl);\n  }\n\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: [\n    '/((?!_next/static|_next/image|favicon\\\\.ico|public).*)',\n  ],\n};\n```\n\n\n## ***Simple middleware***\n\n```typescript\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { headers } from \"next/headers\";\nimport { auth } from \"@/lib/auth\";\n\nexport async function middleware(request: NextRequest) {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  });\n\n  if (!session) {\n    return NextResponse.redirect(new URL(\"/sign-in\", request.url));\n  }\n\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: [\"/((?!api|_next/static|_next/image|favicon.ico|sign-in|assets).*)\"],\n};\n\n```\n\n___\n\n\n\n",
      "excerpt": "Code implementation of a simple JavaScript or TypeScript middleware used within the ChatPulse project for Markdown processing.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-05-13T12:52:04.000Z"
    },
    {
      "id": "200-next-projectlearnings-witherrorhandling-as-a-middleware-for-server-functions-md",
      "slug": "200-next/projectlearnings/witherrorhandling-as-a-middleware-for-server-functions",
      "filepath": "200-NEXT/ProjectLearnings/withErrorHandling as a middleware for server functions.md",
      "folder": "200-NEXT/ProjectLearnings",
      "filename": "withErrorHandling as a middleware for server functions.md",
      "frontmatter": {
        "title": "withErrorHandling as a middleware for server functions",
        "date": "2025-05-14",
        "tags": [
          "typescript"
        ],
        "category": "200-NEXT/ProjectLearnings"
      },
      "content": "\n```typescript\n// Higher order function to handle errors\nexport const withErrorHandling = <T, A extends unknown[]>(\n  fn: (...args: A) => Promise<T>\n) => {\n  return async (...args: A): Promise<T> => {\n    try {\n      const result = await fn(...args);\n      return result;\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error occurred\";\n      return errorMessage as unknown as T;\n    }\n  };\n};\n```\n`withErrorHandling(<func>)`\n",
      "excerpt": "",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-05-14T11:21:46.000Z"
    },
    {
      "id": "404-backend-authentication-and-authorization-md",
      "slug": "404-backend/authentication-and-authorization",
      "filepath": "404-BACKEND/Authentication and Authorization.md",
      "folder": "404-BACKEND",
      "filename": "Authentication and Authorization.md",
      "frontmatter": {
        "title": " Key Differences and Mechanism B/W JWT and Sessions",
        "date": "2025-10-13",
        "tags": [
          "jwt",
          "sessions",
          "authentication",
          "authorization",
          "backend",
          "rbac",
          "stateless",
          "security"
        ],
        "category": "404-BACKEND",
        "description": "A technical guide comparing stateful session-based and stateless JWT authentication, covering scalability, revocation, and role-based access control."
      },
      "content": "\n### 1. Core Concepts: Who vs. What \n\n|Concept|Question Answered|Definition|Example|\n|---|---|---|---|\n|**Authentication (AuthN)**|**Who are you?**|The mechanism to assign an **identity** to a subject (user or system).|Providing a **username and password** to log in.|\n|**Authorization (AuthZ)**|**What can you do?**|The process of verifying a subject's **permissions** and capabilities within a system after they have been identified.|An **Admin** can delete a user, but a **Standard User** cannot.|\n\n---\n\n### 2. Historical Evolution of Authentication\n\nAuthentication methods evolved based on different principles of proof, moving from implicit trust to digital cryptography.\n\n|Era|Mechanism|Principle of Proof|Key Evolution|\n|---|---|---|---|\n|**Pre-Industrial**|Handshake, Vouching|**Implicit Trust**|Based on human contextual trust; failed to scale.|\n|**Medieval**|Wax Seals|**Something You Possess** (Physical Token)|Early authentication tokens; vulnerable to forgery (bypass attacks).|\n|**Industrial**|Passphrases (Telegraph)|**Something You Know** (Shared Secret)|Static passwords; led to the need for secure storage.|\n|**Modern Digital** (1960s-1970s)|Passwords on Mainframes|**Computational Secrets**|Vulnerabilities (plain text storage) led to **hashing** algorithms to secure passwords.|\n|**Modern Frameworks** (21st Century)|JWTs, OAuth 2.0, MFA|**Multiple Factors**|Combined knowledge, possession, and biometrics; enabled scalable, decentralized identity management.|\n\n---\n\n### 3. Key Components for State Management\n\nBefore modern methods, HTTP's **stateless** nature (treating every request as isolated) required mechanisms to maintain session memory.\n\n|Component|Function|Use Case|Diagram|\n|---|---|---|---|\n|**Session**|Creates a temporary, **stateful** server-side context for a user. The server stores user data (cart items, roles) mapped to a unique **Session ID**.|Tracking logged-in state, shopping carts in e-commerce.||\n|**Cookie**|A small piece of information stored in the user's browser by the server. It is the common transport layer for Session IDs or JWTs back to the server.|Sending the Session ID or JWT with every subsequent request.||\n|**JWT (JSON Web Token)**|A self-contained, cryptographically signed token that holds user information (**claims**) like ID and role.|Stateless authentication, distributed microservices.|**Structure:** `Header.Payload.Signature`|\n\n#### Comparison: Sessions vs. JWTs\n\n|Feature|Session-Based (Stateful)|JWT-Based (Stateless)|\n|---|---|---|\n|**Server State**|**Requires** server-side storage (Redis/DB) for session data.|**No** server-side session storage required; state is in the token.|\n|**Scalability**|Lower; synchronizing data across distributed servers causes latency.|Higher; any server with the secret key can validate the token.|\n|**Revocation**|Easy (delete the session ID from storage in real-time).|Difficult (token is valid until it expires; requires complex \"blacklist\" lookups).|\n\n---\n\n### 4. Authentication Architectures (When to Use What)\n\n|Type|Mechanism|Key Advantage|Ideal Use Case|\n|---|---|---|---|\n|**Stateful**|Session ID + Server-Side Storage + Cookie|Centralized control, easy real-time revocation.|Traditional **Web Apps** (Server-Side Rendered or Monoliths).|\n|**Stateless**|JWT (Self-Contained Token)|Scalable, no session dependency, ideal for distributed systems.|**APIs** (Microservices) and **Mobile Apps**.|\n|**API Key**|Cryptographically random, long-lived secret key.|Simple, programmatic access.|**Machine-to-Machine** (M2M) communication (e.g., your server calling ChatGPT API).|\n|**OAuth 2.0 / OIDC**|Delegation via tokens (Access Tokens, ID Tokens).|Securely grants limited access to a third-party app without sharing passwords.|**\"Sign In with Google/Facebook\"** features (Third-party integrations).|\n\n---\n\n### 5. Authorization: Role-Based Access Control (RBAC)\n\nAuthorization determines the level of access an authenticated user has to resources.\n\n- **RBAC Principle:** Permissions are assigned to **roles**, and roles are assigned to **users**. This simplifies management by grouping capabilities.\n    \n- **Workflow:**\n    \n    1. User authenticates and the server determines their **Role** (e.g., `User`, `Admin`, `Moderator`).\n        \n    2. User requests a resource (e.g., `POST /notes`).\n        \n    3. The backend logic checks if the user's assigned **Role** has the **Permission** (`Write`) to perform the **Action** (`POST`) on the **Resource** (`Notes`).\n        \n    4. If not authorized, the server returns a **403 Forbidden** error.\n        \n\n---\n\n### 6. Security Considerations \n\nBackend engineers must follow strict protocols to prevent security exploits during the AuthN flow.\n\n| Attack Type             | Vulnerability                                                                                                                                                                  | Defense Strategy                                                                                                                                                     |\n| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Information Leakage** | Sending specific error messages (e.g., \"User Not Found,\" \"Incorrect Password\") gives attackers clues about valid accounts.                                                     | Always send **generic** error messages (e.g., \"**Authentication failed**\") to prevent attackers from confirming valid usernames.                                     |\n| **Timing Attacks**      | If the server responds faster when a username is invalid (failing early) versus when a password is wrong (failing late after hashing), the response time can leak information. | **Equalize response times** by either using constant-time password comparison functions or simulating a small delay (`sleep` function) in the invalid username path. |\n|                         |                                                                                                                                                                                |                                                                                                                                                                      |\n\n\n---\n---\n\n##  Key Differences and Mechanism B/W JWT and Sessions\n\n| Feature               | Session-Based Authentication                                                                                                                                           | JWT Authentication                                                                                                                                                                                              |\n| --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Statefulness**      | **Stateful** (Server maintains the user's session record).                                                                                                             | **Stateless** (Server does not store the session; the token contains all necessary data).                                                                                                                       |\n| **Data Storage**      | Session data (user ID, roles, expiry) is stored securely on the **server** (in-memory, database, or Redis).                                                            | The JWT token (user data/claims) is stored on the **client** (browser storage, cookie).                                                                                                                         |\n| **Validation**        | Server receives an opaque **Session ID** (usually in a cookie), which it must **look up** in its session store/database to verify the user and retrieve their details. | Server receives the **JWT** (usually in an `Authorization` header), which it verifies locally using a **secret key** to validate the signature and extract user claims. No database lookup is typically needed. |\n| **Token Type**        | **Opaque Reference Token** (A meaningless random string/ID).                                                                                                           | **Self-Contained Token** (A string that encodes and signs actual user data).                                                                                                                                    |\n| **Default Transport** | **Cookie** (The browser automatically attaches the Session ID).                                                                                                        | **Authorization Header** (The client app manually attaches the token as `Bearer <token>`).                                                                                                                      |\n\n### Session Authentication Flow (Stateful)\n\n1. **Login:** The user sends credentials.\n    \n2. **Creation:** The server verifies credentials, creates a session object in the **database** (or cache), and generates a unique, opaque **Session ID**.\n    \n3. **Delivery:** The Session ID is sent back to the client, usually inside an **HTTP-only cookie**.\n    \n4. **Subsequent Request:** The client automatically sends the cookie (containing the Session ID) with every request.\n    \n5. **Authorization:** The server must perform a **database lookup** using the Session ID to retrieve the user's data and confirm the session is still active.\n    \n\n### JWT Authentication Flow (Stateless)\n\n1. **Login:** The user sends credentials.\n    \n2. **Creation:** The server verifies credentials, creates a **JWT** that includes user claims (ID, role, expiry time), and signs it with a secret key.\n    \n3. **Delivery:** The signed JWT is sent back to the client.\n    \n4. **Subsequent Request:** The client stores the JWT and sends it in the `Authorization: Bearer` header with every request.\n    \n5. **Authorization:** The server uses the secret key to **verify the token's signature**. If valid, the user's identity and permissions are read directly from the token payload, **skipping a database call.**\n    \n\n---\n\n##  Trade-offs: Scalability, Control, and Security\n\nThe choice between the two often comes down to prioritizing **scalability/performance** (JWT) versus **real-time control/simplicity** (Session).\n\n### 1. Scalability and Performance\n\n- **JWT Advantage:** Since JWTs are stateless, they are highly scalable. Any server (in a load-balanced or microservices architecture) can validate a JWT without having to share or query a centralized session database. This eliminates the database lookup latency and reduces server load, making it ideal for distributed systems.\n    \n- **Session Disadvantage:** Scaling session-based apps requires complex solutions like **sticky sessions** (forcing a user to hit the same server) or **centralized session stores** (like Redis), which introduces architectural complexity and the performance overhead of a constant session lookup on every request.\n    \n\n### 2. Revocation and Control (The \"Kill Switch\")\n\n- **Session Advantage:** Sessions offer immediate, real-time revocation. If a user logs out, changes their password, or is suspected of malicious activity, the server simply **deletes the session record** from the database, instantly invalidating the Session ID.\n    \n- **JWT Disadvantage:** JWTs are problematic for real-time revocation. Once a JWT is issued, it remains valid until its built-in **expiration time** because the server holds no state to check against. To revoke a token early (e.g., after a user logs out), the server must implement a **blacklist** or revocation list, which partially defeats the purpose of being stateless and introduces a required database lookup again.\n    \n\n### 3. Security Considerations\n\n|Aspect|Session-Based Security|JWT Security|\n|---|---|---|\n|**Data Exposure**|**Low.** The client only has an opaque ID; all user data is safely on the server.|**Medium/High.** The user data (payload) is visible to the client (Base64-encoded, not encrypted) and must **not** contain sensitive information.|\n|**CSRF Protection**|Vulnerable to **Cross-Site Request Forgery (CSRF)** attacks because cookies are automatically sent. Requires implementing anti-CSRF tokens.|Less vulnerable when sent via the `Authorization` header, as it is not automatically attached by the browser.|\n|**Storage Risk**|Lower risk if the Session ID is stored in an **HTTP-only cookie** (preventing JavaScript access via XSS).|Vulnerable to **Cross-Site Scripting (XSS)** if stored in `localStorage` (as malicious JavaScript can easily steal the token). Best stored in an **HTTP-only cookie**.|\n",
      "excerpt": "A technical guide comparing stateful session-based and stateless JWT authentication, covering scalability, revocation, and role-based access control.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-10-13T13:04:12.299Z"
    },
    {
      "id": "404-backend-controllers--services--repositories--middlewares-md",
      "slug": "404-backend/controllers,-services,-repositories,-middlewares",
      "filepath": "404-BACKEND/Controllers, Services, Repositories, Middlewares.md",
      "folder": "404-BACKEND",
      "filename": "Controllers, Services, Repositories, Middlewares.md",
      "frontmatter": {
        "title": " What Are Controllers, Services, Repositories, Middlewares, and Request Context?",
        "date": "2025-11-11",
        "tags": [
          "backend",
          "software-architecture",
          "design-patterns",
          "middleware",
          "api-development",
          "web-development"
        ],
        "category": "404-BACKEND",
        "description": "An overview of backend architecture patterns including the Controller-Service-Repository layers, middleware functions, and request context management."
      },
      "content": "\n#  What Are Controllers, Services, Repositories, Middlewares, and Request Context?\n\n\n---\n\n##  1. ControllerServiceRepository Pattern\n\nA foundational pattern that **separates concerns** in backend design, improving scalability, maintainability, and readability.\n\n###  Request Flow\n\n**Request  Controller  Service  Repository  Database  Response**\n\n---\n\n###  Controllers (a.k.a. Handlers)\n\nThe **entry point** of your application logic.\nIt directly interacts with HTTP requests and responses.\n\n**Responsibilities:**\n\n1. **Binding / Deserialization:**\n   Convert raw request data (e.g., JSON) into usable objects or classes.\n    Invalid input  send `400 Bad Request`.\n\n2. **Validation:**\n   Check that data meets all constraints  required fields, formats, types.\n\n3. **Transformation:**\n   Apply defaults or transformations before processing (e.g., add default pagination or sort order).\n\n4. **Delegation:**\n   Pass cleaned and validated data to the service layer.\n\n5. **Response Formation:**\n   Send back the appropriate HTTP response with status codes (200, 201, 404, 500, etc.).\n\n**In short:**\n *Controller = Interface between client and server logic.*\n\n---\n\n###  Services\n\nContain the **business logic**  the ***brains*** of your application.\n\n**Characteristics:**\n\n* Independent of HTTP or network layers.\n* Can be reused by multiple controllers.\n\n**Responsibilities:**\n\n1. **Business Processing:** Perform computations, decisions, or actions (e.g., send notifications, process payments).\n2. **Orchestration:** Combine multiple repository results to form complex outputs.\n3. **Database Interaction:** Call repository methods for data fetching or updates.\n\n**In short:**\n *Service = **Performs business logic and coordinates data sources**.*\n\n---\n\n###  Repositories\n\nThe **data access layer**  ***interacts directly with the database***.\n\n**Responsibilities:**\n\n* Execute database queries or ORM operations.\n* Perform single-purpose actions (like `findById`, `createUser`, `getAllBooks`).\n* Return raw or structured data to the service layer.\n\n**In short:**\n Repository = ***Talks to the database; one function, one purpose***.*\n\n---\n\n##  2. Middlewares\n\nMiddlewares are ***functions that process requests before reaching the controller (or after responses).***\n\nThey form a **chain** through which every request passes.\n\n###  How Middlewares Work\n\nEach middleware:\n\n```js\n(req, res, next) => { ... }\n```\n\n* Performs a specific task.\n* Calls `next()` to continue the chain.\n* Or sends a response early (e.g., error or access denied).\n\n**Order matters!**\nThey are executed in the exact order they are registered.\n\n---\n\n###  Common Middlewares and Their Uses\n\n| Middleware                | Purpose                                                            |\n| ------------------------- | ------------------------------------------------------------------ |\n| **Logging**               | Log each requests method, path, and timestamp.                    |\n| **CORS**                  | Add `Access-Control-Allow-Origin` headers for cross-origin access. |\n| **Authentication**        | Verify tokens and block unauthorized requests (`401`).             |\n| **Rate Limiting**         | Prevent abuse by limiting requests per IP (`429`).                 |\n| **Global Error Handling** | Catch and standardize all errors (`try/catch` alternative).        |\n| **Body Parsing**          | Automatically parse JSON or form data from requests.               |\n\n**Main Goal:**\n *Avoid duplication by centralizing shared logic.*\n\n---\n\n##  3. Request Context\n\nThe **Request Context** is like a private, ***temporary storage attached to each request***.\nIt exists **only for the duration of that request**.\n\n###  Purpose\n\n* Pass data *downstream* through middlewares, services, and handlers.\n* Avoid tight coupling and long parameter chains.\n\n---\n\n###  Common Use Cases\n\n#### 1. Authentication Data\n\n* Middleware authenticates a token  extracts `user_id`, `role`.\n* Stores these in the request context.\n* Handlers later read them to know *who* is making the request  securely and consistently.\n\n#### 2. Distributed Tracing (Request ID)\n\n* Middleware generates a unique `request_id` (UUID).\n* Stored in context and included in every log.\n* Enables tracking a single request across multiple services (useful in microservices).\n\n#### 3. Cancellation Signals\n\n* Context can signal when a request is cancelled or times out.\n* Useful for graceful shutdowns or aborting DB/network calls if a client disconnects.\n\n---\n\n##  Summary Overview\n\n| Layer               | Role                            | Should Know About HTTP? | Example Task                  |\n| ------------------- | ------------------------------- | ----------------------- | ----------------------------- |\n| **Controller**      | Entry point, validates & routes |  Yes                   | Validate user input           |\n| **Service**         | Business logic                  |  No                    | Calculate invoice total       |\n| **Repository**      | Data access                     |  No                    | Fetch users from DB           |\n| **Middleware**      | Pre-/Post-processing            |  Yes                   | Check authentication token    |\n| **Request Context** | Request-specific data           |  Scoped                | Store `user_id`, `request_id` |\n\n---\n\n##  Key Takeaways\n\n* **Controllers:** Handle requests & responses.\n* **Services:** Implement the core logic.\n* **Repositories:** Manage database access.\n* **Middlewares:** Handle reusable request logic.\n* **Request Context:** Pass request-scoped data without coupling.\n\nThis architecture ensures:\n High cohesion\n Low coupling\n Better testability\n Cleaner codebase\n\n---\n",
      "excerpt": "An overview of backend architecture patterns including the Controller-Service-Repository layers, middleware functions, and request context management.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-11-11T17:36:49.467Z"
    },
    {
      "id": "404-backend-database-with-postgres-md",
      "slug": "404-backend/database-with-postgres",
      "filepath": "404-BACKEND/Database with Postgres.md",
      "folder": "404-BACKEND",
      "filename": "Database with Postgres.md",
      "frontmatter": {
        "title": "Database with Postgres",
        "date": "2026-02-02",
        "tags": [
          "postgresql",
          "sql",
          "backend",
          "databases",
          "migrations",
          "data-modeling",
          "knex",
          "relational-database"
        ],
        "category": "404-BACKEND",
        "description": "A comprehensive guide to PostgreSQL fundamentals, covering SQL vs NoSQL, data types, schema migrations, and relational modeling for backend applications."
      },
      "content": "\n### **1. Introduction to Database Systems**\n\n- **What is a Database?** \n    \n    - A system to **persist** information across sessions (survives after the program stops).\n        \n    - Basically, any structured storage (e.g., contact list, local storage, text files) can be a database.\n        \n- **Disk vs. RAM:** \n    \n    - **RAM (Primary Memory):** Very fast but expensive and volatile (data lost on power off). Used for caching (e.g., Redis).\n        \n    - **Disk (Secondary Memory):** Slower but cheaper and persistent. Used for primary databases (e.g., PostgreSQL, MongoDB).\n        \n- **DBMS (Database Management System):** \n    \n    - Software responsible for efficiently organizing data and providing **CRUD** (Create, Read, Update, Delete) operations.\n        \n    - Key responsibilities: Data organization, Access control, **Integrity** (accuracy/validity), and **Security**.\n        \n- **Why not Text Files?** \n    \n    - **Parsing:** Slow and error-prone to read/write specific data points.\n        \n    - **No Structure:** Difficult to enforce data types (e.g., ensuring a field is a number).\n        \n    - **Concurrency:** Handling multiple users updating the same file simultaneously leads to data corruption or loss.\n        \n\n### **2. Relational vs. Non-Relational Databases**\n\n- **Relational (SQL):** \n    \n    - Organizes data in **tables, rows, and columns**.\n        \n    - **Strict Schema:** Structure must be defined beforehand (Column names, types).\n        \n    - **Pros:** Strong data integrity and consistency. Best for structured data like CRM systems.\n        \n    - _Examples:_ PostgreSQL, MySQL, SQL Server.\n        \n- **Non-Relational (NoSQL):** \n    \n    - Organizes data in **collections and documents**.\n        \n    - **Flexible Schema:** Can store dynamic/unstructured data.\n        \n    - **Pros:** Flexibility for rapid prototyping or content-heavy apps (e.g., CMS).\n        \n    - **Cons:** Harder to maintain data integrity; checks often move to application code.\n        \n    - _Examples:_ MongoDB.\n        \n\n### **3. Why Choose PostgreSQL?**\n\n- **Open Source & Free:** No proprietary locking.\n    \n- **SQL Standard Compliant:** Easy to migrate to/from other SQL databases.\n    \n- **Extensible:** Huge ecosystem of extensions.\n    \n- **Reliability:** Proven track record for scalability.\n    \n- **JSON Support:** PostgreSQL offers a native `JSONB` type with indexing, allowing it to handle dynamic data just like NoSQL databases. This makes it a \"best of both worlds\" solution.\n    \n\n### **4. PostgreSQL Data Types** \n\n- **Integers:** `Serial` (auto-incrementing ID), `Integer`, `BigInt` (for large numbers).\n    \n- **Decimals:**\n    \n    - `Decimal`/`Numeric`: Exact precision (slow). **Use for money/prices.**\n        \n    - `Float`/`Real`: Approximate precision (fast). Use for scientific calculations where slight inaccuracies are acceptable.\n        \n- **Strings:**\n    \n    - `Char(n)`: Fixed length (pads with spaces). **Avoid.**\n        \n    - `Varchar(n)`: Variable length with a limit.\n        \n    - `Text`: Unlimited length. **Recommended:** PostgreSQL docs recommend using `text` as there is no performance penalty compared to `varchar`, and it avoids arbitrary limits (like the legacy `255`).\n        \n- **Others:** `Boolean`, `Date`, `Timestamp` (use `timestamptz` for timezones), `UUID` (great for unique IDs), `JSONB` (binary JSON for efficient storage/querying).\n    \n\n### **5. Database Migrations** \n\n- **Concept:** Version control for your database schema. Instead of running raw SQL commands manually, you write files (e.g., `001_create_users.sql`) that describe changes.\n    \n- **Structure:**\n    \n    - **Up:** SQL to apply changes (Create table).\n        \n    - **Down:** SQL to revert changes (Drop table).\n        \n- **Benefits:** Tracks history of changes, allows rollbacks, and ensures all developers/servers have the same DB structure.\n    \n- **Tool Used:** `dbmate` (Command-line migration tool).\n    \n\n### **6. Database Modeling (Project Management App)**\n\nThe video builds a schema for a project management tool with the following components:\n\n- **Enums:** Custom types to enforce allowed values (e.g., `project_status`: 'active', 'completed', 'archived').\n    \n- **Tables & Relationships:**\n    \n    - **Users:** Stores generic info (email, password hash).\n        \n    - **User Profiles (1-to-1):** Separates profile details (bio, avatar) from the main user table. Uses the `user_id` as both Primary Key and Foreign Key.\n        \n    - **Projects (1-to-Many):** One user (owner) can have many projects. Uses `owner_id` Foreign Key.\n        \n    - **Tasks (1-to-Many):** One project has many tasks. Uses `project_id` Foreign Key.\n        \n    - **Project Members (Many-to-Many):** Users can join multiple projects; projects can have multiple users. Implemented via a **Linking Table** with a composite primary key (`project_id`, `user_id`).\n        \n- **Constraints:**\n    \n    - `Primary Key`: Unique identifier, implies `Not Null` and `Unique`.\n        \n    - `Not Null`: Prevents missing data.\n        \n    - `Unique`: Ensures no duplicates (e.g., emails).\n        \n    - `Foreign Key`: Enforces **Referential Integrity**.\n        \n        - `On Delete Restrict`: Prevents deleting a user if they own projects.\n            \n        - `On Delete Cascade`: Deletes all tasks if the parent project is deleted.\n            \n    - `Check`: Custom validation (e.g., `priority` must be between 1 and 5).\n        \n\n### **7. Writing SQL for Backend APIs**\n\n- **Parameterized Queries:** \n    \n    - **Critical for Security:** Never concatenate strings to build queries. Use placeholders (e.g., `$1`) to prevent **SQL Injection**. The database treats input as data, not executable code.\n        \n- **Joining Data:** \n    \n    - Using `LEFT JOIN` to fetch users even if they don't have a profile.\n        \n    - Using `TO_JSONB` to nest related data (e.g., embedding profile inside the user object) directly in the SQL result.\n        \n- **Dynamic Filtering & Sorting:** \n    \n    - Building queries based on URL parameters.\n        \n    - `ILIKE`: Case-insensitive pattern matching for search (e.g., names starting with 'A').\n        \n    - Dynamic `ORDER BY` clauses based on user selection (e.g., sort by 'created_at' or 'email').\n        \n- **Pagination:** \n    \n    - Using `LIMIT` (page size) and `OFFSET` (skip count) to handle large datasets.\n        \n\n### **8. Advanced Concepts: Indexes & Triggers**\n\n- **Indexes:** \n    \n    - **Problem:** Without an index, finding a specific row requires a **Sequential Scan** (checking every row), which is slow.\n        \n    - **Solution:** An Index is a lookup table (like a book index) that points directly to the data location.\n        \n    - **When to use:** On fields used in `WHERE`, `JOIN`, or `ORDER BY`.\n        \n    - **Trade-off:** Speeds up Reads, but slows down Writes (insert/update) because the index must also be updated.\n        \n- **Triggers:** \n    \n    - **Automation:** A function that automatically runs in response to a database event.\n        \n    - **Use Case:** Automatically updating the `updated_at` timestamp column whenever a row is modified, so application code doesn't need to handle it manually.",
      "excerpt": "A comprehensive guide to PostgreSQL fundamentals, covering SQL vs NoSQL, data types, schema migrations, and relational modeling for backend applications.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2026-02-02T14:40:21.828Z"
    },
    {
      "id": "404-backend-dns-working-md",
      "slug": "404-backend/dns-working",
      "filepath": "404-BACKEND/DNS Working.md",
      "folder": "404-BACKEND",
      "filename": "DNS Working.md",
      "frontmatter": {
        "title": "Everything You Need to Know About DNS",
        "date": "2026-01-30",
        "tags": [
          "dns",
          "networking",
          "backend",
          "internet",
          "infrastructure",
          "caching"
        ],
        "category": "404-BACKEND",
        "description": "A comprehensive guide to the Domain Name System (DNS), explaining how domain names are resolved to IP addresses through a hierarchical network of servers."
      },
      "content": "\n# Everything You Need to Know About DNS  \n\n## What is DNS?\n\nDNS is like a phone book for the internet. It maps domain names, such as `www.example.com`, to IP addresses, such as `192.0.2.1`, which are the actual locations of the servers that host the websites. This way, we dont have to memorize long strings of numbers to visit our favorite sites. We can just type in the name and let DNS do the rest.\n\n---\n\n## How does DNS work?\n\nDNS doesnt know everything by itself. It relies on a network of servers called **DNS resolvers** that work together to find the answer.\n\nWhen you type in a domain name in your browser:\n\n1. Your computer first checks its **local DNS cache**.\n2. If not found, it sends a query to a **DNS resolver**.\n3. The resolver checks its own cache.\n4. If still not found, it queries other DNS servers until the answer is found or the request times out.\n\n> **DNS Resolver**: A server that stores DNS records and answers DNS queries.\n\n### DNS Resolution Flow (Example: `www.example.com`)\n\n1. Local Caches  \n2. Recursive DNS Servers  \n3. Root DNS Servers  \n4. Top-Level Domain (TLD) DNS Servers  \n5. Authoritative DNS Servers  \n\n---\n\n## Step 1: Local Caches\n\nYour computer checks its local cache first. If the mapping exists, the process stops here.\n\nPossible local caches include:\n\n- **Browser Cache**  Cached from previous visits  \n- **DNS Cache**  Cached based on TTL (Time To Live)  \n- **Hosts File**  Manually defined domain-to-IP mappings  \n\n---\n\n## Step 2: Recursive DNS Servers\n\nYour system sends the query to a **recursive DNS server** (usually provided by your ISP).  \n- If the server has the answer cached, it returns it.\n- Otherwise, it forwards the query to a root DNS server.\n\n---\n\n## Step 3: Root DNS Servers\n\nRoot DNS servers are at the top of the DNS hierarchy.  \nThey dont store IP addresses for domains but know where to find **TLD DNS servers**.\n\nExample commands:\n```bash\ndig +short NS com\ndig +short NS org\ndig +short NS ai\ndig +short NS fyi\ndig +short NS io\n````\n\n---\n\n## Step 4: Top-Level Domain DNS Servers\n\nTLD servers delegate queries to **authoritative DNS servers** for second-level domains.\n\nExample commands:\n\n```bash\ndig +short NS cs.fyi\ndig +short NS github.com\ndig +short NS medium.com\n```\n\n---\n\n## Step 5: Authoritative DNS Servers\n\nThese servers store the actual DNS records.\n\n- The authoritative server returns the **A record** (IP address).\n    \n- The recursive DNS server forwards it back to your computer.\n    \n\n---\n\n## How does DNS work in practice?\n\nWe can use the `dig` command to query DNS servers.\n\n### Installing `dig` on Windows\n\n```bash\nchoco install dig\n```\n\n### Finding an IP address\n\n```bash\ndig +short www.example.com\n```\n\nOutput:\n\n```text\n93.184.216.34\n```\n\n### Tracing the full DNS resolution\n\n```bash\ndig +trace www.example.com\n```\n\n---\n\n## Debugging DNS Issues\n\n### Checking DNS Resolution\n\n```bash\ndig example.com +short\n```\n\n### Retrieving A Records\n\n```bash\ndig example.com A\n```\n\n### Retrieving MX Records\n\n```bash\ndig example.com MX\n```\n\n### Checking DNS Propagation\n\n```bash\ndig example.com MX +trace\n```\n\n### Checking DNSSEC Validation\n\n```bash\ndig example.com +dnssec\n```\n\n> **DNSSEC**: A security extension that ensures DNS data authenticity and integrity.\n\n---\n\n## Querying a Specific DNS Server\n\nExample using Google Public DNS:\n\n```bash\ndig example.com A @8.8.8.8\n```\n\n---\n\n## Common DNS Errors\n\n### DNS_PROBE_FINISHED_NXDOMAIN\n\nDomain does not exist or was mistyped.\n\n### DNS_PROBE_FINISHED_NO_INTERNET\n\nDNS server is unreachable due to network issues.\n\n### DNS_PROBE_FINISHED_BAD_CONFIG\n\nIncorrect DNS configuration or unreachable DNS server.\n\n---\n\n## How to Flush DNS Cache\n\n### Windows\n\n```bash\nipconfig /flushdns\n```\n\n### macOS\n\n```bash\ndscacheutil -flushcache\n```\n\n---\n\n## Conclusion\n\nIn this article, we learned how DNS works, the DNS resolution process, and how to debug DNS issues using the `dig` command.  \nI hope you found this article usefulfeel free to share it with your friends and colleagues.\n\n---\n\n All rights reserved  cs.fyi",
      "excerpt": "A comprehensive guide to the Domain Name System (DNS), explaining how domain names are resolved to IP addresses through a hierarchical network of servers.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2026-01-30T14:37:29.106Z"
    },
    {
      "id": "404-backend-http-protocol---md",
      "slug": "404-backend/http-protocol",
      "filepath": "404-BACKEND/HTTP Protocol.md",
      "folder": "404-BACKEND",
      "filename": "HTTP Protocol.md",
      "frontmatter": {
        "title": "HTTP Protocol",
        "date": "2025-08-21",
        "tags": [
          "http",
          "networking",
          "backend",
          "web-architecture",
          "https",
          "protocols",
          "api"
        ],
        "category": "404-BACKEND",
        "description": "A comprehensive overview of HTTP fundamentals, including version evolution, request-response structures, headers, and standard methods for web communication."
      },
      "content": "\n**1. HTTP Protocol Fundamentals**\n\n* **Statelessness**: It means that the server does not store any information about past client requests. Each request from a client is treated as an independent transaction. This design simplifies the server's architecture, as it doesn't need to maintain session state for each client. This makes it easier to scale web applications by distributing requests across multiple servers.\n\n* **Client-Server Model**: HTTP follows a strict client-server architecture. The client (e.g., a web browser) always initiates a request to a server. The server, which hosts the resources (like web pages or data), processes this request and sends back a response.\n\n* **HTTPS**: This is the secure version of HTTP. It adds a layer of security by using TLS (*Transport Layer Security*) or its predecessor, SSL (Secure Sockets Layer), to encrypt the communication between the client and the server. This encryption protects against eavesdropping and tampering with the data being exchanged.\n\n* **Underlying Transport Protocol (TCP)**: HTTP is an application layer protocol and it relies on a reliable transport layer protocol, which is typically TCP (Transmission Control Protocol). TCP ensures that data is delivered reliably and in the correct order between the client and the server.\n\n**2. Evolution of HTTP Versions**\n\n* **HTTP 1.0**: The earliest version. For each request, a new TCP connection was established, and it was closed after the response was sent. This was inefficient and led to performance issues.\n\n* **HTTP 1.1**: A significant improvement. It introduced the concept of persistent connections (`Keep-Alive`), allowing a single TCP connection to be reused for multiple requests. This reduced latency and improved performance. It also added features like chunked transfer encoding and better caching mechanisms.\n\n* **HTTP 2.0**: Focused on improving performance. It introduced multiplexing, which allows multiple requests and responses to be sent concurrently over a single TCP connection.\n\n* **HTTP 3.0**: The latest version, built on the QUIC protocol which uses UDP instead of TCP. This further improves performance by reducing connection establishment time and handling packet loss more effectively.\n\n**3. HTTP Messages (Request and Response)**\n\n* **Request Message**: This is the message sent from the client to the server. It consists of:\n\n\t* A start-line with the HTTP method, the requested URL, and the HTTP version.\n\t\n\t* Headers, which are key-value pairs providing metadata about the request.\n\t\n\t* An optional body, which contains data being sent to the server (e.g., in a POST request).\n\n* **Response Message**: This is the message sent from the server to the client. It consists of:\n\n\t* A status-line with the HTTP version, a status code, and a status message.\n\t\n\t* Headers, which provide metadata about the response.\n\t\n\t* An optional body, which contains the requested resource.\n\n**4. HTTP Headers**\n\n* **Purpose**: Headers are a crucial part of HTTP messages. They provide important metadata about the request or response, such as the content type, encoding, caching directives, and authentication information.\n\n* **Types of Headers**:\n\n* **Request Headers**: Provide information about the client and the requested resource (e.g., `User-Agent`, `Accept`).\n\n* **General Headers**: Apply to both requests and responses (e.g., `Date`, `Connection`).\n\n* **Representation Headers**: Describe the representation of the resource in the message body (e.g., `Content-Type`, `Content-Length`).\n\n* **Security Headers**: Used to enhance security (e.g., `Content-Security-Policy`, `Strict-Transport-Security`).\n\n**5. HTTP Methods\n\n* **Purpose**: These verbs define the action that the client wants to perform on a resource.\n\n* **Common Methods**:\n\n* **GET**: Retrieve a resource.\n\n* **POST**: Create a new resource.\n\n* **PUT**: Replace an existing resource.\n\n* **PATCH**: Partially update an existing resource.\n\n* **DELETE**: Delete a resource.\n\n* **Idempotent vs. Non-Idempotent**:\n\n\t* **Idempotent** methods produce the same result if called multiple times (e.g., GET, PUT, DELETE).\n\t\n\t* **Non-idempotent** methods may have different effects on each call (e.g., POST).\n\n* **OPTIONS**: Used by the client to determine the communication options for a target resource. This is often used in CORS pre-flight requests.\n\n**6. Cross-Origin Resource Sharing (CORS)**\n\n* **Same-Origin Policy**: A security feature in web browsers that prevents a web page from making requests to a different domain than the one that served the page.\n\n* **CORS Mechanism**: A mechanism that allows servers to relax the same-origin policy and specify which other origins are permitted to access their resources.\n\n* **Simple Request Flow**: For certain simple requests (e.g., GET requests with simple headers), the browser adds an `Origin` header. The server then responds with an `Access-Control-Allow-Origin` header if the origin is allowed.\n\n* **Pre-flight Request Flow**: For more complex requests (e.g., those with custom headers or using methods other than GET or POST), the browser sends a pre-flight `OPTIONS` request to the server to check if the actual request is allowed.\n\n**7. HTTP Response Codes (Status Codes)**\n\n* **Purpose**: These are three-digit codes that indicate the outcome of a request. They are grouped into five categories:\n\n* **1xx (Informational)**: The request has been received, and the process is continuing.\n\n* **2xx (Success)**: The request was successfully received, understood, and accepted.\n\n* **3xx (Redirection)**: Further action needs to be taken by the client to complete the request.\n\n* **4xx (Client Errors)**: The request contains bad syntax or cannot be fulfilled.\n\n* **5xx (Server Errors)**: The server failed to fulfill an apparently valid request.\n\n**8. HTTP Caching**\n\n* **Purpose**: Caching is used to store copies of responses to improve performance and reduce server load.\n\n* **Mechanism**:\n\n* **`Cache-Control`**: A header that provides caching directives for both requests and responses.\n\n* **`ETag`**: An identifier for a specific version of a resource.\n\n* **`Last-Modified`**: The date and time when the resource was last modified.\n\nThese headers allow the client to make conditional requests, and the server can respond with a `304 Not Modified` status if the resource has not changed.\n\n**9. Content Negotiation**\n\n* **Purpose**: A mechanism that allows the client and server to agree on the best representation of a resource when multiple representations are available.\n\n* **Types**:\n\n* **Media Type**: The client can specify the desired media type (e.g., `application/json`, `text/html`) using the `Accept` header.\n\n* **Language**: The client can specify the preferred language using the `Accept-Language` header.\n\n* **Encoding**: The client can specify the supported content encodings (e.g., `gzip`) using the `Accept-Encoding` header.\n\n* **HTTP Compression**: Servers can compress the response body to reduce the amount of data transferred, which improves performance.\n\n**10. Persistent Connections (`Keep-Alive`)**\n\n* **Concept**: In HTTP 1.1 and later, a single TCP connection can be kept open and reused for multiple HTTP requests and responses. This avoids the overhead of establishing a new connection for each request.\n\n* **Headers**: The `Connection: keep-alive` header is used to request a persistent connection.\n\n**11. Handling Large Requests and Responses**\n\n* **Large Requests (Client to Server)**: For uploading large files, multipart requests (`multipart/form-data`) are used. The request body is divided into multiple parts, each with its own headers.\n\n* **Large Responses (Server to Client)**: For sending large responses, the server can use chunked transfer encoding, where the response body is sent in a series of chunks.\n\n**12. SSL/TLS/HTTPS Overview**\n\n* **SSL (Secure Sockets Layer)**: The original protocol for encrypting communication between a client and a server. It is now considered insecure and has been replaced by TLS.\n\n* **TLS (Transport Layer Security)**: The modern standard for securing communication over a computer network. It provides privacy and data integrity between two communicating applications.\n\n* **HTTPS (HTTP Secure)**: This is HTTP over TLS. It ensures that the communication between the client and the server is encrypted and secure.",
      "excerpt": "A comprehensive overview of HTTP fundamentals, including version evolution, request-response structures, headers, and standard methods for web communication.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-08-21T16:47:37.623Z"
    },
    {
      "id": "404-backend-osi-model-md",
      "slug": "404-backend/osi-model",
      "filepath": "404-BACKEND/OSI Model.md",
      "folder": "404-BACKEND",
      "filename": "OSI Model.md",
      "frontmatter": {
        "title": " The 7 Layers of the OSI Model",
        "date": "2025-10-08",
        "tags": [
          "networking",
          "osi-model",
          "protocols",
          "backend",
          "architecture",
          "infrastructure"
        ],
        "category": "404-BACKEND",
        "description": "A detailed overview of the seven OSI layers, explaining network communication protocols and data encapsulation from the physical to the application layer."
      },
      "content": "\nThe OSI model helps engineers and developers design, troubleshoot, and understand complex networking systems.\n\n---\n\n##  The 7 Layers of the OSI Model\n\n| **Layer** | **Name** | **Function / Purpose** |\n|------------|-----------|------------------------|\n| **7** | **Application Layer** | Provides network services directly to the end-user applications (e.g., web browsers, email clients). |\n| **6** | **Presentation Layer** | Translates data between the application and network formats  handles encryption, compression, and serialization. |\n| **5** | **Session Layer** | Manages sessions or connections between local and remote applications. |\n| **4** | **Transport Layer** | Responsible for reliable data transfer, error detection, and flow control (e.g., TCP, UDP). |\n| **3** | **Network Layer** | Deals with logical addressing and routing of data packets (e.g., IP addresses, routers). |\n| **2** | **Data Link Layer** | Ensures reliable transmission of data frames between two directly connected nodes (e.g., Ethernet, MAC addresses). |\n| **1** | **Physical Layer** | Concerned with the physical transmission of bits over a medium (e.g., cables, switches, radio waves). |\n\n---\n\n###  Layer 1: **Physical Layer**\n- **Purpose**: Transmits raw bits (0s and 1s) over a physical medium.  \n- **Devices**: Hubs, repeaters, cables, connectors.  \n- **Examples**: Ethernet cables (Cat5/6), fiber optics, radio frequencies.  \n- **Functions**:\n  - Defines voltage levels, bit timings, and data rates.\n  - Specifies connectors and interface standards (e.g., RS-232, IEEE 802.3).\n\n---\n\n###  Layer 2: **Data Link Layer**\n- **Purpose**: Provides error detection and correction for reliable node-to-node communication.  \n- **Divided into two sub-layers**:  \n  1. **LLC (Logical Link Control)**  Manages communication between devices and multiplexing.  \n  2. **MAC (Media Access Control)**  Determines who can transmit data over the network.  \n- **Devices**: Switches, bridges.  \n- **Protocols**: Ethernet, PPP (Point-to-Point Protocol), HDLC.  \n- **Address Type**: MAC address (physical address).\n\n---\n\n###  Layer 3: **Network Layer**\n- **Purpose**: Handles logical addressing and routing  determines the best path for data.  \n- **Devices**: Routers, Layer 3 switches.  \n- **Protocols**: IP (IPv4, IPv6), ICMP, ARP, RIP, OSPF, BGP.  \n- **Address Type**: IP address.  \n- **Functions**:\n  - Packet forwarding and routing.\n  - Fragmentation and reassembly of packets.\n\n---\n\n###  Layer 4: **Transport Layer**\n- **Purpose**: Ensures reliable data delivery across the network.  \n- **Devices**: Gateways, firewalls (some operate here).  \n- **Protocols**: TCP (Transmission Control Protocol), UDP (User Datagram Protocol).  \n- **Functions**:\n  - **Segmentation** and **reassembly** of data.\n  - **Error control** and **flow control**.\n  - **Port addressing** (e.g., HTTP  port 80, HTTPS  port 443).\n\n---\n\n###  Layer 5: **Session Layer**\n- **Purpose**: Establishes, manages, and terminates connections between applications.  \n- **Functions**:\n  - Session establishment and teardown.\n  - Synchronization (e.g., checkpoints for long data transfers).  \n- **Example**: Keeping a user logged in during a web session.\n\n---\n\n###  Layer 6: **Presentation Layer**\n- **Purpose**: Translates data formats for the application layer and the network.  \n- **Functions**:\n  - Data **encryption** and **decryption**.\n  - **Data compression** and **decompression**.\n  - **Format translation** (e.g., converting EBCDIC to ASCII).  \n- **Examples**:\n  - SSL/TLS encryption.\n  - JPEG, MP3, and MPEG formats.\n\n---\n\n###  Layer 7: **Application Layer**\n- **Purpose**: Closest to the end user. Provides network services to applications.  \n- **Functions**:\n  - Enables user interaction with network.\n  - Interfaces with software that uses the network.  \n- **Examples**:\n  - HTTP, HTTPS, FTP, SMTP, POP3, IMAP, DNS, DHCP.\n\n---\n\n##  Mnemonics to Remember the OSI Layers\n\nFrom **Layer 7  1 (top-down)**:  \n> **A**ll **P**eople **S**eem **T**o **N**eed **D**ata **P**rocessing\n\nFrom **Layer 1  7 (bottom-up)**:  \n> **P**lease **D**o **N**ot **T**hrow **S**ausage **P**izza **A**way\n\n---\n\n##  Data Encapsulation & Decapsulation\n\nWhen data moves **down** the OSI model (transmission):\n1. Application data  encapsulated into segments, packets, frames, and finally bits.  \n2. Each layer adds its own **header** to the data (called **encapsulation**).\n\nWhen data moves **up** the OSI model (reception):\n1. Each layer **removes** its corresponding header (called **decapsulation**).\n\nThis ensures the data is interpreted correctly at both sender and receiver ends.\n\n---\n\n##  Real-World Example\n\nWhen you open a web page (like `https://example.com`):\n\n1. **Application (Layer 7)**: Browser uses HTTP/HTTPS to request web content.  \n2. **Presentation (Layer 6)**: SSL/TLS encrypts the data.  \n3. **Session (Layer 5)**: A secure session is established between you and the website.  \n4. **Transport (Layer 4)**: TCP breaks data into segments and ensures packets arrive in order.  \n5. **Network (Layer 3)**: IP handles logical addressing and routing.  \n6. **Data Link (Layer 2)**: Ethernet manages MAC addressing and error detection.  \n7. **Physical (Layer 1)**: Data is converted to electrical or optical signals and transmitted.\n\n---\n",
      "excerpt": "A detailed overview of the seven OSI layers, explaining network communication protocols and data encapsulation from the physical to the application layer.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-10-08T06:12:57.422Z"
    },
    {
      "id": "404-backend-ratelimiting-implimentation-md",
      "slug": "404-backend/ratelimiting-implimentation",
      "filepath": "404-BACKEND/RateLimiting Implimentation.md",
      "folder": "404-BACKEND",
      "filename": "RateLimiting Implimentation.md",
      "frontmatter": {
        "title": "RateLimiting Implimentation",
        "date": "2025-11-13",
        "tags": [
          "js"
        ],
        "category": "404-BACKEND"
      },
      "content": "\n```js\n/*\n  nodejs-rate-limiter.js\n  A flexible, production-ready rate limiting middleware for Express (Node.js).\n\n  Features:\n    - Pluggable stores: Redis (distributed) and in-memory (single-process fallback)\n    - Sliding window implementation in Redis using sorted sets for accurate limits\n    - Configurable window size and max requests, per-key identification (IP, user id)\n    - Response headers: RateLimit-Limit, RateLimit-Remaining, RateLimit-Reset\n    - Customizable callbacks and behavior when limit exceeded\n    - Easy Express integration\n\n  Usage example:\n    const express = require('express');\n    const createRateLimiter = require('./nodejs-rate-limiter');\n\n    // create Redis client (ioredis or node-redis compatible)\n    const Redis = require('ioredis');\n    const redis = new Redis();\n\n    const limiter = createRateLimiter({\n      windowMs: 60_000,          // 1 minute window\n      max: 100,                  // max 100 requests per window per key\n      redisClient: redis,        // optional, for distributed limiting\n      keyGenerator: (req) => req.user?.id || req.ip,\n      trustProxy: true,\n    });\n\n    const app = express();\n    app.use(limiter.middleware());\n\n    app.get('/', (req, res) => res.send('ok'));\n\n    app.listen(3000);\n*/\n\nconst DEFAULTS = {\n  windowMs: 60_000,\n  max: 60,\n  message: 'Too many requests, please try again later.',\n  headers: true,\n  keyPrefix: 'rl:',\n  trustProxy: false,\n  store: 'redis', // 'redis' | 'memory'\n};\n\nfunction createRateLimiter(options = {}) {\n  const cfg = Object.assign({}, DEFAULTS, options);\n\n  if (cfg.store === 'redis' && !cfg.redisClient) {\n    console.warn('[rate-limiter] store=redis but no redisClient provided  falling back to memory store');\n    cfg.store = 'memory';\n  }\n\n  const store = cfg.store === 'redis' ? createRedisStore(cfg) : createMemoryStore(cfg);\n\n  function middleware() {\n    return async function rateLimitMiddleware(req, res, next) {\n      try {\n        const key = (cfg.keyPrefix || '') + (await (cfg.keyGenerator ? cfg.keyGenerator(req) : defaultKeyGenerator(req, cfg)));\n\n        const now = Date.now();\n        const result = await store.increment(key, now);\n        // result: { current, remaining, reset }\n\n        if (cfg.headers) {\n          res.setHeader('RateLimit-Limit', String(cfg.max));\n          res.setHeader('RateLimit-Remaining', String(Math.max(0, result.remaining)));\n          res.setHeader('RateLimit-Reset', String(Math.ceil(result.reset / 1000))); // seconds until reset\n        }\n\n        if (result.current > cfg.max) {\n          // Exceeded\n          if (cfg.onLimitReached) {\n            // allow custom handling (logging, metrics)\n            try { cfg.onLimitReached(req, { key, result, cfg }); } catch (e) { /* ignore */ }\n          }\n\n          res.status(cfg.statusCode || 429);\n          // Recommended to include Retry-After header in seconds\n          const retryAfterSec = Math.ceil(result.reset / 1000);\n          res.setHeader('Retry-After', String(retryAfterSec));\n\n          if (typeof cfg.handler === 'function') return cfg.handler(req, res, next);\n\n          return res.json({ error: cfg.message, retry_after_seconds: retryAfterSec });\n        }\n\n        // allowed\n        return next();\n      } catch (err) {\n        // If the store fails, decide whether to allow or block. Default: allow (fail-open)\n        console.error('[rate-limiter] error', err);\n        if (cfg.failClosed) {\n          return res.status(500).json({ error: 'rate limiter error' });\n        }\n        return next();\n      }\n    };\n  }\n\n  return { middleware };\n}\n\nfunction defaultKeyGenerator(req, cfg) {\n  // Use IP by default. If trustProxy is true, use req.ip (express handles X-Forwarded-For if trust proxy configured on app)\n  if (cfg.trustProxy && req.ip) return req.ip;\n  // fallback to remote address\n  return (req.ip || req.connection?.remoteAddress || 'unknown');\n}\n\n// --- Memory store (single-process) ---\nfunction createMemoryStore(cfg) {\n  // Token-bucket inspired sliding window using timestamps array per key\n  const clients = new Map();\n  const windowMs = cfg.windowMs;\n  const max = cfg.max;\n\n  // periodic cleanup to avoid memory growth\n  const CLEANUP_INTERVAL = Math.max(60_000, Math.floor(windowMs * 2));\n  const cleanupHandle = setInterval(() => {\n    const now = Date.now();\n    for (const [key, item] of clients.entries()) {\n      if (item.lastSeen + windowMs * 2 < now) clients.delete(key);\n    }\n  }, CLEANUP_INTERVAL).unref();\n\n  async function increment(key, now) {\n    let item = clients.get(key);\n    if (!item) {\n      item = { timestamps: [], lastSeen: now };\n      clients.set(key, item);\n    }\n    item.lastSeen = now;\n    const cut = now - windowMs;\n    // keep only timestamps within window\n    item.timestamps = item.timestamps.filter(ts => ts > cut);\n    item.timestamps.push(now);\n\n    const current = item.timestamps.length;\n    const remaining = Math.max(0, max - current);\n    // compute reset time: earliest timestamp in window + windowMs - now\n    const reset = item.timestamps[0] ? (item.timestamps[0] + windowMs - now) : windowMs;\n\n    return { current, remaining, reset };\n  }\n\n  // expose store API\n  return { increment };\n}\n\n// --- Redis store (distributed, sliding window using sorted set) ---\nfunction createRedisStore(cfg) {\n  const redis = cfg.redisClient;\n  const windowMs = cfg.windowMs;\n  const max = cfg.max;\n  const prefix = cfg.keyPrefix || 'rl:';\n\n  // Lua script could be used for atomicity; but we'll use sorted-set commands which are atomic per command sequence\n  async function increment(key, now) {\n    const redisKey = key;\n    const min = now - windowMs;\n\n    // Use pipeline for efficiency\n    const pipeline = redis.multi();\n    pipeline.zadd(redisKey, 'NX', now, String(now));\n    pipeline.zremrangebyscore(redisKey, 0, min);\n    pipeline.zcard(redisKey);\n    pipeline.pexpire(redisKey, windowMs + 1000);\n\n    const execRes = await pipeline.exec();\n    // execRes is array of results for each command\n    // zadd -> [null, 1]\n    // zremrangebyscore -> [null, count]\n    // zcard -> [null, card]\n    // pexpire -> [null, 1]\n\n    // When using node-redis or ioredis the shape differs; normalize:\n    const zcardRes = execRes && execRes[2];\n    let current;\n    if (Array.isArray(zcardRes)) {\n      // ioredis returns [null, value]\n      current = Number(zcardRes[1]);\n    } else if (typeof zcardRes === 'number') {\n      current = zcardRes;\n    } else if (zcardRes && zcardRes[1] !== undefined) {\n      current = Number(zcardRes[1]);\n    } else {\n      // fallback: fetch explicitly\n      current = Number(await redis.zcard(redisKey));\n    }\n\n    const remaining = Math.max(0, max - current);\n\n    // Compute reset time: find the earliest timestamp in the sorted set\n    let reset = windowMs;\n    try {\n      const earliest = await redis.zrange(redisKey, 0, 0, 'WITHSCORES');\n      // earliest could be [member, score] or ['member1','member2'] depending on client\n      let score = null;\n      if (Array.isArray(earliest) && earliest.length >= 2) {\n        score = Number(earliest[1]);\n      } else if (Array.isArray(earliest) && earliest.length === 1) {\n        score = Number(earliest[0]);\n      }\n      if (!Number.isNaN(score)) {\n        reset = Math.max(0, Math.ceil((score + windowMs - now)));\n      }\n    } catch (e) {\n      // ignore, fallback to window\n    }\n\n    return { current, remaining, reset };\n  }\n\n  return { increment };\n}\n\nmodule.exports = createRateLimiter;\n\n```\n",
      "excerpt": "",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-11-13T12:56:14.033Z"
    },
    {
      "id": "404-backend-rest-api-design-md",
      "slug": "404-backend/rest-api-design",
      "filepath": "404-BACKEND/REST API DESIGN.md",
      "folder": "404-BACKEND",
      "filename": "REST API DESIGN.md",
      "frontmatter": {
        "title": " **Understanding REST Principles**",
        "date": "2025-11-13",
        "tags": [
          "rest-api",
          "backend",
          "http-methods",
          "web-architecture",
          "api-design",
          "software-engineering"
        ],
        "category": "404-BACKEND",
        "description": "A comprehensive guide to REST architectural principles, core constraints, and best practices for designing scalable and maintainable web APIs using HTTP."
      },
      "content": "\n---\n\n#  **Understanding REST Principles**\n\nREST (**Representational State Transfer**) is an architectural style that defines a set of constraints for creating scalable, maintainable, and reliable web services. REST APIs use HTTP as the communication protocol and are **resource-oriented**, meaning they revolve around entities (resources) rather than actions.\n\n---\n\n##  **Core Principles of REST Architecture**\n\n1. ### **Resource-Based**\n\n   * REST APIs are designed around **resources** (e.g., users, books, orders).\n   * Each resource is identified by a unique **URI (Uniform Resource Identifier)**.\n   * Example:\n\n     * `/users`  Collection of users\n     * `/users/101`  Specific user with ID 101\n\n### 1.  **Stateless**\n\n   * Every client request must include all necessary information for the server to process it.\n   * The **server does not store any client session** between requests.\n   * Benefit: Simplifies scalability and load balancing since any server can handle any request.\n\n### 3.  **Cacheable**\n\n   * Server responses should indicate whether they are **cacheable** or **non-cacheable**.\n   * This allows clients (or proxies) to reuse responses and improve performance.\n   * HTTP headers like `Cache-Control`, `ETag`, and `Expires` are used to control caching.\n\n### 4.  **Uniform Interface**\n\n   * REST APIs must follow a **consistent interface**, using standard HTTP methods:\n\n     * `GET`, `POST`, `PUT`, `PATCH`, `DELETE`\n   * This uniformity simplifies integration and enhances developer experience.\n\n### 5.  **Layered System**\n\n   * REST architecture can consist of **multiple layers** (e.g., caching, load balancers, proxies).\n   * Each layer only communicates with the one directly beneath it.\n   * This modularity improves scalability, security, and flexibility.\n\n---\n\n###  **Why These Principles Matter**\n\nBy adhering to these REST principles, APIs become:\n\n* **Scalable**  Easy to distribute across multiple servers.\n* **Maintainable**  Clear separation of concerns.\n* **Extensible**  New features can be added without breaking existing functionality.\n\n---\n\n#  **Best Practices for Designing REST APIs**\n\nThese conventions ensure your REST API is **robust, predictable, and user-friendly**.\n\n---\n\n## 1 **Use Nouns for Resource Naming**\n\n* REST focuses on *resources*, not actions.\n*  Use: `/users`, `/orders/{id}`\n*  Avoid: `/getUserData`, `/createOrder`\n* Endpoints should represent entities (nouns) rather than operations (verbs).\n\n---\n\n## 2 **Use Hierarchical Resource Naming**\n\n* Represent relationships between resources using a clear hierarchy.\n* Example:\n\n  * `/orders`  All orders\n  * `/orders/{orderId}`  Specific order\n  * `/orders/{orderId}/items`  Items belonging to a specific order\n* This makes your API structure **logical and intuitive**.\n\n---\n\n## 3 **Use HTTP Methods Correctly**\n\n| Method     | Description                                        | Idempotent? | Example      |\n| :--------- | :------------------------------------------------- | :---------: | :----------- |\n| **GET**    | Retrieve a resource                                |     Yes    | `/users/123` |\n| **POST**   | Create a new resource                              |      No    | `/users`     |\n| **PUT**    | Replace an existing resource (or create if absent) |     Yes    | `/users/123` |\n| **PATCH**  | Partially update a resource                        |      No    | `/users/123` |\n| **DELETE** | Remove a resource                                  |     Yes    | `/users/123` |\n\n* Idempotent = Performing the same operation multiple times has the same result.\n\n---\n\n## 4 **Use Appropriate HTTP Status Codes**\n\n| Code                          | Meaning                   | Use Case                     |\n| :---------------------------- | :------------------------ | :--------------------------- |\n| **200 OK**                    | Request successful        | Data retrieved successfully  |\n| **201 Created**               | New resource created      | After POST                   |\n| **204 No Content**            | Success, no response body | After DELETE or PUT          |\n| **400 Bad Request**           | Malformed request         | Invalid syntax or parameters |\n| **401 Unauthorized**          | Authentication required   | Missing/invalid credentials  |\n| **403 Forbidden**             | Access denied             | User lacks permission        |\n| **404 Not Found**             | Resource doesnt exist    | Wrong URI or deleted data    |\n| **500 Internal Server Error** | Server-side issue         | Unexpected error             |\n\nProper use of status codes improves **clarity and debugging** for clients.\n\n---\n\n## 5 **Use Plural Nouns for Resource Naming**\n\n* Use plural form for collections:\n\n  * `/users`  Collection of user resources\n  * `/books`  Collection of book resources\n* Promotes **consistency** and reflects standard REST conventions.\n\n---\n\n## 6 **Consistent Naming and Casing Conventions**\n\n* Choose one style and **stick to it** throughout your API:\n\n  * **kebab-case:** `/user-profiles`\n  * **snake_case:** `/user_profiles`\n  * **camelCase:** common in JSON fields (`firstName`)\n* Consistency ensures better developer experience and readability.\n\n---\n\n## 7 **Use Query Parameters for Filtering and Sorting**\n\n* Allow clients to filter and sort data efficiently.\n\n  * Example:\n\n    * `/users?name=John&age=30`  Filter by name and age\n    * `/books?sort=title&order=asc`  Sort by title in ascending order\n* Makes API more **flexible and client-friendly**.\n\n---\n\n## 8 **Implement API Versioning**\n\nVersioning helps avoid breaking changes for existing clients.\n\n**Common Strategies:**\n\n1. **URI Versioning:** `/v1/users`, `/v2/users`\n2. **Query Parameter:** `/users?version=2`\n3. **Header Versioning:** `Accept: application/vnd.company.v2+json`\n\n Choose one versioning approach and apply it consistently.\n\n---\n\n## 9 **Provide Comprehensive Documentation**\n\n* Good documentation improves adoption and usability.\n* Include:\n\n  * Endpoint list with descriptions\n  * Request/response formats\n  * Example payloads and responses\n* Use tools like:\n\n  * **Swagger (OpenAPI)**\n  * **API Blueprint**\n  * **Postman Collections**\n\n---\n\n##  **Implement Authentication and Authorization**\n\nSecure your API using standard mechanisms:\n\n| Mechanism                 | Description                                                     |\n| ------------------------- | --------------------------------------------------------------- |\n| **API Keys**              | Simple key-based authentication for trusted clients             |\n| **JWT (JSON Web Tokens)** | Token-based authentication for stateless sessions               |\n| **OAuth 2.0**             | Industry standard for delegated access (e.g., login via Google) |\n\nUse **RBAC** (Role-Based Access Control) or **ABAC** (Attribute-Based Access Control) for permissions.\n\n---\n\n## 11 **Support Caching**\n\n* Use caching to enhance performance and reduce server load.\n* Strategies:\n\n  * **Client-side caching**\n  * **Server-side caching**\n  * **Proxy caching**\n* Use headers like:\n\n  * `Cache-Control`\n  * `ETag`\n  * `Expires`\n\n---\n\n## 12 **Handle Errors Gracefully**\n\n* Return **clear and descriptive error messages**.\n* Include:\n\n  * **Error code**\n  * **Message**\n  * **Details (optional)**\n* Example:\n\n  ```json\n  {\n    \"error\": \"InvalidRequest\",\n    \"message\": \"The 'email' field is required.\"\n  }\n  ```\n\n---\n\n## 13 **Use Hypermedia Controls (HATEOAS)**\n\n* HATEOAS = **Hypermedia As The Engine Of Application State**\n* Include navigational links in responses to guide clients.\n* Example:\n\n  ```json\n  {\n    \"id\": 101,\n    \"title\": \"REST API Design\",\n    \"links\": {\n      \"self\": \"/books/101\",\n      \"author\": \"/books/101/author\"\n    }\n  }\n  ```\n* Makes the API **self-descriptive and discoverable**.\n\n---\n\n## 14 **Implement Rate Limiting and Throttling**\n\n* Protect your API from abuse and overload.\n* **Rate Limiting:** Limits the number of requests per user/time window.\n* **Throttling:** Slows down requests when limits are approached.\n* Example:\n\n  * 100 requests per minute per API key\n\n---\n\n## 15 **Monitor and Log API Activity**\n\n* Essential for **debugging**, **analytics**, and **security**.\n* Log details like:\n\n  * Request method and endpoint\n  * Response time and status code\n  * Error messages\n* Use monitoring tools like:\n\n  * Prometheus, Grafana, Datadog, ELK Stack\n\n---\n\n\n---\n",
      "excerpt": "A comprehensive guide to REST architectural principles, core constraints, and best practices for designing scalable and maintainable web APIs using HTTP.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-11-13T13:06:48.904Z"
    },
    {
      "id": "404-backend-routing-md",
      "slug": "404-backend/routing",
      "filepath": "404-BACKEND/Routing.md",
      "folder": "404-BACKEND",
      "filename": "Routing.md",
      "frontmatter": {
        "title": " Backend Routing: How Requests Find Their Way Home",
        "date": "2025-10-08",
        "tags": [
          "backend",
          "routing",
          "api-design",
          "rest-api",
          "http-methods",
          "web-development"
        ],
        "category": "404-BACKEND",
        "description": "A comprehensive guide to backend routing covering HTTP methods, static and dynamic routes, parameters, nested resources, and API versioning."
      },
      "content": "\n##  Backend Routing: How Requests Find Their Way Home\n\n### 1. Fundamentals of Routing\n\n|Request Component|Purpose (The \"What\" vs. The \"Where\")|\n|---|---|\n|**HTTP Method** (e.g., GET, POST)|Expresses the **intent** or **action** (the **What**) the client wants to perform (e.g., fetch data, add data, delete data).|\n|**Route Path** (URL Path)|Expresses the **address** or **resource** (the **Where**) the action should be performed on (e.g., `/users`, `/products`).|\n|**Routing Definition**|Routing is the process of mapping the unique combination of the **HTTP Method** and the **Route Path** to a specific server-side handler or set of instructions (business logic).|\n\n### 2. Types of Routes\n\nThe backend categorizes routes based on how the URL path is defined and what kind of data is passed.\n\n#### A. Static Routes\n\n- **Definition:** Routes where the path remains constant and contains no variable parameters.\n    \n- **Characteristic:** The string in the path is fixed (e.g., `/api/books`).\n    \n- **Mapping Example:**\n    \n    - `GET /api/books` maps to a handler that returns a list of books.\n        \n    - `POST /api/books` maps to a handler that creates a new book.\n        \n    - _The same path can be used for different methods, mapping to unique logic._\n        \n\n#### B. Dynamic Routes (Path/Route Parameters)\n\n- **Definition:** Routes that contain a dynamic, variable segment within the URL path, used to identify a specific resource.\n    \n- **Usage:** Serves as a **semantic expression** of the resource's identity.\n    \n- **Server Convention:** In the server-side definition, the dynamic part is typically marked with a colon (e.g., `:ID`).\n    \n- **Examples:**\n    \n    - **Request:** `/api/users/`**`123`**\n        \n    - **Server Match:** `/api/users/`**`:ID`**\n        \n    - **Semantic Meaning:** \"Fetch the user resource with ID `123`.\"\n        \n\n**Conceptual Flow of Dynamic Route Matching:**\n\nCode snippet\n\n```\ngraph TD\n    A[Client Sends GET /api/users/123] --> B{Server Route Matcher};\n    B --> C{Matches GET};\n    B --> D{Matches Path Prefix /api/users/};\n    B --> E{Captures '123' as the :ID Parameter};\n    C & D & E --> F[Handler for /api/users/:ID];\n    F --> G[Logic: Fetch user where ID = 123 from DB];\n```\n\n### 3. Parameters in Requests\n\n|Feature|Path/Route Parameters|Query Parameters|\n|---|---|---|\n|**Location**|Part of the main URL path, following a forward slash (`/`).|Appended to the end of the path, starting with a question mark (`?`).|\n|**Format**|`/resource/:id`|`?key1=value1&key2=value2`|\n|**Semantic Role**|**Essential**Defines the specific resource being requested (its address/identity).|**Supplemental**Sends metadata, filtering, sorting, or pagination criteria.|\n|**Typical Use**|Fetching a single item by ID (`/posts/456`).|Used primarily in `GET` requests (which lack a request body) to send extra key-value data.|\n|**Example**|`/users/`**`123`**|`/books?`**`page=2`**`&limit=20`|\n\n### 4. Advanced Routing Concepts\n\n#### A. Nested Routes\n\n- **Definition:** A structuring practice where the route path reflects the hierarchical relationship between different resources.\n    \n- **Purpose:** Provides a human-readable, highly semantic expression of a relationship.\n    \n- **Example:**\n    \n    - `GET /api/users/123/posts/456`\n        \n    - **Interpretation:** Fetch the specific post with ID **`456`** that belongs to the user with ID **`123`**.\n        \n\n#### B. Route Versioning and Deprecation\n\n- **Definition:** Including an API version (e.g., `v1`, `v2`) directly in the route path.\n    \n- **Purpose:** Allows developers to introduce **breaking changes** (like modifying a field name in the JSON response) without immediately breaking existing clients.\n    \n- **Workflow:**\n    \n    1. Client uses old route: `/api/`**`v1`**`/products`.\n        \n    2. New requirements mandate a change. A new version is released: `/api/`**`v2`**`/products`.\n        \n    3. Front-end clients are given a grace period to migrate from `v1` to `v2`.\n        \n    4. `v1` is eventually **deprecated** and removed, maintaining a stable API.\n        \n\n|Version|Example Path|Product Response Change|\n|---|---|---|\n|**V1**|`/api/v1/products`|Field name is **`name`**|\n|**V2**|`/api/v2/products`|Field name is **`title`**|\n\n#### C. Catch-All Route\n\n- **Definition:** The final, default route configured on the server, designed to match any request that has not been matched by any specific route (static, dynamic, or nested).\n    \n- **Server Convention:** Usually set up with a wildcard path (e.g., `/*`).\n    \n- **Purpose:** To provide a graceful error handling mechanism. Instead of returning a technical or null error, the Catch-All Handler returns a user-friendly \"Route Not Found\" message (typically a 404 status code).",
      "excerpt": "A comprehensive guide to backend routing covering HTTP methods, static and dynamic routes, parameters, nested resources, and API versioning.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-10-08T05:38:05.407Z"
    },
    {
      "id": "501-db-drizzle-md",
      "slug": "501-db/drizzle",
      "filepath": "501-DB/Drizzle.md",
      "folder": "501-DB",
      "filename": "Drizzle.md",
      "frontmatter": {
        "title": "Drizzle",
        "date": "2025-09-06",
        "tags": [
          "ts",
          "sql"
        ],
        "category": "501-DB"
      },
      "content": "\n> [!NOTE] DEF\n> Drizzle is a **headless TypeScript ORM** (Object-Relational Mapper) that prioritizes performance, type safety, and a familiar SQL-like syntax. Unlike traditional ORMs that might hide SQL from you, Drizzle empowers you to write queries that closely mirror raw SQL, but with the full safety of TypeScript.\n\n**Key Features:**\n\n- **Type Safety:** If your query is valid in TypeScript, it's a valid SQL query. This catches errors at compile-time, not runtime.\n    \n- **Performance:** Drizzle is extremely lightweight and boasts near-native SQL driver performance.\n    \n- **SQL-like Syntax:** You don't need to learn a complex new query language. If you know SQL, you'll feel right at home.\n    \n- **Schema as Code:** Your database schema is defined directly in your TypeScript files, enabling version control and a single source of truth.\n    \n\n---\n\n###  Approach 1: Codebase-First (The Standard Workflow)\n\nIn this approach, your **TypeScript schema files are the single source of truth**. You define your database structure in code, and Drizzle's tooling generates the necessary SQL to make your database match that code.\n\n#### Workflow Steps\n\n**1. Define or Modify Your Schema**\n\nYou start by defining your tables in a `.ts` file (e.g., `src/db/schema.ts`). Drizzle provides functions like `pgTable`, `mysqlTable`, or `sqliteTable` to define tables and various data types for columns.\n\n\n```ts\n// src/db/schema.ts\nimport { relations } from 'drizzle-orm';\nimport { pgTable, serial, text, varchar } from 'drizzle-orm/pg-core';\n\nexport const users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  fullName: text('full_name'),\n  email: varchar('email', { length: 256 }).notNull().unique(),\n});\n\nexport const posts = pgTable('posts', {\n  id: serial('id').primaryKey(),\n  content: text('content').notNull(),\n  authorId: serial('author_id').references(() => users.id),\n});\n\n// Optional: Define relationships for type-safe joins\nexport const usersRelations = relations(users, ({ many }) => ({\n  posts: many(posts),\n}));\n```\n\n**2. Generate Migration Files **\n\nAfter you create or change your schema, you use the **Drizzle Kit** command-line tool to generate an SQL migration file.\n\nBash\n\n```\nnpx drizzle-kit generate:pg\n```\n\nThis command inspects your TypeScript schema, compares it to its last known state, and generates a new SQL file in your migrations folder. For example, if you just added the `posts` table, the generated SQL file might look like this:\n\nSQL\n\n```sql\n-- migrations/0001_initial_posts.sql\nCREATE TABLE IF NOT EXISTS \"posts\" (\n\t\"id\" serial PRIMARY KEY NOT NULL,\n\t\"content\" text NOT NULL,\n\t\"author_id\" serial\n);\n\nDO $$ BEGIN\n ALTER TABLE \"posts\" ADD CONSTRAINT \"posts_author_id_users_id_fk\" FOREIGN KEY (\"author_id\") REFERENCES \"public\".\"users\"(\"id\") ON DELETE no action ON UPDATE no action;\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n```\n\n**3. Apply the Migration**\n\nFinally, you run the migration against your database. Drizzle Kit provides a command for this as well.\n\nBash\n\n```\nnpx drizzle-kit migrate:pg\n```\n\nThis command connects to your database, checks which migrations haven't been applied yet, and executes them in order.\n\n####  Pros &  Cons\n\n- ** Pros:**\n    \n    - **Single Source of Truth:** Your Git repository contains the entire history and definition of your database.\n        \n    - **Full Type Safety:** Your application code is always in sync with your schema.\n        \n    - **Collaboration:** Easy for teams to collaborate on schema changes through pull requests.\n        \n- ** Cons:**\n    \n    - Requires a disciplined workflow; manual changes to the database can cause drift.\n        \n\n---\n\n###  Approach 2: Database-First (Introspection)\n\nIn this approach, your **existing database is the single source of truth**. This is perfect for projects with a pre-existing database or where a Database Administrator (DBA) manages the schema directly.\n\n#### Workflow Steps\n\n**1. Point Drizzle Kit to Your Database**\n\nYou need an existing database with tables and columns already defined.\n\n**2. Introspect the Database **\n\nYou run the Drizzle Kit `introspect` command:\n\nBash\n\n```\nnpx drizzle-kit introspect:pg\n```\n\nDrizzle Kit connects to your database, reads its entire schema (tables, columns, types, relations, etc.), and **generates the corresponding TypeScript schema files for you**.\n\nThe output will be a complete `schema.ts` file that perfectly mirrors your database's current state, ready for you to use in your application for type-safe querying.\n\n####  Pros &  Cons\n\n- ** Pros:**\n    \n    - **Perfect for Existing Projects:** The easiest way to adopt Drizzle without rebuilding your schema from scratch.\n        \n    - **DBA-Friendly:** Allows database schemas to be managed by dedicated tools or teams while developers still get type-safe clients.\n        \n- ** Cons:**\n    \n    - You lose the \"single source of truth\" in your codebase. Schema changes must be made in the database first, then re-introspected.\n        \n\n---\n\n### In-Depth: Migration & Generation Techniques\n\nDrizzle Kit offers two primary ways to sync your schema with your database, which are crucial to understand.\n\n#### `drizzle-kit push` (For Prototyping)\n\nThe `push` command is a fast, simple way to make your database schema match your TypeScript schema.\n\nBash\n\n```\nnpx drizzle-kit push:pg\n```\n\n- **How it Works:** It directly compares your code schema with the database and generates and applies the necessary SQL `ALTER` statements to sync them. It **does not create migration files**.\n    \n- **When to Use It:** **Only for local development and prototyping.** It's a destructive tool, meaning it can drop columns or data if you're not careful. It's great for quickly iterating on your schema during early development.\n    \n- ** Warning:** **Never use `push` in a production environment.**\n    \n\n#### `drizzle-kit migrate` (For Production)\n\nThe `migrate` command is the production-safe method for applying schema changes.\n\nBash\n\n```\nnpx drizzle-kit migrate:pg\n```\n\n- **How it Works:** It relies on the migration files you create with `drizzle-kit generate`. It keeps track of which migrations have already been applied (in a special `__drizzle_migrations` table) and only runs the new ones.\n    \n- **When to Use It:** For all environments other than initial local development (Staging, Production). It provides a reliable, repeatable, and historical log of every schema change.\n    \n\n#### Drizzle Studio: Visual Generation\n\nDrizzle Kit also includes a powerful utility called **Drizzle Studio**, a GUI for your database.\n\nBash\n\n```\nnpx drizzle-kit studio\n```\n\nThis command opens a browser window with a clean interface to view, add, and edit data in your database. It's an excellent tool for debugging and visualizing your schema without needing a heavy, external database client.",
      "excerpt": "> [!NOTE] DEF\n> Drizzle is a headless TypeScript ORM (Object-Relational Mapper) that prioritizes performance, type safety, and a familiar SQL-like syntax. Unlike traditional ORMs that might hide SQL f...",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-09-06T06:32:45.785Z"
    },
    {
      "id": "501-db-postgressql-md",
      "slug": "501-db/postgressql",
      "filepath": "501-DB/PostgresSQL.md",
      "folder": "501-DB",
      "filename": "PostgresSQL.md",
      "frontmatter": {
        "title": "Basic Commands:",
        "date": "2025-07-26",
        "tags": [
          "sql",
          "database",
          "querying",
          "ddl",
          "dml",
          "operators",
          "joins"
        ],
        "category": "501-DB",
        "description": "A foundational guide to SQL commands covering table manipulation, data selection operators, joins, and the rules for using the union operator."
      },
      "content": "# Basic Commands:\n\n### Create Table\n```sql\nCREATE TABLE cars (  \nbrand VARCHAR(255),  \nmodel VARCHAR(255),  \n year INT  \n);\n```\n\n### Insert into \n```sql\nINSERT INTO cars (brand, model, year)  \nVALUES ('Ford', 'Mustang', 1964);\n```\n\n### Alter table\n```sql\nALTER TABLE cars  \nADD color VARCHAR(255);\n```\n\n```sql\nALTER TABLE cars  \nALTER COLUMN year TYPE VARCHAR(4);\n```\n### Update Table\n```sql\nUPDATE cars  \nSET color = 'red'  \nWHERE brand = 'Volvo';\n```\n\n### Where Clause (All operators):\nWe can operate with different operators in the `WHERE` clause:\n\n|           |                                                                  |\n| --------- | ---------------------------------------------------------------- |\n| `=`       | Equal to                                                         |\n| `<`       | Less than                                                        |\n| `>`       | Greater than                                                     |\n| `<=`      | Less than or equal to                                            |\n| `>=`      | Greater than or equal to                                         |\n| `<>`      | Not equal to                                                     |\n| `!=`      | Not equal to                                                     |\n| `LIKE`    | Check if a value matches a pattern (case sensitive)              |\n| `ILIKE`   | Check if a value matches a pattern (case insensitive)            |\n| `AND`     | Logical AND                                                      |\n| `OR`      | Logical OR                                                       |\n| `IN`      | Check if a value is between a range of values                    |\n| `BETWEEN` | Check if a value is between a range of values                    |\n| `IS NULL` | Check if a value is NULL                                         |\n| `NOT`     | Makes a negative result e.g. `NOT LIKE`, `NOT IN`, `NOT BETWEEN` |\n\n### JOINS:\n![[Pasted image 20250726191832.png]]\n\n### UNION:\n\nThe `UNION` operator is used to combine the result-set of two or more queries.\n\nThe queries in the union must follow these rules:\n\n- They must have the same number of columns\n- The columns must have the same data types\n- The columns must be in the same order\n\nCombine `products` and `testproducts` using the `UNION` operator:\n```sql\nSELECT product_id, product_name  \nFROM products  \nUNION  \nSELECT testproduct_id, product_name  \nFROM testproducts  \nORDER BY product_id;\n```\n",
      "excerpt": "A foundational guide to SQL commands covering table manipulation, data selection operators, joins, and the rules for using the union operator.",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-07-26T13:50:34.000Z"
    },
    {
      "id": "501-db-redis-md",
      "slug": "501-db/redis",
      "filepath": "501-DB/REDIS.md",
      "folder": "501-DB",
      "filename": "REDIS.md",
      "frontmatter": {
        "title": "What is Redis?",
        "date": "2025-09-01",
        "category": "501-DB"
      },
      "content": "## What is Redis?\n\nRedis is an in-memory database that is significantly faster than traditional disk-based databases. It can be used for various purposes, including caching, message queues, and coordination.\n\n---\n\n## Why Redis?\n\nImagine a traditional database being pinged for every query, leading to high latency, increased load on the database, and financial costs. Redis helps solve this problem by creating a database in memory to handle repeated calls for the same data, offloading the traditional database.\n\n---\n\n## Where and for What Should I Use Redis?\n\nYou can determine if Redis is the right tool for a scenario by asking a few key questions:\n\n- **Am I fetching the same data repeatedly?** Redis can cache this data.\n    \n- **Do I need very fast read/write speeds, in microseconds?** Redis operations are much faster than traditional databases.\n    \n- **Do I need a queue or a pub/sub system for coordination?** Redis Lists can be used for this.\n    \n- **Is it okay if this data is temporary or can be reconstructed?** 8\n    \n\n### Why Do I Need a Queue?\n\nA queue is useful when tasks arrive faster than you can process them, or when you need controlled, background processing. For example, if 1000 customers place a food order at once, you can't process them all simultaneously. Instead, you can add them to a queue to be processed on a \"first come, first serve\" basis. This allows customers to wait while their orders are processed.\n\n### What is Coordination?\n\nCoordination ensures that systems or workers don't clash with each other and instead work together peacefully. For example, if you have 10 chefs, you want to make sure only one chef takes a specific pizza order.\n\n---\n\n## How to Use Redis\n\n### Caching Repeated Data\n\nA common use case for Redis is caching. For instance, in a news app that shows the top 10 trending stories, many users may open the app at once, and a database call for each user could overload the database. A better solution is to cache the trending news in Redis so that subsequent requests hit the cache instead of the database16. The cache can be refreshed when new news becomes available.\n\nA common workflow is to first check if the data exists in Redis. If it does, return the cached data19. If not, fetch the data from the source database, store it in Redis with an expiration time, and then return the data.\n\n### Redis Methods\n\n- **get**: Retrieves the value of a key.\n    \n- **setex**: Sets a key to a value and specifies a time-to-live (expiration time)22.\n    \n- **set**: Sets a key to a value with no expiration.\n    \n- **getset**: Sets a key to a new value and returns the old value.\n    \n- **del**: Deletes one or more keys.\n    \n- **exists**: Checks if a key exists.\n    \n- **expire**: Sets a timeout on an existing key in seconds.\n    \n- **ttl**: Returns the remaining time-to-live for a key in seconds.\n    \n- **persist**: Removes the expiration from a key.\n    \n- **incr**: Increments the integer value of a key by .\n    \n- **decr**: Decrements the integer value of a key by .\n    \n- **incrby**: Increments the integer value of a key by a specified amount.\n    \n\n### Using Redis for Queues\n\nWhen orders arrive faster than you can process them, you can use a queue. You can push tasks into a queue using\n\n`lpush` and have a background worker pull them using `brpop`. This approach frees up your web app to handle other tasks while the worker processes the queue in the background. This is good for apps that perform background tasks like image processing or other operations that shouldn't block the user36.\n\n---\n\n## Redis Data Types\n\nRedis is a key-value store where every piece of data requires a key. You can store anything in Redis as long as you model it using one of its data types.\n\n| Redis Data Type       | Stored As (Key  Value)             | What It Looks Like                                      | Common Use Cases                                 |\n| --------------------- | ----------------------------------- | ------------------------------------------------------- | ------------------------------------------------ |\n| **String**            | key  string (text/number)          | `SET user:1 \"Ajeet\"`                                    | Caching values, counters, feature flags, tokens  |\n| **List**              | key  ordered list                  | `LPUSH queue \"task1\"`  `[\"task1\", \"task2\"]`            | Message queues, task lists, chat history         |\n| **Set**               | key  unordered unique items        | `SADD online_users 101 102`  `{101, 102}`              | Unique visitors, tags, \"likes\"                   |\n| **Sorted Set (ZSET)** | key  set + scores (sorted)         | `ZADD leaderboard 500 \"player1\"`  `[(\"player1\", 500)]` | Leaderboards, rankings, priority queues          |\n| **Hash**              | key  field-value pairs (mini JSON) | `HSET user:1 name \"Ajeet\" age 25`                       | User profiles, product info, config maps         |\n| **Stream**            | key  append-only log of events     | `XADD mystream * message \"Hi\"`                          | Event sourcing, chat feeds, logs                 |\n| **Bitmap**            | key  bit array                     | `SETBIT logins 51`                                      | Track daily activity (yes/no), flags             |\n| **HyperLogLog**       | key  probabilistic counter         | `PFADD unique_users user123`                            | Count unique items (e.g., unique visitors)       |\n| **Geospatial**        | key  geo-coordinates (lat, lon)    | `GEOADD locations 77.1 28.6 \"Delhi\"`                    | Find nearby places, \"who's closest\" lookups      |\n",
      "excerpt": "What is Redis?\n\nRedis is an in-memory database that is significantly faster than traditional disk-based databases. It can be used for various purposes, including caching, message queues, and coordinat...",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-09-01T12:49:38.081Z"
    },
    {
      "id": "991-clang-data-types-md",
      "slug": "991-clang/data-types",
      "filepath": "991-CLANG/Data Types.md",
      "folder": "991-CLANG",
      "filename": "Data Types.md",
      "frontmatter": {
        "title": "Boolean Expression:",
        "date": "2025-07-01",
        "tags": [
          "c",
          "include"
        ],
        "category": "991-CLANG"
      },
      "content": "| Data Type | Size         | Description                                                                                           | Example |\n| --------- | ------------ | ----------------------------------------------------------------------------------------------------- | ------- |\n| `int`     | 2 or 4 bytes | Stores whole numbers, without decimals                                                                | `1`     |\n| `float`   | 4 bytes      | Stores fractional numbers, containing one or more decimals. Sufficient for storing 6-7 decimal digits | `1.99`  |\n| `double`  | 8 bytes      | Stores fractional numbers, containing one or more decimals. Sufficient for storing 15 decimal digits  | `1.99`  |\n| `char`    | 1 byte       | Stores a single character/letter/number, or ASCII values                                              | `'A'`   |\n\n\n\n| `%d` or `%i` | `int`                                                                                                                        |     |\n| ------------ | ---------------------------------------------------------------------------------------------------------------------------- | --- |\n| `%f` or `%F` | `float`                                                                                                                      |     |\n| `%lf`        | `double`                                                                                                                     |     |\n| `%c`         | `char`                                                                                                                       |     |\n| `%s`         | Used for **[strings](https://www.w3schools.com/c/c_strings.php) (text)**, which you will learn more about in a later chapter |     |\n\n## Boolean Expression:\n```c\n#include <stdbool.h>\n\nbool isProgrammingFun = true;  \nbool isFishTasty = false;\n// returned as 0,1\n\n```\n\n\n## Short Hand if else:\n```c\n_variable_ = (_condition_) ? _expressionTrue_ : _expressionFalse_;\n```\n\n\n## Switch statements:\n```c\nswitch (_expression_) {  \n case x:  \n _// code block_  \n break;  \n case y:  \n _// code block_  \n break;  \n default:  \n _// code block_  \n}\n```\n\n### *sizeof() includes the \\0 wehere as strlen does not!!!*\n\n\n\n",
      "excerpt": "| Data Type | Size         | Description                                                                                           | Example |\n| --------- | ------------ | ----------------------------...",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-07-01T16:57:00.000Z"
    },
    {
      "id": "991-clang-file-io-and-strings-md",
      "slug": "991-clang/file-io-and-strings",
      "filepath": "991-CLANG/File IO and Strings.md",
      "folder": "991-CLANG",
      "filename": "File IO and Strings.md",
      "frontmatter": {
        "title": "File IO and Strings",
        "date": "2025-08-07",
        "tags": [
          "c",
          "include"
        ],
        "category": "991-CLANG"
      },
      "content": "\n### Reading from a File Line by Line\n\n```c\n\n  FILE *fptr;\n  fptr = fopen(argv[1], \"r\");\n  if (fptr == NULL) {\n    perror(\"Error opening file\");\n    return 1;\n  }\n\n  char line[1028];\n  int points = 0;\n\n  while (fgets(line, sizeof(line), fptr)) {\n    line[strcspn(line, \"\\n\")] = 0;\n    printf(\"Processing line: %s\\n\", line);\n}\n\n```\n\n\n### Splitting Strings using strtok\n\n```c\n#include <string.h>\n#include <stdio.h>\n\nchar** split_string(const char *str, char delimiter) {\n    char *delimiter_ptr = strchr(str, delimiter);\n\n    if (delimiter_ptr == NULL) {\n        return NULL;\n    }\n\n    size_t first_part_len = delimiter_ptr - str;\n\n    char **result = malloc(sizeof(char*) * 2);\n    if (result == NULL) {\n        return NULL;\n    }\n\n    result[0] = malloc(first_part_len + 1);\n    if (result[0] == NULL) {\n        free(result);\n        return NULL;\n    }\n    strncpy(result[0], str, first_part_len);\n    result[0][first_part_len] = '\\0';\n\n    size_t second_part_len = strlen(delimiter_ptr + 1);\n    result[1] = malloc(second_part_len + 1);\n    if (result[1] == NULL) {\n        free(result[0]);\n        free(result);\n        return NULL;\n    }\n    strcpy(result[1], delimiter_ptr + 1);\n\n    return result;\n}\n```\n",
      "excerpt": "Reading from a File Line by Line\n\n\n\n\nSplitting Strings using strtok",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-08-07T14:46:06.000Z"
    },
    {
      "id": "991-clang-make-file-md",
      "slug": "991-clang/make-file",
      "filepath": "991-CLANG/Make File.md",
      "folder": "991-CLANG",
      "filename": "Make File.md",
      "frontmatter": {
        "title": "Typically blah.c would already exist, but I want to limit any additional required files",
        "date": "2025-07-23",
        "tags": [
          "C",
          "ffb8eba6",
          "variables",
          "automatic",
          "1",
          "2",
          "the",
          "string",
          "makefile"
        ],
        "category": "991-CLANG"
      },
      "content": "## Why do Makefiles exist?\n\nMakefiles are used to help decide which parts of a large program need to be recompiled. In the vast majority of cases, C or C++ files are compiled. Other languages typically have their own tools that serve a similar purpose as Make. Make can also be used beyond compilation too, when you need a series of instructions to run depending on what files have changed. This tutorial will focus on the C/C++ compilation use case.\n\n## The versions and types of Make\n\nThere are a variety of implementations of Make, but most of this guide will work on whatever version you're using. However, it's specifically written for GNU Make, which is the standard implementation on Linux and MacOS. All the examples work for Make versions 3 and 4, which are nearly equivalent other than some esoteric differences.\n\n## Running the Examples\n\nTo run these examples, you'll need a terminal and \"make\" installed. For each example, put the contents in a file called `Makefile`, and in that directory run the command `make`. Let's start with the simplest of Makefiles:\n\n```C\nhello:\n\techo \"Hello, World\"\n```\n\n> Note: Makefiles **must** be indented using TABs and not spaces or `make` will fail.\n\nHere is the output of running the above example:\n\n```C\n$ make\necho \"Hello, World\"\nHello, World\n```\n\nThat's it! If you're a bit confused, here's a video that goes through these steps, along with describing the basic structure of Makefiles.\n\n## Makefile Syntax\n\nA Makefile consists of a set of _rules_. A rule generally looks like this:\n\n```\ntargets: prerequisites\n\tcommand\n\tcommand\n\tcommand\n```\n\n- The _targets_ are file names, separated by spaces. Typically, there is only one per rule.\n- The _commands_ are a series of steps typically used to make the target(s). These _need to start with a tab character_, not spaces.\n- The _prerequisites_ are also file names, separated by spaces. These files need to exist before the commands for the target are run. These are also called _dependencies_\n\n## The essence of Make\n\nLet's start with a hello world example:\n\n```\nhello:\n\techo \"Hello, World\"\n\techo \"This line will print if the file hello does not exist.\"\n```\n\n- We have one _target_ called `hello`\n- This target has two _commands_\n- This target has no _prerequisites_\n\nWe'll then run `make hello`. As long as the `hello` file does not exist, the commands will run. If `hello` does exist, no commands will run.\n\nIt's important to realize that I'm talking about `hello` as both a _target_ and a _file_. That's because the two are directly tied together. Typically, when a target is run (aka when the commands of a target are run), the commands will create a file with the same name as the target. In this case, the `hello` _target_ does not create the `hello` _file_.\n\nLet's create a more typical Makefile - one that compiles a single C file. But before we do, make a file called `blah.c` that has the following contents:\n\n```C\n// blah.c\nint main() { return 0; }\n```\n\nThen create the Makefile (called `Makefile`, as always):\n\n```C\nblah:\n\tcc blah.c -o blah\n```\n\nThis time, try simply running `make`. Since there's no target supplied as an argument to the `make` command, the first target is run. In this case, there's only one target (`blah`). The first time you run this, `blah` will be created. The second time, you'll see `make: 'blah' is up to date`. That's because the `blah` file already exists. But there's a problem: if we modify `blah.c` and then run `make`, <mark style=\"background: #FFB8EBA6;\">nothing gets recompiled</mark>.\n\nWe solve this by adding a prerequisite:\n\n```C\nblah: blah.c\n\tcc blah.c -o blah\n```\n\nWhen we run `make` again, the following set of steps happens:\n\n- The first target is selected, because the first target is the default target\n- This has a prerequisite of `blah.c`\n- Make decides if it should run the `blah` target. It will only run if `blah` doesn't exist, or `blah.c` is _newer than_ `blah`\n\nThis last step is critical, and is the **essence of make**. What it's attempting to do is decide if the prerequisites of `blah` have changed since `blah` was last compiled. That is, if `blah.c` is modified, running `make` should recompile the file. And conversely, if `blah.c` has not changed, then it should not be recompiled.\n\nTo make this happen, **it uses the filesystem timestamps as a proxy to determine if something has changed.** This is a reasonable heuristic, because file timestamps typically will only change if the files are modified. But it's important to realize that this isn't always the case. You could, for example, modify a file, and then change the modified timestamp of that file to something old. If you did, Make would incorrectly guess that the file hadn't changed and thus could be ignored.\n\nWhew, what a mouthful. **Make sure that you understand this. It's the crux of Makefiles, and might take you a few minutes to properly understand**. \n\n## More quick examples\n\nThe following Makefile ultimately runs all three targets. When you run `make` in the terminal, it will build a program called `blah` in a series of steps:\n\n- Make selects the target `blah`, because the first target is the default target\n- `blah` requires `blah.o`, so make searches for the `blah.o` target\n- `blah.o` requires `blah.c`, so make searches for the `blah.c` target\n- `blah.c` has no dependencies, so the `echo` command is run\n- The `cc -c` command is then run, because all of the `blah.o` dependencies are finished\n- The top `cc` command is run, because all the `blah` dependencies are finished\n- That's it: `blah` is a compiled c program\n\n```\nblah: blah.o\n\tcc blah.o -o blah # Runs third\n\nblah.o: blah.c\n\tcc -c blah.c -o blah.o # Runs second\n\n# Typically blah.c would already exist, but I want to limit any additional required files\nblah.c:\n\techo \"int main() { return 0; }\" > blah.c # Runs first\n```\n\nIf you delete `blah.c`, all three targets will be rerun. If you edit it (and thus change the timestamp to newer than `blah.o`), the first two targets will run. If you run `touch blah.o` (and thus change the timestamp to newer than `blah`), then only the first target will run. If you change nothing, none of the targets will run. Try it out!\n\nThis next example doesn't do anything new, but is nontheless a good additional example. It will always run both targets, because `some_file` depends on `other_file`, which is never created.\n\n```\nsome_file: other_file\n\techo \"This will always run, and runs second\"\n\ttouch some_file\n\nother_file:\n\techo \"This will always run, and runs first\"\n```\n\n## Make clean\n\n`clean` is often used as a target that removes the output of other targets, but it is not a special word in Make. You can run `make` and `make clean` on this to create and delete `some_file`.\n\nNote that `clean` is doing two new things here:\n\n- It's a target that is not first (the default), and not a prerequisite. That means it'll never run unless you explicitly call `make clean`\n- It's not intended to be a filename. If you happen to have a file named `clean`, this target won't run, which is not what we want. See `.PHONY` later in this tutorial on how to fix this\n\n```\nsome_file: \n\ttouch some_file\n\nclean:\n\trm -f some_file\n```\n\n## Variables\n\nVariables can only be strings. You'll typically want to use `:=`, but `=` also works. See [Variables Pt 2](https://makefiletutorial.com/#variables-pt-2).\n\nHere's an example of using variables:\n\n```C\nfiles := file1 file2\nsome_file: $(files)\n\techo \"Look at this variable: \" $(files)\n\ttouch some_file\n\nfile1:\n\ttouch file1\nfile2:\n\ttouch file2\n\nclean:\n\trm -f file1 file2 some_file\n```\n\nSingle or double quotes have no meaning to Make. They are simply characters that are assigned to the variable. Quotes _are_ useful to shell/bash, though, and you need them in commands like `printf`. In this example, the two commands behave the same:\n\n```\na := one two# a is set to the string \"one two\"\nb := 'one two' # Not recommended. b is set to the string \"'one two'\"\nall:\n\tprintf '$a'\n\tprintf $b\n```\n\nReference variables using either `${}` or `$()`\n\n```\nx := dude\n\nall:\n\techo $(x)\n\techo ${x}\n\n\t# Bad practice, but works\n\techo $x \n```\n\n# Targets\n\n## The all target\n\nMaking multiple targets and you want all of them to run? Make an `all` target. Since this is the first rule listed, it will run by default if `make` is called without specifying a target.\n\n```\nall: one two three\n\none:\n\ttouch one\ntwo:\n\ttouch two\nthree:\n\ttouch three\n\nclean:\n\trm -f one two three\n```\n\n## Multiple targets\n\nWhen there are multiple targets for a rule, the commands will be run for each target. `$@` is an [automatic variable](https://makefiletutorial.com/#automatic-variables) that contains the target name.\n\n```\nall: f1.o f2.o\n\nf1.o f2.o:\n\techo $@\n# Equivalent to:\n# f1.o:\n#\t echo f1.o\n# f2.o:\n#\t echo f2.o\n```\n\n# Automatic Variables and Wildcards\n\n## * Wildcard\n\nBoth `*` and `%` are called wildcards in Make, but they mean entirely different things. `*` searches your filesystem for matching filenames. I suggest that you always wrap it in the `wildcard` function, because otherwise you may fall into a common pitfall described below.\n\n```\n# Print out file information about every .c file\nprint: $(wildcard *.c)\n\tls -la  $?\n```\n\n`*` may be used in the target, prerequisites, or in the `wildcard` function.\n\nDanger: `*` may not be directly used in a variable definitions\n\nDanger: When `*` matches no files, it is left as it is (unless run in the `wildcard` function)\n\n```\nthing_wrong := *.o # Don't do this! '*' will not get expanded\nthing_right := $(wildcard *.o)\n\nall: one two three four\n\n# Fails, because $(thing_wrong) is the string \"*.o\"\none: $(thing_wrong)\n\n# Stays as *.o if there are no files that match this pattern :(\ntwo: *.o \n\n# Works as you would expect! In this case, it does nothing.\nthree: $(thing_right)\n\n# Same as rule three\nfour: $(wildcard *.o)\n```\n\n## % Wildcard\n\n`%` is really useful, but is somewhat confusing because of the variety of situations it can be used in.\n\n- When used in \"matching\" mode, it matches one or more characters in a string. This match is called the stem.\n- When used in \"replacing\" mode, it takes the stem that was matched and replaces that in a string.\n- `%` is most often used in rule definitions and in some specific functions.\n\n\n# Fancy Rules\n\n## Implicit Rules\n\nMake loves c compilation. And every time it expresses its love, things get confusing. Perhaps the most confusing part of Make is the magic/automatic rules that are made. Make calls these \"implicit\" rules. I don't personally agree with this design decision, and I don't recommend using them, but they're often used and are thus useful to know. Here's a list of implicit rules:\n\n- Compiling a C program: `n.o` is made automatically from `n.c` with a command of the form `$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@`\n- Linking a single object file: `n` is made automatically from `n.o` by running the command `$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@`\n\nThe important variables used by implicit rules are:\n\n- `CC`: Program for compiling C programs; default `cc`\n- `CXX`: Program for compiling C++ programs; default `g++`\n- `CFLAGS`: Extra flags to give to the C compiler\n- `CXXFLAGS`: Extra flags to give to the C++ compiler\n- `CPPFLAGS`: Extra flags to give to the C preprocessor\n- `LDFLAGS`: Extra flags to give to compilers when they are supposed to invoke the linker\n\nLet's see how we can now build a C program without ever explicitly telling Make how to do the compilation:\n\n```C\nCC = gcc # Flag for implicit rules\nCFLAGS = -g # Flag for implicit rules. Turn on debug info\n\n# Implicit rule #1: blah is built via the C linker implicit rule\n# Implicit rule #2: blah.o is built via the C compilation implicit rule, because blah.c exists\nblah: blah.o\n\nblah.c:\n\techo \"int main() { return 0; }\" > blah.c\n\nclean:\n\trm -f blah*\n```\n\n## Static Pattern Rules\n\nStatic pattern rules are another way to write less in a Makefile. Here's their syntax:\n\n```\ntargets...: target-pattern: prereq-patterns ...\n   commands\n```\n\nThe essence is that the given `target` is matched by the `target-pattern` (via a `%` wildcard). Whatever was matched is called the _stem_. The stem is then substituted into the `prereq-pattern`, to generate the target's prereqs.\n\nA typical use case is to compile `.c` files into `.o` files. Here's the _manual way_:\n\n```\nobjects = foo.o bar.o all.o\nall: $(objects)\n\t$(CC) $^ -o all\n\nfoo.o: foo.c\n\t$(CC) -c foo.c -o foo.o\n\nbar.o: bar.c\n\t$(CC) -c bar.c -o bar.o\n\nall.o: all.c\n\t$(CC) -c all.c -o all.o\n\nall.c:\n\techo \"int main() { return 0; }\" > all.c\n\n# Note: all.c does not use this rule because Make prioritizes more specific matches when there is more than one match.\n%.c:\n\ttouch $@\n\nclean:\n\trm -f *.c *.o all\n```\n\nHere's the more _efficient way_, using a static pattern rule:\n\n```\nobjects = foo.o bar.o all.o\nall: $(objects)\n\t$(CC) $^ -o all\n\n# Syntax - targets ...: target-pattern: prereq-patterns ...\n# In the case of the first target, foo.o, the target-pattern matches foo.o and sets the \"stem\" to be \"foo\".\n# It then replaces the '%' in prereq-patterns with that stem\n$(objects): %.o: %.c\n\t$(CC) -c $^ -o $@\n\nall.c:\n\techo \"int main() { return 0; }\" > all.c\n\n# Note: all.c does not use this rule because Make prioritizes more specific matches when there is more than one match.\n%.c:\n\ttouch $@\n\nclean:\n\trm -f *.c *.o all\n```\n\n## Static Pattern Rules and Filter\n\nWhile I introduce the [filter function](https://makefiletutorial.com/#the-filter-function) later on, it's common to use in static pattern rules, so I'll mention that here. The `filter` function can be used in Static pattern rules to match the correct files. In this example, I made up the `.raw` and `.result` extensions.\n\n```\nobj_files = foo.result bar.o lose.o\nsrc_files = foo.raw bar.c lose.c\n\nall: $(obj_files)\n# Note: PHONY is important here. Without it, implicit rules will try to build the executable \"all\", since the prereqs are \".o\" files.\n.PHONY: all \n\n# Ex 1: .o files depend on .c files. Though we don't actually make the .o file.\n$(filter %.o,$(obj_files)): %.o: %.c\n\techo \"target: $@ prereq: $<\"\n\n# Ex 2: .result files depend on .raw files. Though we don't actually make the .result file.\n$(filter %.result,$(obj_files)): %.result: %.raw\n\techo \"target: $@ prereq: $<\" \n\n%.c %.raw:\n\ttouch $@\n\nclean:\n\trm -f $(src_files)\n```\n\n## Pattern Rules\n\nPattern rules are often used but quite confusing. You can look at them as two ways:\n\n- A way to define your own implicit rules\n- A simpler form of static pattern rules\n\nLet's start with an example first:\n\n```\n# Define a pattern rule that compiles every .c file into a .o file\n%.o : %.c\n\t\t$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@\n```\n\nPattern rules contain a '%' in the target. This '%' matches any nonempty string, and the other characters match themselves. % in a prerequisite of a pattern rule stands for the same stem that was matched by the % in the target.\n\nHere's another example:\n\n```\n# Define a pattern rule that has no pattern in the prerequisites.\n# This just creates empty .c files when needed.\n%.c:\n   touch $@\n```\n\n## Double-Colon Rules\n\nDouble-Colon Rules are rarely used, but allow multiple rules to be defined for the same target. If these were single colons, a warning would be printed and only the second set of commands would run.\n\n```\nall: blah\n\nblah::\n\techo \"hello\"\n\nblah::\n\techo \"hello again\"\n```\n\n# Commands and execution\n\n## Command Echoing/Silencing\n\nAdd an `@` before a command to stop it from being printed  \nYou can also run make with `-s` to add an `@` before each line\n\n```\nall: \n\t@echo \"This make line will not be printed\"\n\techo \"But this will\"\n```\n\n## Command Execution\n\nEach command is run in a new shell (or at least the effect is as such)\n\n```\nall: \n\tcd ..\n\t# The cd above does not affect this line, because each command is effectively run in a new shell\n\techo `pwd`\n\n\t# This cd command affects the next because they are on the same line\n\tcd ..;echo `pwd`\n\n\t# Same as above\n\tcd ..; \\\n\techo `pwd`\n```\n\n## Default Shell\n\nThe default shell is `/bin/sh`. You can change this by changing the variable SHELL:\n\n```\nSHELL=/bin/bash\n\ncool:\n\techo \"Hello from bash\"\n```\n\n## Double dollar sign\n\nIf you want a string to have a dollar sign, you can use `$$`. This is how to use a shell variable in `bash` or `sh`.\n\nNote the differences between Makefile variables and Shell variables in this next example.\n\n```\nmake_var = I am a make variable\nall:\n\t# Same as running \"sh_var='I am a shell variable'; echo $sh_var\" in the shell\n\tsh_var='I am a shell variable'; echo $$sh_var\n\n\t# Same as running \"echo I am a make variable\" in the shell\n\techo $(make_var)\n```\n\n## Error handling with `-k`, `-i`, and `-`\n\nAdd `-k` when running make to continue running even in the face of errors. Helpful if you want to see all the errors of Make at once.  \nAdd a `-` before a command to suppress the error  \nAdd `-i` to make to have this happen for every command.\n\n```\none:\n\t# This error will be printed but ignored, and make will continue to run\n\t-false\n\ttouch one\n```\n\n## Interrupting or killing make\n\nNote only: If you `ctrl+c` make, it will delete the newer targets it just made.\n\n## Recursive use of make\n\nTo recursively call a makefile, use the special `$(MAKE)` instead of `make` because it will pass the make flags for you and won't itself be affected by them.\n\n```\nnew_contents = \"hello:\\n\\ttouch inside_file\"\nall:\n\tmkdir -p subdir\n\tprintf $(new_contents) | sed -e 's/^ //' > subdir/makefile\n\tcd subdir && $(MAKE)\n\nclean:\n\trm -rf subdir\n```\n\n## Export, environments, and recursive make\n\nWhen Make starts, it automatically creates Make variables out of all the environment variables that are set when it's executed.\n\n```\n# Run this with \"export shell_env_var='I am an environment variable'; make\"\nall:\n\t# Print out the Shell variable\n\techo $$shell_env_var\n\n\t# Print out the Make variable\n\techo $(shell_env_var)\n```\n\nThe `export` directive takes a variable and sets it the environment for all shell commands in all the recipes:\n\n```\nshell_env_var=Shell env var, created inside of Make\nexport shell_env_var\nall:\n\techo $(shell_env_var)\n\techo $$shell_env_var\n```\n\nAs such, when you run the `make` command inside of make, you can use the `export` directive to make it accessible to sub-make commands. In this example, `cooly` is exported such that the makefile in subdir can use it.\n\n```\nnew_contents = \"hello:\\n\\techo \\$$(cooly)\"\n\nall:\n\tmkdir -p subdir\n\tprintf $(new_contents) | sed -e 's/^ //' > subdir/makefile\n\t@echo \"---MAKEFILE CONTENTS---\"\n\t@cd subdir && cat makefile\n\t@echo \"---END MAKEFILE CONTENTS---\"\n\tcd subdir && $(MAKE)\n\n# Note that variables and exports. They are set/affected globally.\ncooly = \"The subdirectory can see me!\"\nexport cooly\n# This would nullify the line above: unexport cooly\n\nclean:\n\trm -rf subdir\n```\n\nYou need to export variables to have them run in the shell as well.\n\n```\none=this will only work locally\nexport two=we can run subcommands with this\n\nall: \n\t@echo $(one)\n\t@echo $$one\n\t@echo $(two)\n\t@echo $$two\n```\n\n`.EXPORT_ALL_VARIABLES` exports all variables for you.\n\n```\n.EXPORT_ALL_VARIABLES:\nnew_contents = \"hello:\\n\\techo \\$$(cooly)\"\n\ncooly = \"The subdirectory can see me!\"\n# This would nullify the line above: unexport cooly\n\nall:\n\tmkdir -p subdir\n\tprintf $(new_contents) | sed -e 's/^ //' > subdir/makefile\n\t@echo \"---MAKEFILE CONTENTS---\"\n\t@cd subdir && cat makefile\n\t@echo \"---END MAKEFILE CONTENTS---\"\n\tcd subdir && $(MAKE)\n\nclean:\n\trm -rf subdir\n```\n\n## Arguments to make\n\nThere's a nice [list of options](http://www.gnu.org/software/make/manual/make.html#Options-Summary) that can be run from make. Check out `--dry-run`, `--touch`, `--old-file`.\n\nYou can have multiple targets to make, i.e. `make clean run test` runs the `clean` goal, then `run`, and then `test`.\n\n# Variables Pt. 2\n\n## Flavors and modification\n\nThere are two flavors of variables:\n\n- recursive (use `=`) - only looks for the variables when the command is _used_, not when it's _defined_.\n- simply expanded (use `:=`) - like normal imperative programming -- only those defined so far get expanded\n\n```\n# Recursive variable. This will print \"later\" below\none = one ${later_variable}\n# Simply expanded variable. This will not print \"later\" below\ntwo := two ${later_variable}\n\nlater_variable = later\n\nall: \n\techo $(one)\n\techo $(two)\n```\n\nSimply expanded (using `:=`) allows you to append to a variable. Recursive definitions will give an infinite loop error.\n\n```\none = hello\n# one gets defined as a simply expanded variable (:=) and thus can handle appending\none := ${one} there\n\nall: \n\techo $(one)\n```\n\n`?=` only sets variables if they have not yet been set\n\n```\none = hello\none ?= will not be set\ntwo ?= will be set\n\nall: \n\techo $(one)\n\techo $(two)\n```\n\nSpaces at the end of a line are not stripped, but those at the start are. To make a variable with a single space, use `$(nullstring)`\n\n```\nwith_spaces = hello   # with_spaces has many spaces after \"hello\"\nafter = $(with_spaces)there\n\nnullstring =\nspace = $(nullstring) # Make a variable with a single space.\n\nall: \n\techo \"$(after)\"\n\techo start\"$(space)\"end\n```\n\nAn undefined variable is actually an empty string!\n\n```\nall: \n\t# Undefined variables are just empty strings!\n\techo $(nowhere)\n```\n\nUse `+=` to append\n\n```\nfoo := start\nfoo += more\n\nall: \n\techo $(foo)\n```\n\n[String Substitution](https://makefiletutorial.com/#string-substitution) is also a really common and useful way to modify variables. Also check out [Text Functions](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#Text-Functions) and [Filename Functions](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#File-Name-Functions).\n\n## Command line arguments and override\n\nYou can override variables that come from the command line by using `override`. Here we ran make with `make option_one=hi`\n\n```\n# Overrides command line arguments\noverride option_one = did_override\n# Does not override command line arguments\noption_two = not_override\nall: \n\techo $(option_one)\n\techo $(option_two)\n```\n\n## List of commands and define\n\nThe [define directive](https://www.gnu.org/software/make/manual/html_node/Multi_002dLine.html) is not a function, though it may look that way. I've seen it used so infrequently that I won't go into details, but it's mainly used for defining [canned recipes](https://www.gnu.org/software/make/manual/html_node/Canned-Recipes.html#Canned-Recipes) and also pairs well with the [eval function](https://www.gnu.org/software/make/manual/html_node/Eval-Function.html#Eval-Function).\n\n`define`/`endef` simply creates a variable that is set to a list of commands. Note here that it's a bit different than having a semi-colon between commands, because each is run in a separate shell, as expected.\n\n```\none = export blah=\"I was set!\"; echo $$blah\n\ndefine two\nexport blah=\"I was set!\"\necho $$blah\nendef\n\nall: \n\t@echo \"This prints 'I was set'\"\n\t@$(one)\n\t@echo \"This does not print 'I was set' because each command runs in a separate shell\"\n\t@$(two)\n```\n\n## Target-specific variables\n\nVariables can be set for specific targets\n\n```\nall: one = cool\n\nall: \n\techo one is defined: $(one)\n\nother:\n\techo one is nothing: $(one)\n```\n\n## Pattern-specific variables\n\nYou can set variables for specific target _patterns_\n\n```\n%.c: one = cool\n\nblah.c: \n\techo one is defined: $(one)\n\nother:\n\techo one is nothing: $(one)\n```\n\n# Conditional part of Makefiles\n\n## Conditional if/else\n\n```\nfoo = ok\n\nall:\nifeq ($(foo), ok)\n\techo \"foo equals ok\"\nelse\n\techo \"nope\"\nendif\n```\n\n## Check if a variable is empty\n\n```\nnullstring =\nfoo = $(nullstring) # end of line; there is a space here\n\nall:\nifeq ($(strip $(foo)),)\n\techo \"foo is empty after being stripped\"\nendif\nifeq ($(nullstring),)\n\techo \"nullstring doesn't even have spaces\"\nendif\n```\n\n## Check if a variable is defined\n\nifdef does not expand variable references; it just sees if something is defined at all\n\n```\nbar =\nfoo = $(bar)\n\nall:\nifdef foo\n\techo \"foo is defined\"\nendif\nifndef bar\n\techo \"but bar is not\"\nendif\n```\n\n## $(MAKEFLAGS)\n\nThis example shows you how to test make flags with `findstring` and `MAKEFLAGS`. Run this example with `make -i` to see it print out the echo statement.\n\n```\nall:\n# Search for the \"-i\" flag. MAKEFLAGS is just a list of single characters, one per flag. So look for \"i\" in this case.\nifneq (,$(findstring i, $(MAKEFLAGS)))\n\techo \"i was passed to MAKEFLAGS\"\nendif\n```\n\n# Functions\n\n## First Functions\n\n_Functions_ are mainly just for text processing. Call functions with `$(fn, arguments)` or `${fn, arguments}`. Make has a decent amount of [builtin functions](https://www.gnu.org/software/make/manual/html_node/Functions.html).\n\n```\nbar := ${subst not,\"totally\", \"I am not superman\"}\nall: \n\t@echo $(bar)\n```\n\nIf you want to replace spaces or commas, use variables\n\n```\ncomma := ,\nempty:=\nspace := $(empty) $(empty)\nfoo := a b c\nbar := $(subst $(space),$(comma),$(foo))\n\nall: \n\t@echo $(bar)\n```\n\nDo NOT include spaces in the arguments after the first. That will be seen as part of the string.\n\n```\ncomma := ,\nempty:=\nspace := $(empty) $(empty)\nfoo := a b c\nbar := $(subst $(space), $(comma) , $(foo)) # Watch out!\n\nall: \n\t# Output is \", a , b , c\". Notice the spaces introduced\n\t@echo $(bar)\n```\n\n## String Substitution\n\n`$(patsubst pattern,replacement,text)` does the following:\n\n\"Finds whitespace-separated words in text that match pattern and replaces them with replacement. Here pattern may contain a % which acts as a wildcard, matching any number of any characters within a word. If replacement also contains a %, the % is replaced by the text that matched the % in pattern. Only the first % in the pattern and replacement is treated this way; any subsequent % is unchanged.\" ([GNU docs](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#Text-Functions))\n\nThe substitution reference `$(text:pattern=replacement)` is a shorthand for this.\n\nThere's another shorthand that replaces only suffixes: `$(text:suffix=replacement)`. No `%` wildcard is used here.\n\nNote: don't add extra spaces for this shorthand. It will be seen as a search or replacement term.\n\n```\nfoo := a.o b.o l.a c.o\none := $(patsubst %.o,%.c,$(foo))\n# This is a shorthand for the above\ntwo := $(foo:%.o=%.c)\n# This is the suffix-only shorthand, and is also equivalent to the above.\nthree := $(foo:.o=.c)\n\nall:\n\techo $(one)\n\techo $(two)\n\techo $(three)\n```\n\n## The foreach function\n\nThe foreach function looks like this: `$(foreach var,list,text)`. It converts one list of words (separated by spaces) to another. `var` is set to each word in list, and `text` is expanded for each word.  \nThis appends an exclamation after each word:\n\n```\nfoo := who are you\n# For each \"word\" in foo, output that same word with an exclamation after\nbar := $(foreach wrd,$(foo),$(wrd)!)\n\nall:\n\t# Output is \"who! are! you!\"\n\t@echo $(bar)\n```\n\n## The if function\n\n`if` checks if the first argument is nonempty. If so, runs the second argument, otherwise runs the third.\n\n```\nfoo := $(if this-is-not-empty,then!,else!)\nempty :=\nbar := $(if $(empty),then!,else!)\n\nall:\n\t@echo $(foo)\n\t@echo $(bar)\n```\n\n## The call function\n\nMake supports creating basic functions. You \"define\" the function just by creating a variable, but use the parameters `$(0)`, `$(1)`, etc. You then call the function with the special [`call`](https://www.gnu.org/software/make/manual/html_node/Call-Function.html#Call-Function) builtin function. The syntax is `$(call variable,param,param)`. `$(0)` is the variable, while `$(1)`, `$(2)`, etc. are the params.\n\n```\nsweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3)\n\nall:\n\t# Outputs \"Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:\"\n\t@echo $(call sweet_new_fn, go, tigers)\n```\n\n## The shell function\n\nshell - This calls the shell, but it replaces newlines with spaces!\n\n```\nall: \n\t@echo $(shell ls -la) # Very ugly because the newlines are gone!\n```\n\n## The filter function\n\nThe `filter` function is used to select certain elements from a list that match a specific pattern. For example, this will select all elements in `obj_files` that end with `.o`.\n\n```\nobj_files = foo.result bar.o lose.o\nfiltered_files = $(filter %.o,$(obj_files))\n\nall:\n\t@echo $(filtered_files)\n```\n\nFilter can also be used in more complex ways:\n\n1. **Filtering multiple patterns**: You can filter multiple patterns at once. For example, `$(filter %.c %.h, $(files))` will select all `.c` and `.h` files from the files list.\n    \n2. **Negation**: If you want to select all elements that do not match a pattern, you can use `filter-out`. For example, `$(filter-out %.h, $(files))` will select all files that are not `.h` files.\n    \n3. **Nested filter**: You can nest filter functions to apply multiple filters. For example, `$(filter %.o, $(filter-out test%, $(objects)))` will select all object files that end with `.o` but don't start with `test`.\n    \n\n# Other Features\n\n## Include Makefiles\n\nThe include directive tells make to read one or more other makefiles. It's a line in the makefile that looks like this:\n\n```\ninclude filenames...\n```\n\nThis is particularly useful when you use compiler flags like `-M` that create Makefiles based on the source. For example, if some c files includes a header, that header will be added to a Makefile that's written by gcc. I talk about this more in the [Makefile Cookbook](https://makefiletutorial.com/#makefile-cookbook)\n\n## The vpath Directive\n\nUse vpath to specify where some set of prerequisites exist. The format is `vpath <pattern> <directories, space/colon separated>` `<pattern>` can have a `%`, which matches any zero or more characters. You can also do this globallyish with the variable VPATH\n\n```\nvpath %.h ../headers ../other-directory\n\n# Note: vpath allows blah.h to be found even though blah.h is never in the current directory\nsome_binary: ../headers blah.h\n\ttouch some_binary\n\n../headers:\n\tmkdir ../headers\n\n# We call the target blah.h instead of ../headers/blah.h, because that's the prereq that some_binary is looking for\n# Typically, blah.h would already exist and you wouldn't need this.\nblah.h:\n\ttouch ../headers/blah.h\n\nclean:\n\trm -rf ../headers\n\trm -f some_binary\n```\n\n## Multiline\n\nThe backslash (\"\\\") character gives us the ability to use multiple lines when the commands are too long\n\n```\nsome_file: \n\techo This line is too long, so \\\n\t\tit is broken up into multiple lines\n```\n\n## .phony\n\nAdding `.PHONY` to a target will prevent Make from confusing the phony target with a file name. In this example, if the file `clean` is created, make clean will still be run. Technically, I should have used it in every example with `all` or `clean`, but I wanted to keep the examples clean. Additionally, \"phony\" targets typically have names that are rarely file names, and in practice many people skip this.\n\n```\nsome_file:\n\ttouch some_file\n\ttouch clean\n\n.PHONY: clean\nclean:\n\trm -f some_file\n\trm -f clean\n```\n\n## .delete_on_error\n\nThe make tool will stop running a rule (and will propogate back to prerequisites) if a command returns a nonzero exit status.  \n`DELETE_ON_ERROR` will delete the target of a rule if the rule fails in this manner. This will happen for all targets, not just the one it is before like PHONY. It's a good idea to always use this, even though make does not for historical reasons.\n\n```\n.DELETE_ON_ERROR:\nall: one two\n\none:\n\ttouch one\n\tfalse\n\ntwo:\n\ttouch two\n\tfalse\n```\n\n# Makefile Cookbook\n\nLet's go through a really juicy Make example that works well for medium sized projects.\n\nThe neat thing about this makefile is it automatically determines dependencies for you. All you have to do is put your C/C++ files in the `src/` folder.\n\n```C\n# Thanks to Job Vranish (https://spin.atomicobject.com/2016/08/26/makefile-c-projects/)\nTARGET_EXEC := final_program\n\nBUILD_DIR := ./build\nSRC_DIRS := ./src\n\n# Find all the C and C++ files we want to compile\n# Note the single quotes around the * expressions. The shell will incorrectly expand these otherwise, but we want to send the * directly to the find command.\nSRCS := $(shell find $(SRC_DIRS) -name '*.cpp' -or -name '*.c' -or -name '*.s')\n\n# Prepends BUILD_DIR and appends .o to every src file\n# As an example, ./your_dir/hello.cpp turns into ./build/./your_dir/hello.cpp.o\nOBJS := $(SRCS:%=$(BUILD_DIR)/%.o)\n\n# String substitution (suffix version without %).\n# As an example, ./build/hello.cpp.o turns into ./build/hello.cpp.d\nDEPS := $(OBJS:.o=.d)\n\n# Every folder in ./src will need to be passed to GCC so that it can find header files\nINC_DIRS := $(shell find $(SRC_DIRS) -type d)\n# Add a prefix to INC_DIRS. So moduleA would become -ImoduleA. GCC understands this -I flag\nINC_FLAGS := $(addprefix -I,$(INC_DIRS))\n\n# The -MMD and -MP flags together generate Makefiles for us!\n# These files will have .d instead of .o as the output.\nCPPFLAGS := $(INC_FLAGS) -MMD -MP\n\n# The final build step.\n$(BUILD_DIR)/$(TARGET_EXEC): $(OBJS)\n\t$(CXX) $(OBJS) -o $@ $(LDFLAGS)\n\n# Build step for C source\n$(BUILD_DIR)/%.c.o: %.c\n\tmkdir -p $(dir $@)\n\t$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@\n\n# Build step for C++ source\n$(BUILD_DIR)/%.cpp.o: %.cpp\n\tmkdir -p $(dir $@)\n\t$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $< -o $@\n\n\n.PHONY: clean\nclean:\n\trm -r $(BUILD_DIR)\n\n# Include the .d makefiles. The - at the front suppresses the errors of missing\n# Makefiles. Initially, all the .d files will be missing, and we don't want those\n# errors to show up.\n-include $(DEPS)\n```",
      "excerpt": "Why do Makefiles exist?\n\nMakefiles are used to help decide which parts of a large program need to be recompiled. In the vast majority of cases, C or C++ files are compiled. Other languages typically h...",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-07-23T10:38:06.000Z"
    },
    {
      "id": "991-clang-memory-management-in-c-md",
      "slug": "991-clang/memory-management-in-c",
      "filepath": "991-CLANG/Memory Management in C.md",
      "folder": "991-CLANG",
      "filename": "Memory Management in C.md",
      "frontmatter": {
        "title": "Example: Read in File",
        "date": "2025-07-23",
        "tags": [
          "C",
          "c",
          "fn6",
          "how",
          "multiple"
        ],
        "category": "991-CLANG"
      },
      "content": "## Example: Read in File\n\n```C\nFILE *fp = fopen(\"input.txt\", \"r\");\nchar line[1024];\nchar **lines = NULL;\nsize_t num_lines = 0;\nif (!fp) {\n\tabort();\n}  \n// 1. Read in the file.\nwhile (1) {    \n\tchar *l = fgets(line, sizeof(line), fp);\n\tif (!l) {\n\t    break; // End of file (hopefully).    \n\t}    \n\t// Make room in the list of lines.\n\tif (!num_lines) {\n\t\tlines = malloc(sizeof(char *));\n\t} else {\n\t    lines = realloc(lines, (num_lines + 1) * sizeof(char *));\n\t}    \n\tif (!lines) {\n\t    abort(); // We are out of memory so panic.\n\t}    \n\tchar *copy = strdup(l);\n\tif (!copy) {\n\t    abort(); // We are out of memory so panic.\n\t}    \n\tlines[num_lines] = copy;\n    num_lines++;\n}\n```\n\nwe have the next line of the file in `line`, but we overwrite that buffer every time we read a new line from the file, so we need to store it somewhere. We use the `lines` variable for this, which is defined as:\n\n```c\n  char **lines = NULL;  size_t num_lines = 0;\n```\n\nStoring a copy of `line` is a two-part process:\n\n1. Make a copy of the line itself.\n2. Store the pointer to that line in `lines`.\n\nHowever, in order to store that pointer, we first need to make room in `lines`, which means allocating some memory. There are actually two cases here:\n\n1. Lines is empty (nothing is stored), which happens at the start.\n2. Lines is non-empty but doesn't have enough room.\n\nWe distinguish these by looking at `num_lines` which starts at `0`. In the former case, we allocate enough memory for a single line, like so:\n\n```c\n      lines = malloc(sizeof(char *));\n```\n\n==The latter case is more complicated, however, because we already have something in `lines`, it's just that there's not (necessarily) enough room in memory to add another value. This means we (may) need to\n\n1. Allocate enough memory to hold the new number of values.\n2. Copy over the current contents of `lines` into the new memory region.\n3. De-allocate the original memory.\n\n### When you call `malloc(size)` the system guarantees that the returned pointer is _at least_ big enough to hold an object of size `size`assuming that the allocation succeedsbut it's allowed to be larger\n\nAs we are doing here, then it's not efficient to have to copy the contents of the object over and over again. Instead, you can allocate more space than the programmer asked for and then when they ask for more, just say \"ok\" without taking any other action. All of this is handled automatically by the `realloc()` function call.\n\n\nIf this function were to return without cleaning up, it would create what's called a \"memory leak\". Remember that the only variable in our program that knows about any of this memory is `lines`, which points to the list of pointers for the individual stored lines. `lines` is on the stack and will be lost when the function returns, so if the function returns without cleaning up, then there is no program variable pointing to any of this memory and it's just lost.[[6]](https://educatedguesswork.org/posts/memory-management-1/#fn6) The result of a memory leak is that the leaked memory isn't available for new allocations but also can't be used because there's nothing pointing to it. If the program runs long enough and has a big enough leak, you can eventually accumulate enough leaked memory to affect the program function or even cause it to run out of memory, so you want to clean up. This is one reason why it often works to restart a program that seems stalled.\n\n```c\n  // Clean up.  \n  fclose(fp);  \n  for (size_t i=0; i<num_lines; i++) {\n      free(lines[i]);  \n\t}  \n  free(lines);\n```\n\n## How `malloc()` works [#](https://educatedguesswork.org/posts/memory-management-1/#how-malloc\\(\\)-works)\n\nSo far we've just been treating `malloc()` as a kind of black box, and that's generally fine for most programming tasks, but it's helpful to have some sense of what's going on internally. The first thing to realize is that `malloc()` isn't magic. In fact, you can write your own memory allocator in C (Firefox, for instance, uses a custom allocator).\n\nAt a very high level, you should think of `malloc()` as having access to one or more large contiguous blocks of memory, which it then dispenses on demand. On a very simple computer, `malloc()` would just have access to the entire memory of the machine, but on a modern multiprocess operating system, it gets chunks of memory from the operating system. For our purposes, let's easiest to think of it as having a big contiguous chunk of memory to work with. As I said, we usually wouldn't start at memory location 0, so we'll just assume the block starts at 1000.\n\nThe figure below shows the situation after a single allocation of size 200, with the allocation being red and the unallocated space being blue. What's happened here is just that `malloc(200)` just picked the first available memory region, which is at the start of the block because no memory has been allocated.\n\n![[Pasted image 20250722230727.png]]\n\nThe allocation starts at address 1000 and goes to address 1199, so `malloc()` just returns the address `1000`, which points to the start of the allocated region.\n\nThe next figure shows the situation with two more allocations, one of size 400 and one of size 200. Again, this is what you'd expect: the allocator just picks the lowest available region. As noted above, a real allocator would probably leave some extra space to facilitate growing the allocation but we're trying to keep things simple for the purpose of examples. Designing fast memory allocators is a whole (complicated) topic all on its own.\n\n![[Pasted image 20250722230831.png]]\n\nAs the program runs longer and memory is allocated and freed you tend get lots of small holes that can't be filled with big allocations, and so you have to allocate higher and higher memory regions. This is called _fragmentation_. In the extreme, you can get to the point where you can't allocate new memory even though there's actually plenty of free space; it's just not in a convenient form. There are techniques for avoiding this kind of fragmentation as well as for allocating memory more efficiently, but they're too advanced to cover here.\n\nWhen you call `malloc()` the allocator finds a suitable region and allocates it. When you call `free()` it adds it to the list of holes (or adjusts the highest allocation value if it's the highest allocation).\n\nInterestingly, it's not always necessary to store a list of every chunk of allocation memory. You can do this, but that means you need some data structure that lets you look up the allocations from their addresses. A common thing people do instead is to store the per-allocation metadata as a header right before the allocated region. The header contains the size of the allocation and maybe some other stuff. For instance, the first allocation above might look like this:\n![[Pasted image 20250722230943.png]]\n\n## Multiple References and UAF [#](https://educatedguesswork.org/posts/memory-management-1/#multiple-references-and-uaf)\n\nLet's consider a slight modification of the function we've been looking at, in which along with printing out all the lines, we instead return the last line in sort order. With a lot of trimming, the function might look like this:\n\n![[Pasted image 20250722231049.png]]\n\nThis function gets called like this:\n\n```c\nchar *largest = find_largest(\"input.txt\");printf(\"%s\\n\", largest);\n```\n\nThe experienced C programmer will immediately note that this code has a serious bug, because we are trying to use the memory pointed to `largest` after we have `free()`d it. When the calling function tries to use `largest`, there are **no guarantees at all** about what will happen. This is called a _use after free (UAF)_ bug. \nFor example, the allocator might have reallocated the memory in response to some other call to `malloc()`, in which case it is now full of some other data. Of course, it's also quite likely that the region is still unused and has the same contents as before; it's just that the allocator added it to the list of holes. In this case, the program may work fine under test but then fail unpredictably later when some change to your code causes allocations to happen differently and suddenly `largest` points to some memory reason being used for something else.\n\nThe reason this is all possible is that in C pointers are just values that hold the memory address; effectively they're just numbers and they behave like numbers. So if you assign a pointer value to another variable, now you have two variables that point to the same thing (i.e., they have the same value). When we call free on the first copy of the variable, that doesn't have any effect at all on the other copy (or on the first one, for that matter). It just changes the state of the memory region addressed by the variable. Once you've called `free(x)` you're still left with whatever is in `x`, and nothing in C stops you from using it; it's just illegal to do so, and it's your job not to, or else.\n\n\n## Memory Leaks\n\nA **memory leak** happens when dynamic memory is allocated but never freed.\n\nIf a memory leak happens in a loop or in a function that is called frequently it could take up too much memory and cause the computer to slow down.\n\nThere is a risk of a memory leak if a pointer to dynamic memory is lost before the memory can be freed. This can happen accidentally, so it is important to be careful and keep track of pointers to dynamic memory.\n\n### Example 1\n\nThe pointer is overwritten:\n```C\nint x = 5;  \nint *ptr;  \nptr = calloc(2, sizeof(*ptr));  \nptr = &x;\n```\nIn this example, after the pointer is changed to point at `x`, the memory allocated by `calloc()` can no longer be accessed.\n\n### Example 2\n\nThe pointer exists only inside a function:\n```C\nvoid myFunction() {  \n int *ptr;  \n ptr = malloc(sizeof(*ptr));  \n}  \n  \nint main() {  \n myFunction();  \n printf(\"The function has ended\");  \n return 0;  \n}\n```\n\nIn this example, the memory that was allocated inside of the function remains allocated after the function ends but it cannot be accessed anymore. One way to prevent this problem is to free the memory before the function ends.\n\n### Example 3\n\nThe pointer gets lost when reallocation fails:\n```C\nint* ptr;  \nptr = malloc(sizeof(*ptr));  \nptr = realloc(ptr, 2*sizeof(*ptr));\n```\n\nIf `realloc()` is unable to reallocate memory it will return a pointer to `NULL` and the original memory will remain reserved.\n\nIn this example, if `realloc()` fails then the `NULL` pointer is assigned to the `ptr` variable, overwriting the original memory address so that it cannot be accessed anymore.\n",
      "excerpt": "Example: Read in File\n\n\n\nwe have the next line of the file in , but we overwrite that buffer every time we read a new line from the file, so we need to store it somewhere. We use the  variable for thi...",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-07-23T09:44:55.000Z"
    },
    {
      "id": "991-clang-pointers-in-c-md",
      "slug": "991-clang/pointers-in-c",
      "filepath": "991-CLANG/Pointers in C.md",
      "folder": "991-CLANG",
      "filename": "Pointers in C.md",
      "frontmatter": {
        "title": "Pointers in C",
        "date": "2025-07-23",
        "tags": [
          "C"
        ],
        "category": "991-CLANG"
      },
      "content": "- Declaration and Derefrence have the same syntax but different meanings.\n- **void** type cast -> Generic pointer(Means the type is not known yet)\n```C\nvoid print(void *data, char datatype){\n\tif datatype == '--':\n\t\t(int*) data //Type casting it to any datatype you want\n}\n```\n\n- In C array always decays into a pointer it means decau is the process in which an array gets coverted to a pointer.\n\n-  `arr[5]==5[arr]` ??\n*arr[n] means (arr+n) therefore 5[arr] eq *(5+arr)*\n\n",
      "excerpt": "- Declaration and Derefrence have the same syntax but different meanings.\n- void type cast -> Generic pointer(Means the type is not known yet)\n\n\n- In C array always decays into a pointer it means deca...",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-07-23T10:09:59.000Z"
    },
    {
      "id": "991-clang-proxy-server-in-c-md",
      "slug": "991-clang/proxy-server-in-c",
      "filepath": "991-CLANG/Proxy Server in C.md",
      "folder": "991-CLANG",
      "filename": "Proxy Server in C.md",
      "frontmatter": {
        "title": "Socket Programming in C:",
        "date": "2025-07-23",
        "tags": [
          "c"
        ],
        "category": "991-CLANG"
      },
      "content": "This code sets up a **multithreaded proxy server** that handles HTTP GET requests and includes a **caching mechanism** to improve performance. It's designed to accept multiple client connections concurrently using threads.\n\n\n# Socket Programming in C:\n\n\n- ### Client Socket Process:\n\t- Set up a Socket (Prepare to communicate)\n        - Create a socket\n\t    - Determine server IP address and port number\n\t    - Initiate the connection to the server\n\t- Send and receive packets (Exchange data with the server)\n\t    -  Write data (i.e., request) to the socket\n\t    -  Read data (i.e., response) from the socket\n\t    -  Do stuff with the data (e.g., display a Web page)\n\t -  Close the socket.\n\n- ### Server Socket Process:\n\t-  Set up a Socket (Prepare to communicate)\n\t\t-  Create a socket s_listen (i.e., the listening socket)\n\t\t-  Associate servers IP address and port no. with the socket\n\t-  Wait to hear from a client\n\t    - Indicate how many connections can be pending on the socket\n\t    - Accept an incoming connection from a client, create a new socket s_new for the client.\n\t-  Send and receive packets (Exchange data with the client over the new socket s_new)\n\t    - Read data (i.e., client request) from the socket\n\t    - Handle the request\n\t    - Write data (i.e., server response) to the socket\n\t    - Close the socket s_new\n\t- Repeat 2.2-3.4 with the next connection request\n\n## I. Main Server Program - `proxy.c`\n\nLet's start by walking through the `main` function and then follow the execution flow to understand the other functions involved.\n\n### `main(int argc, char * argv[])`\n\n```c\nint main(int argc, char * argv[]) {\n\n\tint client_socketId, client_len; // client_socketId == to store the client socket id\n\tstruct sockaddr_in server_addr, client_addr; // Address of client and server to be assigned\n\n    sem_init(&seamaphore,0,MAX_CLIENTS); // Initializing seamaphore and lock\n    pthread_mutex_init(&lock,NULL); // Initializing lock for cache\n    \n\n\tif(argc == 2)        //checking whether two arguments are received or not\n\t{\n\t\tport_number = atoi(argv[1]);\n\t}\n\telse\n\t{\n\t\tprintf(\"Too few arguments\\n\");\n\t\texit(1);\n\t}\n\n\tprintf(\"Setting Proxy Server Port : %d\\n\",port_number);\n\n    //creating the proxy socket\n\tproxy_socketId = socket(AF_INET, SOCK_STREAM, 0);\n\n\tif( proxy_socketId < 0)\n\t{\n\t\tperror(\"Failed to create socket.\\n\");\n\t\texit(1);\n\t}\n\n\tint reuse =1;\n\tif (setsockopt(proxy_socketId, SOL_SOCKET, SO_REUSEADDR, (const char*)&reuse, sizeof(reuse)) < 0) \n        perror(\"setsockopt(SO_REUSEADDR) failed\\n\");\n\n\tbzero((char*)&server_addr, sizeof(server_addr));  \n\tserver_addr.sin_family = AF_INET;\n\tserver_addr.sin_port = htons(port_number); // Assigning port to the Proxy\n\tserver_addr.sin_addr.s_addr = INADDR_ANY; // Any available adress assigned\n\n    // Binding the socket\n\tif( bind(proxy_socketId, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0 )\n\t{\n\t\tperror(\"Port is not free\\n\");\n\t\texit(1);\n\t}\n\tprintf(\"Binding on port: %d\\n\",port_number);\n\n    // Proxy socket listening to the requests\n\tint listen_status = listen(proxy_socketId, MAX_CLIENTS);\n\n\tif(listen_status < 0 )\n\t{\n\t\tperror(\"Error while Listening !\\n\");\n\t\texit(1);\n\t}\n\n\tint i = 0; // Iterator for thread_id (tid) and Accepted Client_Socket for each thread\n\tint Connected_socketId[MAX_CLIENTS];   // This array stores socket descriptors of connected clients\n\n    // Infinite Loop for accepting connections\n\twhile(1)\n\t{\n\t\t\n\t\tbzero((char*)&client_addr, sizeof(client_addr));\t\t\t// Clears struct client_addr\n\t\tclient_len = sizeof(client_addr); \n\n        // Accepting the connections\n\t\tclient_socketId = accept(proxy_socketId, (struct sockaddr*)&client_addr,(socklen_t*)&client_len);\t// Accepts connection\n\t\tif(client_socketId < 0)\n\t\t{\n\t\t\tfprintf(stderr, \"Error in Accepting connection !\\n\");\n\t\t\texit(1);\n\t\t}\n\t\telse{\n\t\t\tConnected_socketId[i] = client_socketId; // Storing accepted client into array\n\t\t}\n\n\t\t// Getting IP address and port number of client\n\t\tstruct sockaddr_in* client_pt = (struct sockaddr_in*)&client_addr;\n\t\tstruct in_addr ip_addr = client_pt->sin_addr;\n\t\tchar str[INET_ADDRSTRLEN];\t\t\t\t\t\t\t\t\t\t// INET_ADDRSTRLEN: Default ip address size\n\t\tinet_ntop( AF_INET, &ip_addr, str, INET_ADDRSTRLEN );\n\t\tprintf(\"Client is connected with port number: %d and ip address: %s \\n\",ntohs(client_addr.sin_port), str);\n\t\t//printf(\"Socket values of index %d in main function is %d\\n\",i, client_socketId);\n\t\tpthread_create(&tid[i],NULL,thread_fn, (void*)&Connected_socketId[i]); // Creating a thread for each client accepted\n\t\ti++; \n\t}\n\tclose(proxy_socketId);\t\t\t\t\t\t\t\t\t// Close socket\n \treturn 0;\n}\n```\n\n  * **Purpose**: This is the entry point of the proxy server application. It initializes the server, sets up the listening socket, and then enters an infinite loop to accept incoming client connections, creating a new thread for each.\n  * **Parameters**:\n      * `int argc`: The number of command-line arguments provided when the program is run.\n      * `char * argv[]`: An array of **pointers** to strings, where each string is a command-line argument. `argv[0]` is typically the program's name, `argv[1]` the first argument, and so on.\n  * **Pointers and Variables**:\n      * `int client_socketId`: This integer variable will store the **socket descriptor** for each new client connection accepted by the proxy. A socket descriptor is a small integer that uniquely identifies a socket in the operating system.\n      * `int client_len`: An integer to store the size of the client's address structure.\n      * `struct sockaddr_in server_addr`, `struct sockaddr_in client_addr`: These are structures that hold internet socket addresses.\n          * `server_addr`: Will store the proxy server's own IP address and port.\n          * `client_addr`: Will store the connecting client's IP address and port.\n          * **Pointers**: ==When using these structures with socket functions, you often need to cast their **addresses** to `(struct sockaddr*)`. For example, `(struct sockaddr*)&server_addr` means \"take the address of `server_addr` and treat it as a pointer to a generic `sockaddr` structure.\"\n      * `sem_init(&seamaphore, 0, MAX_CLIENTS)`: Initializes a **semaphore**.\n          * `&seamaphore`: The **address** of the `sem_t` variable to initialize.\n          * `0`: Indicates that this semaphore is shared between threads of the same process.\n          * `MAX_CLIENTS`: The initial value (or maximum value) of the semaphore. This means up to `MAX_CLIENTS` threads can proceed without blocking on this semaphore. It limits concurrent client handling.\n      * `pthread_mutex_init(&lock, NULL)`: Initializes a ==**mutex** (mutual exclusion lock).\n          * `&lock`: *The* **address** of the `pthread_mutex_t` variable to initialize.\n          * `NULL`: Uses default mutex attributes. This mutex will be used to protect the shared **cache** from simultaneous access by multiple threads, preventing data corruption.\n      * `port_number = atoi(argv[1])`: If a command-line argument is provided (`argc == 2`), it converts the first argument string (pointed to by `argv[1]`) to an integer and assigns it to `port_number`.\n      * `proxy_socketId = socket(AF_INET, SOCK_STREAM, 0)`: Creates the main **listening socket** for the proxy server.\n          * `AF_INET`: Specifies the address family as IPv4.\n          * `SOCK_STREAM`: Specifies a stream socket, which provides reliable, ordered, and error-checked data delivery (TCP).\n          * `0`: Specifies the default protocol for the given family and type.\n          * The return value is a **socket descriptor** (an `int`). If it's less than `0`, an error occurred.\n      * `setsockopt(proxy_socketId, SOL_SOCKET, SO_REUSEADDR, (const char*)&reuse, sizeof(reuse))`: This sets a socket option.\n          * `proxy_socketId`: The socket to apply the option to.\n          * `SOL_SOCKET`: Specifies the option applies at the socket level.\n          * `SO_REUSEADDR`: Allows the port to be reused immediately after the server closes, even if previous connections are in `TIME_WAIT` state. This is crucial for rapid development and testing.\n          * `(const char*)&reuse`: A **pointer** to an integer (`reuse`) containing the option value (`1` for true).\n          * `sizeof(reuse)`: The size of the option value.\n      * `bzero((char*)&server_addr, sizeof(server_addr))`: Fills the `server_addr` structure with zeros. `(char*)&server_addr` casts the **address** of `server_addr` to a `char*` so `bzero` can operate on its raw bytes.\n      * `server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port_number); server_addr.sin_addr.s_addr = INADDR_ANY;`: Configures the `server_addr` structure:\n          * `sin_family`: Address family (IPv4).\n          * `sin_port`: The port number, converted to network byte order using `htons()`.\n          * `sin_addr.s_addr`: The IP address. `INADDR_ANY` means the server will listen on all available network interfaces.\n      * `bind(proxy_socketId, (struct sockaddr*)&server_addr, sizeof(server_addr))`: Associates the `proxy_socketId` with the `server_addr` (IP address and port). `(struct sockaddr*)&server_addr` is a **pointer** cast.\n      * `listen(proxy_socketId, MAX_CLIENTS)`: Puts the `proxy_socketId` into a listening state, ready to accept incoming connections. `MAX_CLIENTS` specifies the maximum length of the queue of pending connections.\n      * `int Connected_socketId[MAX_CLIENTS]`: An array to store the socket descriptors of currently connected clients. Each element is an `int`.\n      * `while(1)`: An infinite loop, making the server continuously run and accept new connections.\n      * `client_socketId = accept(proxy_socketId, (struct sockaddr*)&client_addr, (socklen_t*)&client_len)`: This is where the server waits for a client to connect.\n          * `proxy_socketId`: The listening socket.\n          * `(struct sockaddr*)&client_addr`: A **pointer** to a `sockaddr_in` structure where the client's address information will be stored.\n          * `(socklen_t*)&client_len`: A **pointer** to an integer that, on input, specifies the size of `client_addr` and, on output, specifies the actual size of the stored client address.\n          * It returns a **new socket descriptor** (`client_socketId`) dedicated to communication with this specific client. If it's less than `0`, an error occurred.\n      * `struct sockaddr_in* client_pt = (struct sockaddr_in*)&client_addr;`: Creates a **pointer** `client_pt` that points to the `client_addr` structure. This makes it easier to access members like `sin_addr`.\n      * `struct in_addr ip_addr = client_pt->sin_addr;`: Accesses the `sin_addr` member (which is of type `struct in_addr`) from the `client_addr` structure using the `client_pt` **pointer**. The `->` operator is used to access members of a structure through a pointer.\n      * `inet_ntop(AF_INET, &ip_addr, str, INET_ADDRSTRLEN)`: Converts the numeric IP address (`ip_addr`, whose **address** is passed) into a human-readable string format, storing it in `str`.\n      * `pthread_create(&tid[i], NULL, thread_fn, (void*)&Connected_socketId[i])`: This is the core of the multithreading. It creates a new thread for each accepted client.\n          * `&tid[i]`: The **address** of the `pthread_t` variable that will store the ID of the new thread.\n          * `NULL`: Uses default thread attributes.\n          * `thread_fn`: The **function pointer** to the function that the new thread will execute. This is the client-handling logic.\n          * `(void*)&Connected_socketId[i]`: The **argument** passed to `thread_fn`. It's a **pointer** to the `client_socketId` (which is stored in `Connected_socketId[i]`), cast to `void*` because `pthread_create` expects a `void*` argument. Inside `thread_fn`, this `void*` will be cast back to an `int*` to get the client's socket descriptor.\n      * `i++`: Increments the thread counter to prepare for the next client.\n      * `close(proxy_socketId)`: Closes the main listening socket when the server is shut down (though in this infinite loop, it's unreachable unless the loop breaks).\n\n-----\n\n### `thread_fn(void* socketNew)`\n\n```c\nvoid* thread_fn(void* socketNew)\n{\n\tsem_wait(&seamaphore);\n\tint p;\n\tsem_getvalue(&seamaphore,&p);\n\tprintf(\"Semaphore value:%d\\n\",p);\n\tint socket = *(int *)socketNew; // Dereferencing the void pointer to get the actual socket ID\n\tint bytes_send_client;\n\tchar *buffer = (char*)calloc(MAX_BYTES, sizeof(char));\n\tbzero(buffer, MAX_BYTES);\n\t\n\tbytes_send_client = recv(socket, buffer, MAX_BYTES, 0);\n\n\tchar *temp_buffer_ptr = NULL; \n\tint len = 0;\n\n\t// This loop will execute as long as there is data to be received\n\t// from the client and the end of the HTTP header (\"\\r\\n\\r\\n\") has\n\t// not been found yet.\n\twhile(bytes_send_client > 0)\n\t{\n\t\tlen = strlen(buffer);\n        //loop until u find \"\\r\\n\\r\\n\" in the buffer\n\t\tif(strstr(buffer, \"\\r\\n\\r\\n\") == NULL)\n\t\t{\t\n\t\t\tbytes_send_client = recv(socket, buffer + len, MAX_BYTES - len, 0);\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tchar *tempReq = (char*)malloc(strlen(buffer)*sizeof(char)+1);\n    //tempReq, buffer both store the http request sent by client\n\tfor (int i = 0; i < strlen(buffer); i++)\n\t{\n\t\ttempReq[i] = buffer[i];\n\t}\n\t\n\t//checking for the request in cache \n\tstruct cache_element* temp = find(tempReq);\n\n\tif( temp != NULL){\n        //request found in cache, so sending the response to client from proxy's cache\n\t\tint size=temp->len/sizeof(char);\n\t\tint pos=0;\n\t\tchar response[MAX_BYTES];\n\t\twhile(posdata[pos];\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tsend(socket,response,MAX_BYTES,0);\n\t\t}\n\t\tprintf(\"Data retrived from the Cache\\n\\n\");\n\t\tprintf(\"%s\\n\\n\",response);\n\t\t// close(socketNew);\n\t\t// sem_post(&seamaphore);\n\t\t// return NULL;\n\t}\n\t\n\t\n\telse if(bytes_send_client > 0)\n\t{\n\t\tlen = strlen(buffer); \n\t\t//Parsing the request\n\t\tParsedRequest* request = ParsedRequest_create();\n\t\t\n        //ParsedRequest_parse returns 0 on success and -1 on failure.On success it stores parsed request in\n        // the request\n\t\tif (ParsedRequest_parse(request, buffer, len) < 0) \n\t\t{\n\t\t   \tprintf(\"Parsing failed\\n\");\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\tbzero(buffer, MAX_BYTES);\n\t\t\tif(!strcmp(request->method,\"GET\"))\t\t\t\t\t\t\t\n\t\t\t{\n                \n\t\t\t\tif( request->host && request->path && (checkHTTPversion(request->version) == 1) )\n\t\t\t\t{\n\t\t\t\t\tbytes_send_client = handle_request(socket, request, tempReq);\t\t// Handle GET request\n\t\t\t\t\tif(bytes_send_client == -1)\n\t\t\t\t\t{\t\n\t\t\t\t\t\tsendErrorMessage(socket, 500);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsendErrorMessage(socket, 500);\t\t\t// 500 Internal Error\n\n\t\t\t}\n            else\n            {\n                printf(\"This code doesn't support any method other than GET\\n\");\n            }\n    \n\t\t}\n        //freeing up the request pointer\n\t\tParsedRequest_destroy(request);\n\n\t}\n\n\telse if( bytes_send_client < 0)\n\t{\n\t\tperror(\"Error in receiving from client.\\n\");\n\t}\n\telse if(bytes_send_client == 0)\n\t{\n\t\tprintf(\"Client disconnected!\\n\");\n\t}\n\n\tshutdown(socket, SHUT_RDWR);\n\tclose(socket);\n\tfree(buffer);\n\tsem_post(&seamaphore);\t\n\t\n\tsem_getvalue(&seamaphore,&p);\n\tprintf(\"Semaphore post value:%d\\n\",p);\n\tfree(tempReq);\n\treturn NULL;\n}\n```\n\n  * **Purpose**: This function is the main logic executed by each new thread. It receives an HTTP request from a client, checks the cache for it, serves from cache if found, otherwise forwards the request to the origin server, receives the response, and then caches it before sending it back to the client.\n  * **Parameters**:\n      * `void* socketNew`: A **generic pointer** (`void*`) to the `client_socketId` for this specific client connection. It needs to be cast back to an `int*` to be used.\n  * **Pointers and Variables**:\n      * `sem_wait(&seamaphore)`: Decrements the **semaphore** count. If the count is zero (meaning `MAX_CLIENTS` threads are already active), the calling thread will block until another thread releases the semaphore. This ensures we don't exceed `MAX_CLIENTS` concurrent connections.\n      * `int socket = *(int *)socketNew;`: This is crucial for **pointer dereferencing**.\n          * `(int *)socketNew`: Casts the `void*` `socketNew` back to an `int*` (a pointer to an integer).\n          * `*(int *)socketNew`: **Dereferences** the `int*` to get the actual integer value that `socketNew` points to, which is the `client_socketId`. This `socket` variable is then used for all communication with this client within the thread.\n      * `char *buffer = (char*)calloc(MAX_BYTES, sizeof(char))`: Dynamically allocates memory for `MAX_BYTES` characters and initializes them all to zero. This `buffer` will be used to receive the HTTP request from the client.\n      * `bytes_send_client = recv(socket, buffer, MAX_BYTES, 0)`: Receives data from the client's `socket` into the `buffer`. `bytes_send_client` stores the number of bytes actually received.\n      * `strstr(buffer, \"\\r\\n\\r\\n\")`: This string function searches for the first occurrence of the HTTP header termination sequence (`\\r\\n\\r\\n`) within the `buffer`. It returns a **pointer** to the first character of the found substring, or `NULL` if not found.\n      * `char *tempReq = (char*)malloc(strlen(buffer)*sizeof(char)+1)`: Dynamically allocates memory for `tempReq`, which will store a copy of the raw HTTP request received from the client. This copy is used as the **key for the cache**.\n      * `struct cache_element* temp = find(tempReq)`: Calls the `find` function (explained later) to check if the `tempReq` (the URL) exists in the cache. `temp` will be a **pointer** to the `cache_element` if found, or `NULL`.\n      * **Cache Hit (`if(temp != NULL)`)**:\n          * If the request is found in the cache, the stored response (`temp->data`) is sent back to the client in chunks of `MAX_BYTES`.\n          * `temp->len`: The length of the cached data.\n          * `temp->data[pos]`: Accessing individual characters of the cached data using array-like syntax with the **pointer** `temp->data`.\n          * `send(socket, response, MAX_BYTES, 0)`: Sends the cached data to the client.\n      * **Cache Miss (`else if(bytes_send_client > 0)`)**:\n          * `ParsedRequest* request = ParsedRequest_create()`: Creates a new `ParsedRequest` object. This function returns a **pointer** to a dynamically allocated `ParsedRequest` structure.\n          * `ParsedRequest_parse(request, buffer, len)`: Parses the raw HTTP request (`buffer`) into the `request` structure. This function populates the fields (method, host, path, headers, etc.) within the `ParsedRequest` structure pointed to by `request`.\n          * `strcmp(request->method, \"GET\")`: Compares the HTTP method (pointed to by `request->method`) to \"GET\".\n          * `request->host`, `request->path`, `request->version`: These are **pointers** to strings within the `ParsedRequest` structure, holding the parsed components of the URL and HTTP version.\n          * `handle_request(socket, request, tempReq)`: If it's a valid GET request, calls `handle_request` to fetch the content from the remote server, send it to the client, and add it to the cache.\n          * `sendErrorMessage(socket, 500)`: Sends an appropriate HTTP error if something goes wrong.\n          * `ParsedRequest_destroy(request)`: Frees the memory allocated for the `ParsedRequest` structure and its internal components.\n      * `shutdown(socket, SHUT_RDWR)`: Disables further sends and receives on the client socket.\n      * `close(socket)`: Closes the client socket.\n      * `free(buffer); free(tempReq);`: Frees the dynamically allocated memory for `buffer` and `tempReq`.\n      * `sem_post(&seamaphore)`: Increments the **semaphore** count, signaling that this thread has finished handling a client and another waiting thread can now proceed.\n      * `sem_getvalue(&seamaphore, &p)`: Retrieves the current value of the semaphore and stores it in `p`. `&p` is the **address** of the integer where the value will be stored.\n      * `return NULL`: Threads typically return `NULL` from their `void*` function.\n\n-----\n\n### `sendErrorMessage(int socket, int status_code)`\n\n```c\nint sendErrorMessage(int socket, int status_code)\n{\n\tchar str[1024];\n\tchar currentTime[50];\n\ttime_t now = time(0);\n\n\tstruct tm data = *gmtime(&now);\n\tstrftime(currentTime,sizeof(currentTime),\"%a, %d %b %Y %H:%M:%S %Z\", &data);\n\n\tswitch(status_code)\n\t{\n\t\t// ... (cases for 400, 403, 404, 500, 501, 505) ...\n\t}\n\treturn 1;\n}\n```\n\n  * **Purpose**: This function constructs and sends an HTTP error response back to the client based on a given HTTP status code.\n  * **Parameters**:\n      * `int socket`: The **socket descriptor** of the client connection to which the error message should be sent.\n      * `int status_code`: The HTTP status code (e.g., 400 for Bad Request).\n  * **Pointers and Variables**:\n      * `char str[1024]`: A local character array (buffer) to build the HTTP error response string.\n      * `char currentTime[50]`: A local character array to store the formatted current timestamp.\n      * `time_t now = time(0)`: Gets the current time in seconds since the Epoch.\n      * `struct tm data = *gmtime(&now)`: Converts the `time_t` value (`now`) into a broken-down time structure (`struct tm`) in Coordinated Universal Time (UTC). `gmtime()` returns a **pointer** to a `struct tm`, and `*` **dereferences** it to get the structure itself.\n      * ` strftime(currentTime, sizeof(currentTime), ...)  `: Formats the `struct tm` data into a human-readable date and time string, storing it in `currentTime`.\n      * `snprintf(str, sizeof(str), ...)`: Formats the full HTTP error response string (including headers and a simple HTML body) into the `str` buffer. It uses `currentTime` (a string **pointer**) to embed the current date.\n      * `send(socket, str, strlen(str), 0)`: Sends the constructed HTTP error response string over the provided `socket`. `strlen(str)` provides the exact length of the string to send.\n\n-----\n\n### `checkHTTPversion(char* msg)`\n\n```c\nint checkHTTPversion(char* msg)\n{\n\t// This Function checks for the HTTP version\n\tif( (strncmp(msg, \"HTTP/1.1\", 8) == 0) || (strncmp(msg, \"HTTP/1.0\", 8) == 0) )\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n```\n\n  * **Purpose**: This simple function validates if the provided string represents a supported HTTP version (either \"HTTP/1.1\" or \"HTTP/1.0\").\n  * **Parameters**:\n      * `char* msg`: A **pointer** to the string containing the HTTP version extracted from the client's request.\n  * **Pointers and Variables**:\n      * `strncmp(msg, \"HTTP/1.1\", 8)`: Compares the first 8 characters of the string pointed to by `msg` with \"HTTP/1.1\". `strncmp` is used for safe comparison of fixed lengths, preventing buffer overflows if `msg` is not null-terminated or shorter than expected.\n      * `strncmp(msg, \"HTTP/1.0\", 8)`: Similar comparison for \"HTTP/1.0\".\n\n-----\n\n### `connectRemoteServer(char* host_addr, int port_num)`\n\n```c\nint connectRemoteServer(char* host_addr, int port_num)\n{\n\t// Creating Socket for remote server ---------------------------\n\tint remoteSocket = socket(AF_INET, SOCK_STREAM, 0);\n\n\tif( remoteSocket < 0)\n\t{\n\t\tprintf(\"Error in Creating Socket.\\n\");\n\t\treturn -1;\n\t}\n\t\n\t// Get host by the name or ip address provided\n\tstruct hostent *host = gethostbyname(host_addr);\t\n\tif(host == NULL)\n\t{\n\t\tfprintf(stderr, \"No such host exists.\\n\");\t\n\t\treturn -1;\n\t}\n\n\t// inserts ip address and port number of host in struct `server_addr`\n\tstruct sockaddr_in server_addr;\n\n\tbzero((char*)&server_addr, sizeof(server_addr));\n\tserver_addr.sin_family = AF_INET;\n\tserver_addr.sin_port = htons(port_num);\n\n\tbcopy((char *)host->h_addr,(char *)&server_addr.sin_addr.s_addr,host->h_length);\n\n\t// Connect to Remote server ----------------------------------------------------\n\tif( connect(remoteSocket, (struct sockaddr*)&server_addr, (socklen_t)sizeof(server_addr)) < 0 )\n\t{\n\t\tfprintf(stderr, \"Error in connecting !\\n\"); \n\t\treturn -1;\n\t}\n\t// free(host_addr); // This line is problematic if host_addr is not dynamically allocated for this specific function call.\n\treturn remoteSocket;\n}\n```\n\n  * **Purpose**: This function is responsible for creating a new socket and establishing a TCP connection to the actual web server (origin server) specified by the client's request.\n  * **Parameters**:\n      * `char* host_addr`: A **pointer** to a string containing the hostname (e.g., \"[www.google.com](https://www.google.com)\") or IP address of the remote server.\n      * `int port_num`: The port number of the remote server (e.g., 80 for HTTP).\n  * **Pointers and Variables**:\n      * `int remoteSocket`: This integer will hold the **socket descriptor** for the connection to the remote server.\n      * `struct hostent *host`: This is a **pointer** to a `struct hostent`. The `gethostbyname()` function takes a hostname (a `char*`) and returns a pointer to this structure, which contains information like the official name of the host, its aliases, and a list of IP addresses.\n      * `struct sockaddr_in server_addr`: This structure holds the remote server's IP address and port number in a format suitable for socket functions.\n      * `bzero((char*)&server_addr, sizeof(server_addr))`: Initializes the `server_addr` structure to all zeros. `(char*)&server_addr` casts the **address** of `server_addr` to a `char*` so `bzero` can operate on its raw bytes.\n      * `server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port_num);`: Sets the address family to IPv4 and converts the `port_num` to network byte order.\n      * `bcopy((char *)host->h_addr,(char *)&server_addr.sin_addr.s_addr,host->h_length)`: Copies the IP address from the `host` structure (obtained via `gethostbyname()`) into `server_addr.sin_addr.s_addr`.\n          * `(char *)host->h_addr`: This is a **pointer** to the first IP address in the list provided by `gethostbyname()`.\n          * `(char *)&server_addr.sin_addr.s_addr`: This is the **address** of the `s_addr` field within `server_addr.sin_addr`, where the IP address will be stored.\n          * `host->h_length`: The length of the address (e.g., 4 bytes for IPv4).\n      * `connect(remoteSocket, (struct sockaddr*)&server_addr, (socklen_t)sizeof(server_addr))`: Attempts to establish a connection using the `remoteSocket` to the `server_addr`. `(struct sockaddr*)&server_addr` is a **pointer** cast to the generic `sockaddr` type.\n\n-----\n\n### `handle_request(int clientSocket, ParsedRequest *request, char *tempReq)`\n\n```c\nint handle_request(int clientSocket, ParsedRequest *request, char *tempReq)\n{\n\tchar *buf = (char*)malloc(sizeof(char)*MAX_BYTES);\n\tstrcpy(buf, \"GET \");\n\tstrcat(buf, request->path);\n\tstrcat(buf, \" \");\n\tstrcat(buf, request->version);\n\tstrcat(buf, \"\\r\\n\");\n\n\tsize_t len = strlen(buf);\n\n\tif (ParsedHeader_set(request, \"Connection\", \"close\") < 0){\n\t\tprintf(\"set header key not work\\n\");\n\t}\n\n\tif(ParsedHeader_get(request, \"Host\") == NULL)\n\t{\n\t\tif(ParsedHeader_set(request, \"Host\", request->host) < 0){\n\t\t\tprintf(\"Set \\\"Host\\\" header key not working\\n\");\n\t\t}\n\t}\n\n\tif (ParsedRequest_unparse_headers(request, buf + len, (size_t)MAX_BYTES - len) < 0) {\n\t\tprintf(\"unparse failed\\n\");\n\t\t//return -1;\t\t\t\t// If this happens Still try to send request without header\n\t}\n\n\tint server_port = 80;\t\t\t\t// Default Remote Server Port\n\tif(request->port != NULL)\n\t\tserver_port = atoi(request->port);\n\n\tint remoteSocketID = connectRemoteServer(request->host, server_port);\n\n\tif(remoteSocketID < 0)\n\t\treturn -1;\n\n\tint bytes_send = send(remoteSocketID, buf, strlen(buf), 0);\n\n\tbzero(buf, MAX_BYTES);\n\n\tbytes_send = recv(remoteSocketID, buf, MAX_BYTES-1, 0);\n\tchar *temp_buffer = (char*)malloc(sizeof(char)*MAX_BYTES); //temp buffer\n\tint temp_buffer_size = MAX_BYTES;\n\tint temp_buffer_index = 0;\n\n\twhile(bytes_send > 0)\n\t{\n\t\tbytes_send = send(clientSocket, buf, bytes_send, 0);\n\t\t\n\t\tfor(int i=0;i<bytes_send;i++){\n\t\t\tif(temp_buffer_index < temp_buffer_size){\n\t\t\t\ttemp_buffer[temp_buffer_index] = buf[i];\n\t\t\t\ttemp_buffer_index++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttemp_buffer_size += MAX_BYTES;\n\t\t\t\ttemp_buffer = (char*)realloc(temp_buffer, temp_buffer_size*sizeof(char)); // Reallocating Memory\n\t\t\t\ttemp_buffer[temp_buffer_index] = buf[i];\n\t\t\t\ttemp_buffer_index++;\n\t\t\t}\n\t\t}\n\t\tbzero(buf, MAX_BYTES);\n\t\tbytes_send = recv(remoteSocketID, buf, MAX_BYTES-1, 0);\n\t}\n\n\ttemp_buffer[temp_buffer_index] = '\\0';\n\tadd_cache_element(temp_buffer,temp_buffer_index,tempReq);\n\n\tfree(temp_buffer);\n\tfree(buf);\n\tclose(remoteSocketID);\n\treturn 1;\n}\n```\n\n  * **Purpose**: This function takes a parsed client request, modifies it for the origin server, sends it, receives the response, and then forwards the response to the client while also adding it to the cache.\n  * **Parameters**:\n      * `int clientSocket`: The **socket descriptor** for the client connection.\n      * `ParsedRequest *request`: A **pointer** to the `ParsedRequest` structure, which holds the parsed components of the client's HTTP request.\n      * `char *tempReq`: A **pointer** to the original, raw HTTP request string from the client. This will be used as the key for caching the response.\n  * **Pointers and Variables**:\n      * `char *buf = (char*)malloc(sizeof(char)*MAX_BYTES)`: Dynamically allocates a buffer to construct the request to the remote server and later to receive the response from it. `buf` is a **pointer** to this allocated memory.\n      * `strcpy(buf, \"GET \"); strcat(buf, request->path); ...`: This sequence constructs the HTTP request line (e.g., \"GET /some/path HTTP/1.1\") using strings pointed to by members of the `request` structure (`request->path`, `request->version`).\n      * `ParsedHeader_set(request, \"Connection\", \"close\")`: This function from `proxy_parse.h` sets or adds an HTTP header. It takes the `ParsedRequest` **pointer**, and **pointers** to the key (\"Connection\") and value (\"close\") strings. This is often done to ensure the connection with the origin server closes after the response, simplifying proxy logic.\n      * `ParsedHeader_get(request, \"Host\")`: This function from `proxy_parse.h` retrieves a header. It returns a **pointer** to a `ParsedHeader` structure if the \"Host\" header is found, otherwise `NULL`. This check ensures that the \"Host\" header is present, which is mandatory for HTTP/1.1 requests.\n      * `ParsedRequest_unparse_headers(request, buf + len, (size_t)MAX_BYTES - len)`: This function from `proxy_parse.h` takes the parsed headers from the `request` structure and converts them back into a raw string format, appending them to `buf` after the request line. `buf + len` is a **pointer arithmetic** expression; it moves the **pointer** `buf` forward by `len` bytes, indicating where the headers should start.\n      * `int remoteSocketID = connectRemoteServer(request->host, server_port)`: Calls the `connectRemoteServer` function to establish a connection to the origin web server. `request->host` is a **pointer** to the hostname string.\n      * `send(remoteSocketID, buf, strlen(buf), 0)`: Sends the complete HTTP request (request line + headers) to the `remoteSocketID`.\n      * `char *temp_buffer = (char*)malloc(sizeof(char)*MAX_BYTES)`: Dynamically allocates a temporary buffer to accumulate the full response received from the remote server.\n      * `temp_buffer = (char*)realloc(temp_buffer, temp_buffer_size*sizeof(char))`: If the incoming response is larger than the current `temp_buffer_size`, `realloc` is used to expand the allocated memory for `temp_buffer`. If `realloc` is successful, `temp_buffer` might point to a new memory location.\n      * `add_cache_element(temp_buffer, temp_buffer_index, tempReq)`: Calls the cache function to add the received response (`temp_buffer` and its length `temp_buffer_index`) with its corresponding request URL (`tempReq`) to the cache.\n      * `free(temp_buffer); free(buf);`: Frees the dynamically allocated memory pointed to by `temp_buffer` and `buf` to prevent memory leaks.\n      * `close(remoteSocketID)`: Closes the socket connection to the remote server.\n\n-----\n\n### Cache Management Functions\n\n#### `find(char* url)`\n\n```c\ncache_element* find(char* url){\n\n// Checks for url in the cache if found returns pointer to the respective cache element or else returns NULL\n    cache_element* site=NULL;\n\t//sem_wait(&cache_lock);\n    int temp_lock_val = pthread_mutex_lock(&lock);\n\tprintf(\"Remove Cache Lock Acquired %d\\n\",temp_lock_val); \n    if(head!=NULL){\n        site = head;\n        while (site!=NULL)\n        {\n            if(!strcmp(site->url,url)){\n\t\t\t\tprintf(\"LRU Time Track Before : %ld\", site->lru_time_track);\n                printf(\"\\nurl found\\n\");\n\t\t\t\t// Updating the time_track\n\t\t\t\tsite->lru_time_track = time(NULL);\n\t\t\t\tprintf(\"LRU Time Track After : %ld\", site->lru_time_track);\n\t\t\t\tbreak;\n            }\n            site=site->next;\n        }       \n    }\n\telse {\n    printf(\"\\nurl not found\\n\");\n\t}\n\t//sem_post(&cache_lock);\n    temp_lock_val = pthread_mutex_unlock(&lock);\n\tprintf(\"Remove Cache Lock Unlocked %d\\n\",temp_lock_val); \n    return site;\n}\n```\n\n  * **Purpose**: Searches for a `cache_element` in the cache (a linked list) using the provided `url` as the key. If found, it updates the `lru_time_track` for that element to reflect its recent use, and returns a pointer to it.\n  * **Parameters**:\n      * `char* url`: A **pointer** to the URL string to search for in the cache.\n  * **Pointers and Variables**:\n      * `cache_element* site=NULL`: A **pointer** of type `cache_element*` used to traverse the cache linked list. It's initialized to `NULL`.\n      * `pthread_mutex_lock(&lock)`: Acquires the **mutex lock**. This is critical because `head` and the cache linked list (`site->next`, `site->lru_time_track`) are shared resources accessed by multiple threads. The lock ensures that only one thread can access or modify the cache at a time, preventing race conditions and data corruption.\n      * `if(head!=NULL)`: Checks if the cache is empty. `head` is a **global pointer** to the first element of the cache linked list.\n      * `site = head`: Starts `site` at the beginning of the linked list.\n      * `while (site!=NULL)`: Loops through each element in the linked list.\n      * `if(!strcmp(site->url,url))`: Compares the `url` stored in the current `cache_element` (`site->url`, a **pointer** to a string) with the input `url` (**pointer** to a string). If they are identical (meaning the URL is found), `strcmp` returns `0`.\n      * `site->lru_time_track = time(NULL)`: If the element is found, its `lru_time_track` is updated to the current time using `time(NULL)`. This marks it as recently used, which is important for the LRU eviction policy. `site->lru_time_track` accesses the `lru_time_track` member of the `cache_element` pointed to by `site`.\n      * `site=site->next`: Moves the `site` **pointer** to the next `cache_element` in the linked list. `site->next` accesses the `next` member (a **pointer** to the next element) of the `cache_element` pointed to by `site`.\n      * `pthread_mutex_unlock(&lock)`: Releases the **mutex lock**, allowing other threads to access the cache.\n\n#### `remove_cache_element()`\n\n```c\nvoid remove_cache_element(){\n    // If cache is not empty searches for the node which has the least lru_time_track and deletes it\n    cache_element * p ;  \t// Cache_element Pointer (Prev. Pointer)\n\tcache_element * q ;\t\t// Cache_element Pointer (Next Pointer)\n\tcache_element * temp;\t// Cache element to remove\n    //sem_wait(&cache_lock);\n    int temp_lock_val = pthread_mutex_lock(&lock);\n\tprintf(\"Remove Cache Lock Acquired %d\\n\",temp_lock_val); \n\tif( head != NULL) { // Cache != empty\n\t\tfor (q = head, p = head, temp =head ; q -> next != NULL; \n\t\t\tq = q -> next) { // Iterate through entire cache and search for oldest time track\n\t\t\tif(( (q -> next) -> lru_time_track) < (temp -> lru_time_track)) {\n\t\t\t\ttemp = q -> next;\n\t\t\t\tp = q;\n\t\t\t}\n\t\t}\n\t\tif(temp == head) { \n\t\t\thead = head -> next; /*Handle the base case*/\n\t\t} else {\n\t\t\tp->next = temp->next;\t\n\t\t}\n\t\tcache_size = cache_size - (temp -> len) - sizeof(cache_element) - \n\t\tstrlen(temp -> url) - 1;     //updating the cache size\n\t\tfree(temp->data);     \t\t\n\t\tfree(temp->url); // Free the removed element \n\t\tfree(temp);\n\t} \n\t//sem_post(&cache_lock);\n    temp_lock_val = pthread_mutex_unlock(&lock);\n\tprintf(\"Remove Cache Lock Unlocked %d\\n\",temp_lock_val); \n}\n```\n\n  * **Purpose**: Implements the LRU (Least Recently Used) cache eviction policy. It finds the `cache_element` that was accessed the longest time ago and removes it from the cache to free up space.\n  * **Parameters**: None (operates on the global `head` and `cache_size`).\n  * **Pointers and Variables**:\n      * `pthread_mutex_lock(&lock)`: Acquires the mutex lock before modifying the cache.\n      * `cache_element * p`, `cache_element * q`, `cache_element * temp`: These are **pointers** used to traverse the linked list and keep track of elements.\n          * `p`: A \"previous\" pointer, always pointing to the element *before* `temp`.\n          * `q`: A \"current\" pointer, iterating through the list to find the element to remove.\n          * `temp`: A \"temporary\" pointer, always pointing to the element currently identified as the least recently used.\n      * `if(head != NULL)`: Checks if the cache is not empty.\n      * `for (q = head, p = head, temp =head ; q -> next != NULL; q = q -> next)`: This loop iterates through the linked list to find the element with the smallest `lru_time_track`.\n          * `q -> next`: Accesses the `next` pointer of the `cache_element` pointed to by `q`.\n          * `q -> next -> lru_time_track`: Accesses the `lru_time_track` of the element pointed to by `q->next`.\n          * `temp -> lru_time_track`: Accesses the `lru_time_track` of the element pointed to by `temp`.\n      * `if(temp == head)`: If the element to be removed (`temp`) is the `head` of the list, then `head` is simply updated to point to the next element.\n      * `else { p->next = temp->next; }`: If `temp` is not the head, `p->next` (the `next` pointer of the element *before* `temp`) is made to point to `temp->next` (the element *after* `temp`), effectively unlinking `temp` from the list.\n      * `cache_size = cache_size - ...`: Decrements the global `cache_size` by the size of the removed element (its `data` length, the size of the `cache_element` structure itself, and the length of its `url`).\n      * `free(temp->data); free(temp->url); free(temp);`: Frees the dynamically allocated memory for the actual data (`temp->data`), the URL string (`temp->url`), and the `cache_element` structure itself (`temp`). This is crucial for preventing memory leaks.\n      * `pthread_mutex_unlock(&lock)`: Releases the mutex lock.\n\n#### `add_cache_element(char* data,int size,char* url)`\n\n```c\nint add_cache_element(char* data,int size,char* url){\n    // Adds element to the cache\n\t// sem_wait(&cache_lock);\n    int temp_lock_val = pthread_mutex_lock(&lock);\n\tprintf(\"Add Cache Lock Acquired %d\\n\", temp_lock_val);\n    int element_size=size+1+strlen(url)+sizeof(cache_element); // Size of the new element which will be added to the cache\n    if(element_size>MAX_ELEMENT_SIZE){\n\t\t//sem_post(&cache_lock);\n        // If element size is greater than MAX_ELEMENT_SIZE we don't add the element to the cache\n        temp_lock_val = pthread_mutex_unlock(&lock);\n\t\tprintf(\"Add Cache Lock Unlocked %d\\n\", temp_lock_val);\n\t\t// free(data); // These free() calls are potentially problematic depending on how 'data' and 'url' were allocated prior to this function call.\n\t\t// printf(\"--\\n\");\n\t\t// free(url);\n        return 0;\n    }\n    else\n    {   while(cache_size+element_size>MAX_SIZE){\n            // We keep removing elements from cache until we get enough space to add the element\n            remove_cache_element();\n        }\n        cache_element* element = (cache_element*) malloc(sizeof(cache_element)); // Allocating memory for the new cache element\n        element->data= (char*)malloc(size+1); // Allocating memory for the response to be stored in the cache element\n\t\tstrcpy(element->data,data); \n        element -> url = (char*)malloc(1+( strlen( url )*sizeof(char)  )); // Allocating memory for the request to be stored in the cache element (as a key)\n\t\tstrcpy( element -> url, url );\n\t\telement->lru_time_track=time(NULL);    // Updating the time_track\n        element->next=head; \n        element->len=size;\n        head=element;\n        cache_size+=element_size;\n        temp_lock_val = pthread_mutex_unlock(&lock);\n\t\tprintf(\"Add Cache Lock Unlocked %d\\n\", temp_lock_val);\n\t\t//sem_post(&cache_lock);\n\t\t// free(data); // Again, these free() calls might be incorrect.\n\t\t// printf(\"--\\n\");\n\t\t// free(url);\n        return 1;\n    }\n    return 0;\n}\n```\n\n  * **Purpose**: Adds a new `cache_element` (HTTP response data and its corresponding URL) to the cache. It ensures that the cache doesn't exceed its `MAX_SIZE` by evicting older elements if necessary, and it also checks if the new element itself is too large to be cached.\n  * **Parameters**:\n      * `char* data`: A **pointer** to the HTTP response data (the content to be cached).\n      * `int size`: The length of the `data` in bytes.\n      * `char* url`: A **pointer** to the URL string (the key for the cache element).\n  * **Pointers and Variables**:\n      * `pthread_mutex_lock(&lock)`: Acquires the mutex lock before modifying the cache.\n      * `int element_size = size + 1 + strlen(url) + sizeof(cache_element)`: Calculates the total size that the new `cache_element` will occupy in memory, including the data, URL string, and the `cache_element` structure itself. `size + 1` accounts for the null terminator for `data`. `strlen(url) + 1` accounts for the null terminator for `url`.\n      * `if(element_size > MAX_ELEMENT_SIZE)`: Checks if the new element is individually too large to be cached. If so, it returns `0` (failure) without adding it.\n      * `while(cache_size + element_size > MAX_SIZE)`: This loop implements cache eviction. If adding the new element would make the cache exceed `MAX_SIZE`, it repeatedly calls `remove_cache_element()` until enough space is freed.\n      * `cache_element* element = (cache_element*) malloc(sizeof(cache_element))`: Dynamically allocates memory for the new `cache_element` structure itself. `element` is a **pointer** to this new structure.\n      * `element->data = (char*)malloc(size+1)`: Dynamically allocates memory for the actual response data (`data`) within the new `cache_element`. `element->data` is a **pointer** to this memory. `strcpy(element->data, data)` copies the content.\n      * `element->url = (char*)malloc(1 + (strlen(url) * sizeof(char)))`: Dynamically allocates memory for the URL string within the new `cache_element`. `element->url` is a **pointer** to this memory. `strcpy(element->url, url)` copies the URL.\n      * `element->lru_time_track = time(NULL)`: Sets the `lru_time_track` of the new element to the current time, marking it as recently added/used.\n      * `element->next = head`: This adds the new element to the *front* of the linked list (a common way to implement a simple LRU where the head is the most recently added). `element->next` points to what was previously the `head`.\n      * `head = element`: Updates the global `head` **pointer** to point to the newly added element, making it the new beginning of the list.\n      * `cache_size += element_size`: Updates the global `cache_size`.\n      * `pthread_mutex_unlock(&lock)`: Releases the mutex lock.\n\n-----\n\n## II. Proxy Parse Library - `proxy_parse.c`\n\nThis library provides functions to parse HTTP requests into a structured format and unparse them back into raw strings.\n\n### Structures\n\n```c\n// (Implicitly defined in proxy_parse.h, but important to understand)\nstruct ParsedHeader {\n    char *key;      // Pointer to the header key (e.g., \"Host\")\n    char *value;    // Pointer to the header value (e.g., \"www.example.com\")\n    size_t keylen;  // Length of the key string\n    size_t valuelen; // Length of the value string\n};\n\nstruct ParsedRequest {\n    char *buf;      // Pointer to the original raw request line (e.g., \"GET http://www.example.com/ HTTP/1.1\")\n    size_t buflen;  // Length of the raw request line\n    char *method;   // Pointer to the HTTP method (e.g., \"GET\")\n    char *protocol; // Pointer to the protocol (e.g., \"http\")\n    char *host;     // Pointer to the host (e.g., \"www.example.com\")\n    char *port;     // Pointer to the port (e.g., \"80\")\n    char *path;     // Pointer to the path (e.g., \"/index.html\")\n    char *version;  // Pointer to the HTTP version (e.g., \"HTTP/1.1\")\n    struct ParsedHeader *headers; // Pointer to an array of ParsedHeader structures\n    size_t headerslen;   // Allocated capacity for headers array\n    size_t headersused;  // Number of headers actually used\n};\n```\n\n  * **`ParsedHeader`**: Represents a single HTTP header, storing its key and value as dynamically allocated strings.\n      * `char *key`, `char *value`: **Pointers** to dynamically allocated character arrays that store the header's key and value strings.\n  * **`ParsedRequest`**: Represents the entire parsed HTTP request. It holds pointers to various components of the request line and an array of `ParsedHeader` structures for the request headers.\n      * `char *buf`: A **pointer** to a dynamically allocated string holding the *request line* from the original HTTP request (e.g., \"GET [http://www.example.com/](http://www.example.com/) HTTP/1.1\").\n      * `char *method`, `char *protocol`, `char *host`, `char *port`, `char *path`, `char *version`: These are all **pointers** to character arrays (strings). During parsing, these pointers will be made to point to specific parts within the `buf` (or newly allocated memory for `path`), essentially \"slicing\" the request line into its components.\n      * `struct ParsedHeader *headers`: A **pointer** to an array of `ParsedHeader` structures. This array is dynamically resized as needed.\n\n-----\n\n### `debug(const char * format, ...)`\n\n```c\nvoid debug(const char * format, ...) {\n  va_list args;\n  if (DEBUG) {\n   va_start(args, format);\n   vfprintf(stderr, format, args);\n   va_end(args);\n  }\n}\n```\n\n  * **Purpose**: A debugging utility function that prints formatted output to `stderr` if the `DEBUG` macro is defined (usually `DEBUG` is set to `1`).\n  * **Parameters**:\n      * `const char * format`: A **pointer** to a format string, similar to `printf`.\n      * `...`: Ellipsis, indicating a variable number of arguments (like `printf`).\n  * **Pointers and Variables**:\n      * `va_list args`: A special type from `<stdarg.h>` used to handle variable argument lists.\n      * `va_start(args, format)`: Initializes `args` to point to the first optional argument.\n      * `vfprintf(stderr, format, args)`: Prints the formatted output to `stderr` using the variable argument list.\n      * `va_end(args)`: Cleans up the `va_list`.\n\n-----\n\n### `ParsedHeader_set(struct ParsedRequest *pr, const char * key, const char * value)`\n\n```c\nint ParsedHeader_set(struct ParsedRequest *pr,\n      const char * key, const char * value)\n{\n  struct ParsedHeader *ph;\n  ParsedHeader_remove (pr, key); // Remove existing header with same key\n\n  if (pr->headerslen <= pr->headersused+1) {\n   pr->headerslen = pr->headerslen * 2;\n   pr->headers =\n     (struct ParsedHeader *)realloc(pr->headers,\n    pr->headerslen * sizeof(struct ParsedHeader));\n   if (!pr->headers)\n     return -1;\n  }\n\n  ph = pr->headers + pr->headersused;\n  pr->headersused += 1;\n  \n  ph->key = (char *)malloc(strlen(key)+1);\n  memcpy(ph->key, key, strlen(key));\n  ph->key[strlen(key)] = '\\0';\n\n  ph->value = (char *)malloc(strlen(value)+1);\n  memcpy(ph->value, value, strlen(value));\n  ph->value[strlen(value)] = '\\0';\n\n  ph->keylen = strlen(key)+1;\n  ph->valuelen = strlen(value)+1;\n  return 0;\n}\n```\n\n  * **Purpose**: Adds or updates an HTTP header (key-value pair) within a `ParsedRequest` structure. If a header with the same key already exists, it's removed first.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure where the header will be set.\n      * `const char * key`: A **pointer** to the string representing the header key (e.g., \"Host\").\n      * `const char * value`: A **pointer** to the string representing the header value (e.g., \"[www.example.com](https://www.example.com)\").\n  * **Pointers and Variables**:\n      * `struct ParsedHeader *ph`: A **pointer** used to refer to the new `ParsedHeader` element being added to the array.\n      * `ParsedHeader_remove(pr, key)`: Calls another function (explained below) to remove any existing header with the same `key`.\n      * `if (pr->headerslen <= pr->headersused+1)`: Checks if the allocated array for headers (`pr->headers`) needs to be resized.\n          * `pr->headerslen`: The currently allocated capacity of the `headers` array.\n          * `pr->headersused`: The number of header slots currently occupied.\n      * `pr->headers = (struct ParsedHeader *)realloc(pr->headers, pr->headerslen * sizeof(struct ParsedHeader))`: If resizing is needed, `realloc` attempts to resize the `headers` array (pointed to by `pr->headers`). If successful, `pr->headers` might point to a new memory location.\n      * `ph = pr->headers + pr->headersused`: Uses **pointer arithmetic** to get a **pointer** to the next available slot in the `headers` array where the new header will be stored.\n      * `pr->headersused += 1`: Increments the count of used header slots.\n      * `ph->key = (char *)malloc(strlen(key)+1); memcpy(ph->key, key, strlen(key)); ph->key[strlen(key)] = '\\0';`: Dynamically allocates memory for the header `key` string, copies the content from the input `key` (pointed to by `key`), and null-terminates it. `ph->key` becomes a **pointer** to this new memory.\n      * `ph->value = (char *)malloc(strlen(value)+1); memcpy(ph->value, value, strlen(value)); ph->value[strlen(value)] = '\\0';`: Similar dynamic allocation and copying for the header `value`. `ph->value` becomes a **pointer** to this new memory.\n      * `ph->keylen`, `ph->valuelen`: Store the lengths of the `key` and `value` strings.\n\n-----\n\n### `ParsedHeader_get(struct ParsedRequest *pr, const char * key)`\n\n```c\nstruct ParsedHeader* ParsedHeader_get(struct ParsedRequest *pr,\n           const char * key)\n{\n  size_t i = 0;\n  struct ParsedHeader * tmp;\n  while(pr->headersused > i)\n  {\n   tmp = pr->headers + i;\n   if(tmp->key && key && strcmp(tmp->key, key) == 0)\n   {\n     return tmp;\n   }\n   i++;\n  }\n  return NULL;\n}\n```\n\n  * **Purpose**: Searches for a specific header by its `key` within a `ParsedRequest` structure's headers array.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure to search within.\n      * `const char * key`: A **pointer** to the header key string to look for.\n  * **Pointers and Variables**:\n      * `struct ParsedHeader * tmp`: A **pointer** to a `ParsedHeader` structure, used to iterate through the `headers` array.\n      * `while(pr->headersused > i)`: Loops through each header currently stored in the `pr->headers` array.\n      * `tmp = pr->headers + i`: Uses **pointer arithmetic** to get a **pointer** to the `i`-th `ParsedHeader` element in the `headers` array.\n      * `strcmp(tmp->key, key) == 0`: Compares the `key` string stored in the current header (`tmp->key`, a **pointer**) with the input `key` (a **pointer**).\n\n-----\n\n### `ParsedHeader_remove(struct ParsedRequest *pr, const char *key)`\n\n```c\nint ParsedHeader_remove(struct ParsedRequest *pr, const char *key)\n{\n  struct ParsedHeader *tmp;\n  tmp = ParsedHeader_get(pr, key);\n  if(tmp == NULL)\n   return -1;\n\n  free(tmp->key);\n  free(tmp->value);\n  tmp->key = NULL;\n  return 0;\n}\n```\n\n  * **Purpose**: Removes a specific header by its `key` from a `ParsedRequest` structure. It frees the memory associated with that header's key and value strings.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure from which to remove the header.\n      * `const char *key`: A **pointer** to the key string of the header to remove.\n  * **Pointers and Variables**:\n      * `struct ParsedHeader *tmp`: A **pointer** to the `ParsedHeader` structure that `ParsedHeader_get` finds.\n      * `free(tmp->key); free(tmp->value);`: Frees the dynamically allocated memory for the header's key and value strings, which `tmp->key` and `tmp->value` point to.\n      * `tmp->key = NULL;`: Sets the `key` pointer to `NULL` to indicate that this header slot is now \"empty\" or invalid, though it doesn't shift the array elements.\n\n-----\n\n### `ParsedHeader_create(struct ParsedRequest *pr)`\n\n```c\nvoid ParsedHeader_create(struct ParsedRequest *pr)\n{\n  pr->headers =\n  (struct ParsedHeader *)malloc(sizeof(struct ParsedHeader)*DEFAULT_NHDRS);\n  pr->headerslen = DEFAULT_NHDRS;\n  pr->headersused = 0;\n}\n```\n\n  * **Purpose**: Initializes the `headers` array within a `ParsedRequest` structure.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure to initialize.\n  * **Pointers and Variables**:\n      * `pr->headers = (struct ParsedHeader *)malloc(...)`: Dynamically allocates an initial array of `DEFAULT_NHDRS` `ParsedHeader` structures. `pr->headers` is then made to **point** to the beginning of this allocated block.\n\n-----\n\n### `ParsedHeader_lineLen(struct ParsedHeader * ph)`\n\n```c\nsize_t ParsedHeader_lineLen(struct ParsedHeader * ph)\n{\n  if(ph->key != NULL)\n  {\n   return strlen(ph->key)+strlen(ph->value)+4;\n  }\n  return 0;\n}\n```\n\n  * **Purpose**: Calculates the length of a single header line when unparsed into a string (e.g., \"Key: Value\\\\r\\\\n\").\n  * **Parameters**:\n      * `struct ParsedHeader * ph`: A **pointer** to the `ParsedHeader` structure.\n  * **Pointers and Variables**:\n      * `strlen(ph->key)`: Gets the length of the string pointed to by `ph->key`.\n      * `strlen(ph->value)`: Gets the length of the string pointed to by `ph->value`.\n      * `+4`: Accounts for the \": \" (2 bytes) and \"\\\\r\\\\n\" (2 bytes).\n\n-----\n\n### `ParsedHeader_headersLen(struct ParsedRequest *pr)`\n\n```c\nsize_t ParsedHeader_headersLen(struct ParsedRequest *pr)\n{\n  if (!pr || !pr->buf)\n   return 0;\n\n  size_t i = 0;\n  int len = 0;\n  while(pr->headersused > i)\n  {\n   len += ParsedHeader_lineLen(pr->headers + i);\n   i++;\n  }\n  len += 2; // For the final \"\\r\\n\" after all headers\n  return len;\n}\n```\n\n  * **Purpose**: Calculates the total length of all headers in a `ParsedRequest` when they are unparsed into a single string, including the final blank line (`\\r\\n`).\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure.\n  * **Pointers and Variables**:\n      * `pr->headers + i`: Uses **pointer arithmetic** to get a **pointer** to the `i`-th `ParsedHeader` in the array.\n      * `ParsedHeader_lineLen(...)`: Calls the previously explained function to get the length of each individual header line.\n\n-----\n\n### `ParsedHeader_printHeaders(struct ParsedRequest * pr, char * buf, size_t len)`\n\n```c\nint ParsedHeader_printHeaders(struct ParsedRequest * pr, char * buf,\n         size_t len)\n{\n  char * current = buf;\n  struct ParsedHeader * ph;\n  size_t i = 0;\n\n  if(len < ParsedHeader_headersLen(pr))\n  {\n   debug(\"buffer for printing headers too small\\n\");\n   return -1;\n  }\n\n  while(pr->headersused > i)\n  {\n   ph = pr->headers+i;\n   if (ph->key) {\n     memcpy(current, ph->key, strlen(ph->key));\n     memcpy(current+strlen(ph->key), \": \", 2);\n     memcpy(current+strlen(ph->key) +2 , ph->value,\n       strlen(ph->value));\n     memcpy(current+strlen(ph->key) +2+strlen(ph->value) ,\n       \"\\r\\n\", 2);\n     current += strlen(ph->key)+strlen(ph->value)+4;\n   }\n   i++;\n  }\n  memcpy(current, \"\\r\\n\",2);\n  return 0;\n}\n```\n\n  * **Purpose**: Writes the parsed HTTP headers from a `ParsedRequest` structure into a provided character buffer, formatting them as `Key: Value\\r\\n`.\n  * **Parameters**:\n      * `struct ParsedRequest * pr`: A **pointer** to the `ParsedRequest` structure containing the headers.\n      * `char * buf`: A **pointer** to the buffer where the headers will be written.\n      * `size_t len`: The available length of the `buf`.\n  * **Pointers and Variables**:\n      * `char * current = buf`: A **pointer** that tracks the current position in the `buf` where data should be written. It starts at the beginning of `buf` and is incremented after each part of the header is copied.\n      * `struct ParsedHeader * ph`: A **pointer** to the current `ParsedHeader` being processed.\n      * `ph = pr->headers + i`: Uses **pointer arithmetic** to get the address of the `i`-th header in the `headers` array.\n      * `memcpy(current, ph->key, strlen(ph->key))`: Copies the header key (pointed to by `ph->key`) into the `current` position of the `buf`.\n      * `current += strlen(ph->key)`: Moves `current` **pointer** forward by the length of the copied key. Similar pointer arithmetic is used for copying the \": \", value, and \"\\\\r\\\\n\".\n\n-----\n\n### `ParsedHeader_destroyOne(struct ParsedHeader * ph)`\n\n```c\nvoid ParsedHeader_destroyOne(struct ParsedHeader * ph)\n{\n  if(ph->key != NULL)\n  {\n   free(ph->key);\n   ph->key = NULL;\n   free(ph->value);\n   ph->value = NULL;\n   ph->keylen = 0;\n   ph->valuelen = 0;\n  }\n}\n```\n\n  * **Purpose**: Frees the dynamically allocated memory for the `key` and `value` strings within a single `ParsedHeader` structure.\n  * **Parameters**:\n      * `struct ParsedHeader * ph`: A **pointer** to the `ParsedHeader` structure to destroy.\n  * **Pointers and Variables**:\n      * `free(ph->key); free(ph->value);`: Frees the memory blocks that `ph->key` and `ph->value` point to.\n      * `ph->key = NULL; ph->value = NULL;`: Sets the pointers to `NULL` after freeing, which is good practice to prevent dangling pointers.\n\n-----\n\n### `ParsedHeader_destroy(struct ParsedRequest * pr)`\n\n```c\nvoid ParsedHeader_destroy(struct ParsedRequest * pr)\n{\n  size_t i = 0;\n  while(pr->headersused > i)\n  {\n   ParsedHeader_destroyOne(pr->headers + i);\n   i++;\n  }\n  pr->headersused = 0;\n\n  free(pr->headers);\n  pr->headerslen = 0;\n}\n```\n\n  * **Purpose**: Frees all dynamically allocated memory associated with the `headers` array within a `ParsedRequest` structure.\n  * **Parameters**:\n      * `struct ParsedRequest * pr`: A **pointer** to the `ParsedRequest` structure whose headers are to be destroyed.\n  * **Pointers and Variables**:\n      * `ParsedHeader_destroyOne(pr->headers + i)`: Calls `ParsedHeader_destroyOne` for each individual header in the `headers` array (accessed using **pointer arithmetic** `pr->headers + i`).\n      * `free(pr->headers)`: Frees the main memory block that holds the array of `ParsedHeader` structures, which `pr->headers` points to.\n\n-----\n\n### `ParsedHeader_parse(struct ParsedRequest * pr, char * line)`\n\n```c\nint ParsedHeader_parse(struct ParsedRequest * pr, char * line)\n{\n  char * key;\n  char * value;\n  char * index1;\n  char * index2;\n\n  index1 = index(line, ':'); // Find the colon separating key and value\n  if(index1 == NULL) { /* ... error ... */ }\n  key = (char *)malloc((index1-line+1)*sizeof(char));\n  memcpy(key, line, index1-line);\n  key[index1-line]='\\0';\n\n  index1 += 2; // Move past \": \"\n  index2 = strstr(index1, \"\\r\\n\"); // Find the end of the header line\n  value = (char *) malloc((index2-index1+1)*sizeof(char));\n  memcpy(value, index1, (index2-index1));\n  value[index2-index1] = '\\0';\n\n  ParsedHeader_set(pr, key, value);\n  free(key);\n  free(value);\n  return 0;\n}\n```\n\n  * **Purpose**: Parses a single raw HTTP header line (e.g., \"Host: [www.example.com](https://www.example.com)\\\\r\\\\n\") into its key and value components, and then adds them to the `ParsedRequest` structure.\n  * **Parameters**:\n      * `struct ParsedRequest * pr`: A **pointer** to the `ParsedRequest` structure to add the parsed header to.\n      * `char * line`: A **pointer** to the raw header line string.\n  * **Pointers and Variables**:\n      * `char * key`, `char * value`: **Pointers** that will temporarily hold the extracted key and value strings.\n      * `char * index1`, `char * index2`: **Pointers** used to mark positions within the `line` string.\n      * `index1 = index(line, ':')`: Finds the first occurrence of `':'` in the `line` string. `index` returns a **pointer** to that character.\n      * `key = (char *)malloc((index1-line+1)*sizeof(char))`: Dynamically allocates memory for the `key` string. `index1-line` calculates the length of the key by finding the difference in memory addresses between `index1` and `line`.\n      * `memcpy(key, line, index1-line); key[index1-line]='\\0';`: Copies the key characters from `line` into the `key` buffer and null-terminates it.\n      * `index1 += 2`: Moves `index1` **pointer** past the `\": \"` characters to the start of the value.\n      * `index2 = strstr(index1, \"\\r\\n\")`: Finds the end of the header line (`\\r\\n`) starting from `index1`. `strstr` returns a **pointer** to the `\\r\\n`.\n      * `value = (char *) malloc((index2-index1+1)*sizeof(char))`: Dynamically allocates memory for the `value` string based on the length between `index1` and `index2`.\n      * `memcpy(value, index1, (index2-index1)); value[index2-index1] = '\\0';`: Copies the value characters and null-terminates them.\n      * `ParsedHeader_set(pr, key, value)`: Calls the function to add this parsed key-value pair to the `ParsedRequest` structure.\n      * `free(key); free(value);`: Frees the temporary memory allocated for `key` and `value` strings.\n\n-----\n\n### `ParsedRequest_destroy(struct ParsedRequest *pr)`\n\n```c\nvoid ParsedRequest_destroy(struct ParsedRequest *pr)\n{\n  if(pr->buf != NULL)\n  {\n   free(pr->buf);\n  }\n  if (pr->path != NULL) {\n   free(pr->path);\n  }\n  if(pr->headerslen > 0)\n  {\n   ParsedHeader_destroy(pr);\n  }\n  free(pr);\n}\n```\n\n  * **Purpose**: Frees all dynamically allocated memory associated with a `ParsedRequest` structure and its internal components.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure to destroy.\n  * **Pointers and Variables**:\n      * `free(pr->buf); free(pr->path);`: Frees the memory blocks pointed to by `pr->buf` (the request line) and `pr->path` (if it was separately allocated).\n      * `ParsedHeader_destroy(pr)`: Calls the function to free all headers within the `ParsedRequest`.\n      * `free(pr)`: Frees the `ParsedRequest` structure itself, which `pr` points to.\n\n-----\n\n### `ParsedRequest_create()`\n\n```c\nstruct ParsedRequest* ParsedRequest_create()\n{\n  struct ParsedRequest *pr;\n  pr = (struct ParsedRequest *)malloc(sizeof(struct ParsedRequest));\n  if (pr != NULL)\n  {\n   ParsedHeader_create(pr);\n   pr->buf = NULL;\n   pr->method = NULL;\n   pr->protocol = NULL;\n   pr->host = NULL;\n   pr->path = NULL;\n   pr->version = NULL;\n   pr->buf = NULL;\n   pr->buflen = 0;\n  }\n  return pr;\n}\n```\n\n  * **Purpose**: Allocates memory for and initializes a new `ParsedRequest` structure.\n  * **Parameters**: None.\n  * **Pointers and Variables**:\n      * `struct ParsedRequest *pr`: A **pointer** that will point to the newly allocated `ParsedRequest` structure.\n      * `pr = (struct ParsedRequest *)malloc(sizeof(struct ParsedRequest))`: Dynamically allocates memory for the `ParsedRequest` structure.\n      * `ParsedHeader_create(pr)`: Initializes the `headers` array within the new `ParsedRequest` structure.\n      * `pr->buf = NULL; pr->method = NULL; ...`: Initializes all other **pointers** within the `ParsedRequest` structure to `NULL` to ensure they start in a defined state.\n\n-----\n\n### `ParsedRequest_unparse(struct ParsedRequest *pr, char *buf, size_t buflen)`\n\n```c\nint ParsedRequest_unparse(struct ParsedRequest *pr, char *buf,\n       size_t buflen)\n{\n  if (!pr || !pr->buf)\n   return -1;\n\n  size_t tmp;\n  if (ParsedRequest_printRequestLine(pr, buf, buflen, &tmp) < 0)\n   return -1;\n  if (ParsedHeader_printHeaders(pr, buf+tmp, buflen-tmp) < 0)\n   return -1;\n  return 0;\n}\n```\n\n  * **Purpose**: Reconstructs the entire raw HTTP request string (request line + headers) from a `ParsedRequest` structure into a provided buffer.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure.\n      * `char *buf`: A **pointer** to the destination buffer.\n      * `size_t buflen`: The maximum size of the destination buffer.\n  * **Pointers and Variables**:\n      * `size_t tmp`: A variable to store the length of the request line printed. `&tmp` passes the **address** of `tmp` so `ParsedRequest_printRequestLine` can modify its value.\n      * `ParsedRequest_printRequestLine(pr, buf, buflen, &tmp)`: Prints the request line into `buf` and updates `tmp` with its length.\n      * `ParsedHeader_printHeaders(pr, buf+tmp, buflen-tmp)`: Prints the headers into `buf` starting *after* the request line. `buf+tmp` is **pointer arithmetic** that moves the pointer to the correct starting position.\n\n-----\n\n### `ParsedRequest_unparse_headers(struct ParsedRequest *pr, char *buf, size_t buflen)`\n\n```c\nint ParsedRequest_unparse_headers(struct ParsedRequest *pr, char *buf,\n         size_t buflen)\n{\n  if (!pr || !pr->buf)\n   return -1;\n\n  if (ParsedHeader_printHeaders(pr, buf, buflen) < 0)\n   return -1;\n  return 0;\n}\n```\n\n  * **Purpose**: Reconstructs only the HTTP headers from a `ParsedRequest` structure into a provided buffer.\n  * **Parameters**: Same as `ParsedRequest_unparse`, but it only deals with headers.\n  * **Pointers and Variables**:\n      * `ParsedHeader_printHeaders(pr, buf, buflen)`: Directly calls `ParsedHeader_printHeaders` to write the headers into `buf`.\n\n-----\n\n### `ParsedRequest_totalLen(struct ParsedRequest *pr)`\n\n```c\nsize_t ParsedRequest_totalLen(struct ParsedRequest *pr)\n{\n  if (!pr || !pr->buf)\n   return 0;\n  return ParsedRequest_requestLineLen(pr)+ParsedHeader_headersLen(pr);\n}\n```\n\n  * **Purpose**: Calculates the total length of the entire HTTP request (request line + headers) if it were unparsed into a single string.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure.\n  * **Pointers and Variables**:\n      * Calls `ParsedRequest_requestLineLen(pr)` and `ParsedHeader_headersLen(pr)` to get the lengths of the respective parts and sums them.\n\n-----\n\n### `ParsedRequest_parse(struct ParsedRequest * parse, const char *buf, int buflen)`\n\n```c\nint\nParsedRequest_parse(struct ParsedRequest * parse, const char *buf,\n      int buflen)\n{\n  char *full_addr;\n  char *saveptr; // For strtok_r\n  char *index;\n  char *currentHeader;\n\n  // ... checks for valid buffer, copies to tmp_buf ...\n\n  index = strstr(tmp_buf, \"\\r\\n\"); // Find end of request line\n  // ... copy request line to parse->buf ...\n\n  /* Parse request line */\n  parse->method = strtok_r(parse->buf, \" \", &saveptr);\n  // ... error checks for method ...\n\n  full_addr = strtok_r(NULL, \" \", &saveptr);\n  // ... error checks for full_addr ...\n\n  parse->version = full_addr + strlen(full_addr) + 1; // Pointer arithmetic to get version\n  // ... error checks for version ...\n\n  parse->protocol = strtok_r(full_addr, \"://\", &saveptr);\n  // ... error checks for protocol ...\n\n  parse->host = strtok_r(NULL, \"/\", &saveptr);\n  // ... error checks for host ...\n\n  parse->path = strtok_r(NULL, \" \", &saveptr);\n  // ... handling for path ...\n\n  parse->host = strtok_r(parse->host, \":\", &saveptr); // Separate host and port\n  parse->port = strtok_r(NULL, \"/\", &saveptr);\n\n  // ... error checks for host and port ...\n \n  /* Parse headers */\n  currentHeader = strstr(tmp_buf, \"\\r\\n\")+2; // Start after first \\r\\n\n  while (currentHeader[0] != '\\0' &&\n    !(currentHeader[0] == '\\r' && currentHeader[1] == '\\n')) {\n  \n   if (ParsedHeader_parse(parse, currentHeader)) { /* ... handle error ... */ }\n\n   currentHeader = strstr(currentHeader, \"\\r\\n\"); // Find next header line\n   // ... error checks ...\n   currentHeader += 2;\n  }\n  free(tmp_buf);\n  return ret;\n}\n```\n\n  * **Purpose**: This is the core parsing function. It takes a raw HTTP request buffer and populates a `ParsedRequest` structure with its components (method, URL parts, version, and headers).\n  * **Parameters**:\n      * `struct ParsedRequest * parse`: A **pointer** to the `ParsedRequest` structure to populate.\n      * `const char *buf`: A **pointer** to the raw HTTP request string.\n      * `int buflen`: The length of the raw request buffer.\n  * **Pointers and Variables**:\n      * `char *tmp_buf = (char *)malloc(buflen + 1);`: Creates a mutable, null-terminated copy of the input `buf`. This is important because `strtok_r` modifies the string it operates on. `tmp_buf` is a **pointer** to this copy.\n      * `char *saveptr`: A **pointer** used by `strtok_r` to maintain its internal state, allowing it to be re-entrant (safe for use in multithreaded environments).\n      * `char *index`: A **pointer** used to find substrings like `\\r\\n` within `tmp_buf`.\n      * `char *currentHeader`: A **pointer** that iterates through the header lines in `tmp_buf`.\n      * `parse->method = strtok_r(parse->buf, \" \", &saveptr)`: `strtok_r` is used repeatedly to break down the request line and URL into their individual components. It modifies `parse->buf` in place and returns **pointers** to the start of each token (e.g., \"GET\", \"http\", \"[www.example.com](https://www.example.com)\"). These **pointers** are then assigned to `parse->method`, `parse->protocol`, `parse->host`, `parse->path`, `parse->port`, and `parse->version`.\n          * **Important**: Many of these `parse->` members directly **point** into the `parse->buf` (or `tmp_buf` initially). This means they are *not* separately allocated strings but rather \"views\" into a larger string. `parse->path` is an exception as it may be allocated separately if it's the root path.\n      * `parse->version = full_addr + strlen(full_addr) + 1;`: This is an example of **pointer arithmetic**. `full_addr` points to \"[http://www.example.com/some/path](https://www.google.com/search?q=http://www.example.com/some/path)\". `strlen(full_addr)` gets its length. Adding `strlen(full_addr) + 1` moves the pointer past this part and the space, directly to the \"HTTP/1.1\" string which becomes `parse->version`.\n      * `ParsedHeader_parse(parse, currentHeader)`: This function is called in a loop for each header line found. It parses individual header lines and adds them to the `ParsedRequest` structure.\n      * `free(tmp_buf)`: Frees the temporary copy of the request buffer.\n\n-----\n\n### `ParsedRequest_requestLineLen(struct ParsedRequest *pr)`\n\n```c\nsize_t ParsedRequest_requestLineLen(struct ParsedRequest *pr)\n{\n  if (!pr || !pr->buf)\n   return 0;\n\n  size_t len =\n   strlen(pr->method) + 1 + strlen(pr->protocol) + 3 +\n   strlen(pr->host) + 1 + strlen(pr->version) + 2;\n  if(pr->port != NULL)\n  {\n   len += strlen(pr->port)+1;\n  }\n  /* path is at least a slash */\n  len += strlen(pr->path);\n  return len;\n}\n```\n\n  * **Purpose**: Calculates the length of the HTTP request line if it were unparsed into a string.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure.\n  * **Pointers and Variables**:\n      * It uses `strlen()` on the various **pointers** within the `ParsedRequest` structure (`pr->method`, `pr->protocol`, `pr->host`, `pr->version`, `pr->port`, `pr->path`) to sum up their lengths and add fixed lengths for spaces, \"://\", and \"\\\\r\\\\n\".\n\n-----\n\n### `ParsedRequest_printRequestLine(struct ParsedRequest *pr, char * buf, size_t buflen, size_t *tmp)`\n\n```c\nint ParsedRequest_printRequestLine(struct ParsedRequest *pr,\n         char * buf, size_t buflen,\n         size_t *tmp)\n{\n  char * current = buf;\n\n  if(buflen < ParsedRequest_requestLineLen(pr)) { /* ... error ... */ }\n  memcpy(current, pr->method, strlen(pr->method));\n  current += strlen(pr->method);\n  current[0] = ' ';\n  current += 1;\n\n  // ... similar memcpy and pointer arithmetic for protocol, host, port, path, version ...\n\n  *tmp = current-buf; // Calculate total length written\n  return 0;\n}\n```\n\n  * **Purpose**: Writes the components of the HTTP request line (method, URL parts, version) from a `ParsedRequest` structure into a provided character buffer, formatted as a standard HTTP request line.\n  * **Parameters**:\n      * `struct ParsedRequest *pr`: A **pointer** to the `ParsedRequest` structure.\n      * `char * buf`: A **pointer** to the destination buffer.\n      * `size_t buflen`: The maximum size of the destination buffer.\n      * `size_t *tmp`: A **pointer** to a `size_t` variable where the total length of the written request line will be stored.\n  * **Pointers and Variables**:\n      * `char * current = buf`: A **pointer** that keeps track of the current writing position within the `buf`.\n      * `memcpy(current, pr->method, strlen(pr->method))`: Copies the string pointed to by `pr->method` into the `current` position of `buf`.\n      * `current += strlen(pr->method)`: Advances the `current` **pointer** by the length of the copied string. This pattern is repeated for all parts of the request line (`pr->protocol`, `pr->host`, `pr->port`, `pr->path`, `pr->version`), along with adding spaces, \"://\", and \"\\\\r\\\\n\".\n      * `*tmp = current-buf;`: After writing all parts of the request line, this line calculates the total number of bytes written. It subtracts the starting **address** of `buf` from the final **address** of `current`. The result is then stored in the `size_t` variable pointed to by `tmp` (using **dereferencing**).\n\n-----\n\nThis detailed explanation covers the core functions, global variables, and the extensive use of pointers in both the main proxy server logic and the `proxy_parse` library. Understanding how pointers are used for memory management (malloc, realloc, free), accessing structure members (`->`), string manipulation (`strcpy`, `strcat`, `strstr`, `strtok_r`), and passing data to threads is fundamental to grasping this C code.",
      "excerpt": "This code sets up a multithreaded proxy server that handles HTTP GET requests and includes a caching mechanism to improve performance. It's designed to accept multiple client connections concurrently ...",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-07-23T10:12:02.000Z"
    },
    {
      "id": "991-clang-algs-bfs-md",
      "slug": "991-clang/algs/bfs",
      "filepath": "991-CLANG/ALGS/BFS.md",
      "folder": "991-CLANG/ALGS",
      "filename": "BFS.md",
      "frontmatter": {
        "title": "Def:",
        "date": "2025-08-17",
        "tags": [
          "python",
          "do"
        ],
        "category": "991-CLANG/ALGS"
      },
      "content": "## Def:\nBreadth-First Search (BFS) is ==a graph traversal algorithm that explores a graph level by level==\n\n![[Pasted image 20250817174830.png]]\n### ALGORITHM \n```python\nvisited = [False] * GRID_SIZE\ndef BFS(GRID, STARTING):\n\tqueue = [STARTING]\n\twhile(!queue.isEmpty()):\n\t\tNEW_NODE = queue.pop()\n\t\tif not visited:\n\t\t\tvisit(NEW_NODE) #DO SOMETHING\n\t\t\tvisited[NEW_NODE] = TRUE\n\t\t\tfor w in GRID.NEIGHBORS(NEW_NODE):\n\t\t\t\tif !visited(w):\n\t\t\t\t\tqueue.append(w)\n```\n\n### FLOOD FILL\n- **PYTHON**\n```python \nfrom collections import deque\nclass Solution:\n    \n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        start = image[sr][sc]\n        visited = set()\n        queue = deque([(sr, sc)])\n        while(q):\n            row,col = queue.popleft()\n            visited.add(row,col)\n            image[row][col] = color\n            for row,col in neighbours(image,row,col,start):\n                if(row,col) not in visited:\n                    queue.append((row,col))\n        return image\n    def neighbours(image,row,col,start):\n        indices = [(row-1,col),(row+1,col),(row,col-1),(row,col+1)]\n        return [(row,col) for row,col in indices if isValid(image,row,col) and image[row,col] == start]\n    def isValid(image,row,col):\n        return row > 0 and col>0 and row<len(image) and col<len(image[0])\n\n\n        \n```",
      "excerpt": "Def:\nBreadth-First Search (BFS) is ==a graph traversal algorithm that explores a graph level by level==\n\n![[Pasted image 20250817174830.png]]\nALGORITHM \n\n\nFLOOD FILL\n- PYTHON",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-08-17T13:16:03.586Z"
    },
    {
      "id": "991-clang-algs-dfs-md",
      "slug": "991-clang/algs/dfs",
      "filepath": "991-CLANG/ALGS/DFS.md",
      "folder": "991-CLANG/ALGS",
      "filename": "DFS.md",
      "frontmatter": {
        "title": "DFS",
        "date": "2025-08-18",
        "tags": [
          "python"
        ],
        "category": "991-CLANG/ALGS"
      },
      "content": "### Using recursion\n```python\nmarksed = [False] * GRIDSIZE\ndef dfs(G,v):\n\tvisit(v)\n\tmarked[v] = True\n\tfor w in neighbours(G,v):\n\t\tif not marked[w]:\n\t\t\tdfs(G,w)\n```\n\n### Using Stack\n```python\nmarksed = [False] * GRIDSIZE\ndef dfs(G,v):\n\tstack = [v]\n\twhile stackNotEmpty():\n\t\tv = stack.pop()\n\t\tif not marked[w]:\n\t\t\t\tvisit(v)\n\t\t\t\tmarked[v] = True\n\t\t\t\tfor w in neighbours(G,v):\n\t\t\t\t\tif not marked[w]:\n\t\t\t\t\t\tstack.append(w)\n```",
      "excerpt": "Using recursion\n\n\nUsing Stack",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-08-18T12:54:33.805Z"
    },
    {
      "id": "991-clang-algs-dijkstra-algorithm-md",
      "slug": "991-clang/algs/dijkstra-algorithm",
      "filepath": "991-CLANG/ALGS/Dijkstra Algorithm.md",
      "folder": "991-CLANG/ALGS",
      "filename": "Dijkstra Algorithm.md",
      "frontmatter": {
        "title": "Dijkstra Algorithm",
        "date": "2025-09-04",
        "category": "991-CLANG/ALGS"
      },
      "content": "\n\n### 1. Dijkstra's Algorithm: Finding the Shortest Path\n\nImagine you're standing in a city and want to find the shortest walking time to every other location. Dijkstra's algorithm is a methodical way to do this.\n\n**The Core Idea**: Start at a source point and explore outwards. Always prioritize exploring from the location you've reached that has the shortest total travel time from your start. It's a \"greedy\" approach because you always choose the path that seems best at the moment.\n\n**The Key Components**:\n* **Nodes (Vertices)**: These are the locations (e.g., intersections in a city).\n* **Edges**: These are the paths connecting the locations (e.g., streets).\n* **Weights**: This is the \"cost\" to travel an edge (e.g., the time it takes to walk down a street). For Dijkstra's to work, these weights **must not be negative**.\n\n**The Steps**:\n1.  **Initialization**:\n    * Pick a starting node. The distance to this node is 0.\n    * The distance to every other node is initially unknown, so we mark it as infinity.\n    * Keep track of all nodes you haven't visited yet.\n\n2.  **The Loop**:\n    * From your set of unvisited nodes, pick the one with the smallest known distance from the start. Let's call this the `current_node`.\n    * For the `current_node`, look at all its directly connected neighbors.\n    * For each neighbor, calculate the distance from the start point *through* the `current_node`. This is `(distance to current_node) + (weight of the edge to the neighbor)`.\n    * If this new calculated distance is shorter than the neighbor's previously known distance, update it.\n    * Once you've checked all neighbors, mark the `current_node` as visited. You're done with it because you've found the guaranteed shortest path to it.\n    * Repeat this process until you've visited all nodes (or just the destination node if you only need one path).\n\n\n\n---\n\n### 2. Priority Queues: The Engine for Dijkstra's\n\nHow do you efficiently perform the step \"pick the unvisited node with the smallest known distance\"? If you have thousands of nodes, searching through a list every time is very slow. This is where a priority queue comes in.\n\n**What it is**: A priority queue is a special data structure where every element has a \"priority.\" When you ask for an element, it **always gives you the one with the highest (or lowest) priority**.\n\n**How it helps Dijkstra's**:\n* You store the nodes to visit in a priority queue.\n* The \"priority\" of each node is its **total distance from the start**.\n* When Dijkstra's algorithm needs the next node to visit, it simply asks the priority queue for the element with the lowest priority (the shortest distance). This is extremely fast.\n\nSo, the priority queue acts as an efficient to-do list, ensuring the algorithm always explores the most promising node next without wasting time searching.\n\n### APPLY IN AOC day 17\n[[Day 17]]\n",
      "excerpt": "1. Dijkstra's Algorithm: Finding the Shortest Path\n\nImagine you're standing in a city and want to find the shortest walking time to every other location. Dijkstra's algorithm is a methodical way to do...",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-09-04T16:36:20.452Z"
    },
    {
      "id": "991-clang-ds-linked-list-md",
      "slug": "991-clang/ds/linked-list",
      "filepath": "991-CLANG/DS/Linked List.md",
      "folder": "991-CLANG/DS",
      "filename": "Linked List.md",
      "frontmatter": {
        "title": "1 **What is a Linked List?**",
        "date": "2025-11-14",
        "tags": [
          "c",
          "include"
        ],
        "category": "991-CLANG/DS"
      },
      "content": "\n# 1 **What is a Linked List?**\n\nA **Linked List** is a linear data structure where elements (called **nodes**) are stored in **non-contiguous memory locations**.\n\nEach node contains:\n\n1. **Data**\n2. **Pointer to the next node**\n\n```\n[Data | Next]  [Data | Next]  [Data | Next]  NULL\n```\n\n---\n\n# 2 **Why Linked List?**\n\n###  Advantages\n\n* **Dynamic size** (grows/shrinks at runtime)\n* **Efficient insertion/deletion** (O(1) if position known)\n* No need for contiguous memory (unlike arrays)\n* Useful for implementing stacks, queues, graphs.\n\n###  Disadvantages\n\n* No random access (must traverse sequentially)\n* Extra memory for storing pointers\n* Slower traversal due to pointer overhead\n* Not cache-friendly\n\n---\n\n# 3 **Types of Linked Lists**\n\n---\n\n##  3.1 **Singly Linked List**\n\nEach node has:\n\n* data\n* pointer to **next** node\n\n```\n+------+------+\n| Data | Next | --->  +------+------+\n+------+------         | Data | Next | ---> NULL\n```\n\n### Pointer structure (C):\n\n```c\nstruct Node {\n    int data;\n    struct Node* next;\n};\n```\n\n---\n\n##  3.2 **Doubly Linked List**\n\nEach node has:\n\n* data\n* pointer to previous node\n* pointer to next node\n\n```\nNULL  [Prev | Data | Next]  [Prev | Data | Next]  NULL\n```\n\n### Structure:\n\n```c\nstruct Node {\n    int data;\n    struct Node* prev;\n    struct Node* next;\n};\n```\n\n---\n\n##  3.3 **Circular Linked List**\n\nLast node points back to the **head**, not NULL.\n\n### Circular Singly:\n\n```\nA  B  C  D  A (head)\n```\n\n### Circular Doubly:\n\n```\n A  B  C  D  (back to A)\n```\n\n### Structure similar to singly/doubly  only last node links to head.\n\n---\n\n---\n\n# 4 **SINGLY LINKED LIST  Full Implementation in C**\n\n---\n\n##  4.1 Node Structure\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n```\n\n---\n\n##  4.2 Insert at Beginning\n\n```c\nstruct Node* insertAtBeginning(struct Node* head, int value) {\n    struct Node* newNode = malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = head;\n    return newNode;\n}\n```\n\n---\n\n##  4.3 Insert at End\n\n```c\nstruct Node* insertAtEnd(struct Node* head, int value) {\n    struct Node* newNode = malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n\n    if (head == NULL) return newNode;\n\n    struct Node* temp = head;\n    while (temp->next != NULL)\n        temp = temp->next;\n\n    temp->next = newNode;\n    return head;\n}\n```\n\n---\n\n##  4.4 Insert at Position\n\n```c\nstruct Node* insertAtPosition(struct Node* head, int value, int pos) {\n    if (pos == 1)\n        return insertAtBeginning(head, value);\n\n    struct Node* newNode = malloc(sizeof(struct Node));\n    newNode->data = value;\n\n    struct Node* temp = head;\n    for (int i = 1; i < pos - 1 && temp != NULL; i++)\n        temp = temp->next;\n\n    if (temp == NULL) {\n        printf(\"Position out of bounds\\n\");\n        return head;\n    }\n\n    newNode->next = temp->next;\n    temp->next = newNode;\n\n    return head;\n}\n```\n\n---\n\n##  4.5 Delete from Beginning\n\n```c\nstruct Node* deleteFromBeginning(struct Node* head) {\n    if (head == NULL) return NULL;\n\n    struct Node* temp = head;\n    head = head->next;\n    free(temp);\n    return head;\n}\n```\n\n---\n\n##  4.6 Delete from End\n\n```c\nstruct Node* deleteFromEnd(struct Node* head) {\n    if (head == NULL) return NULL;\n\n    if (head->next == NULL) {\n        free(head);\n        return NULL;\n    }\n\n    struct Node* temp = head;\n    while (temp->next->next != NULL)\n        temp = temp->next;\n\n    free(temp->next);\n    temp->next = NULL;\n\n    return head;\n}\n```\n\n---\n\n##  4.7 Delete at Position\n\n```c\nstruct Node* deleteAtPosition(struct Node* head, int pos) {\n    if (pos == 1)\n        return deleteFromBeginning(head);\n\n    struct Node* temp = head;\n    for (int i = 1; i < pos - 1 && temp != NULL; i++)\n        temp = temp->next;\n\n    if (temp == NULL || temp->next == NULL) {\n        printf(\"Position invalid\\n\");\n        return head;\n    }\n\n    struct Node* target = temp->next;\n    temp->next = target->next;\n    free(target);\n\n    return head;\n}\n```\n\n---\n\n##  4.8 Searching in Linked List\n\n```c\nvoid search(struct Node* head, int key) {\n    int pos = 1;\n    while (head != NULL) {\n        if (head->data == key) {\n            printf(\"Found at position %d\\n\", pos);\n            return;\n        }\n        head = head->next;\n        pos++;\n    }\n    printf(\"Not found\\n\");\n}\n```\n\n---\n\n##  4.9 Display List\n\n```c\nvoid display(struct Node* head) {\n    while (head != NULL) {\n        printf(\"%d  \", head->data);\n        head = head->next;\n    }\n    printf(\"NULL\\n\");\n}\n```\n\n---\n##  4.10 Reverse a List\n\n```c\nvoid reverseList(struct Node** headRef) {\n  struct Node* prev = NULL;\n  struct Node* current = *headRef;\n  struct Node* next = NULL;\n\n  while (current != NULL) {\n    next = current->next;\n    current->next = prev;\n    prev = current;\n    current = next;\n  }\n  *headRef = prev;\n}\n```\n\n---\n\n\n# 5 **DOUBLY LINKED LIST  Main Operations**\n\n(Short version; can expand if you want)\n\n---\n\n##  5.1 Structure\n\n```c\nstruct Node {\n    int data;\n    struct Node* prev;\n    struct Node* next;\n};\n```\n\n---\n\n##  5.2 Insert at Beginning\n\n```c\nstruct Node* insertAtBeginning(struct Node* head, int value) {\n    struct Node* newNode = malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->prev = NULL;\n    newNode->next = head;\n\n    if (head != NULL)\n        head->prev = newNode;\n\n    return newNode;\n}\n```\n\n---\n\n##  5.3 Insert at End\n\n```c\nstruct Node* insertAtEnd(struct Node* head, int value) {\n    struct Node* newNode = malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n\n    if (head == NULL) {\n        newNode->prev = NULL;\n        return newNode;\n    }\n\n    struct Node* temp = head;\n    while (temp->next != NULL)\n        temp = temp->next;\n\n    temp->next = newNode;\n    newNode->prev = temp;\n    return head;\n}\n```\n\n---\n\n# 6 **CIRCULAR LINKED LIST (Concept)**\n\n### Changes:\n\n* Last node points back to **head**.\n* Useful for round-robin scheduling, music playlists, queues.\n\n### Example:\n\n```\nhead  A  B  C  (back to head)\n```\n\n---\n\n# 7 **Linked List vs Array**\n\n| Feature         | Array             | Linked List |\n| --------------- | ----------------- | ----------- |\n| Memory          | Contiguous        | Anywhere    |\n| Insert/Delete   | Expensive (shift) | O(1)        |\n| Access          | O(1) random       | O(n)        |\n| Memory overhead | Low               | High        |\n| Cache-friendly  | Yes               | No          |\n\n---\n\n# 8 **Real-life Applications**\n\n* Undo/Redo in editors\n* Playlist navigation\n* Browser forward/back history\n* Queues/stacks implementation\n* Graph adjacency lists\n* Memory management (free list)\n\n---\n\n",
      "excerpt": "1 What is a Linked List?\n\nA Linked List is a linear data structure where elements (called nodes) are stored in non-contiguous memory locations.\n\nEach node contains:\n\n1. Data\n2. Pointer to the next n...",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-11-14T11:09:02.580Z"
    },
    {
      "id": "991-clang-ds-priority-queue-md",
      "slug": "991-clang/ds/priority-queue",
      "filepath": "991-CLANG/DS/Priority Queue.md",
      "folder": "991-CLANG/DS",
      "filename": "Priority Queue.md",
      "frontmatter": {
        "title": "Priority Queue",
        "date": "2025-09-05",
        "tags": [
          "c",
          "include",
          "define"
        ],
        "category": "991-CLANG/DS"
      },
      "content": "\n\n> [!NOTE] Def:\n> Priority queue is an abstract data type(ADT) in the computer science which is designed to the operate much like the regular queue except that each element has the certain priority. The priority can determines the order in which elements are dequeued - elements with the higher priority are removed from queue before those with lower priority\n\n```c\ntypedef struct {\n    int items[MAX];\n    int size;\n} PriorityQueue;\n\n```\n\n### 1. Enqueue Operation\n\nThis operation can be used to add the new element to the priority queue with the given priority.\n\n****Algorithm****\n\n> - Add the element to end of the heap.\n> - Restore the heap property by the comparing the added element with its parent. If it can violates the heap property, swap them.\n> - Continues this process up the heap until the correct position is found or root is reached.\n\n### 2. Dequeue (Extract - Min/Max)\n\nThis operation can be used to removes and return the elements with the highest max in the max-heap and min in the min-heap of the priority queue.\n\n****Algorithms****\n\n> 1. Replace the root of heap with the last element in the heap.\n> 2. Reduce the size of the heap by the one.\n> 3. Restore the heap property by the recursively comparing the new root with its children and swapping it\n> 4. with the higher priority child in the max-heap or the lower priority child in the min heap.\n> 5. Continues this process down the heap until the correct position is found or the leaf is reached.\n\n### 3. Peek\n\nThis operation can be used to returns the element with the highest priority without the removing it from the priority queue.\n\n****Algorithm****\n\n> 1. Return the element at the root of the heap.\n\n### 4. Increase/Decrease Key\n\nThis operation can be used to change the priority of the element in the priority queue.\n\n****Algorithm****\n\n> 1. Locate the element whose the priority needs to be updated.\n> 2. Update the priority of the element.\n> 3. If the priority is increased in the max-heap or decreased in the min-heap and it can restore the heap property by the heapifying up from the element.\n> 4. If the priority is decreased in the max-heap or increased in the min-heap and restore the heap property by the heapifying down from element.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define maximum size of the priority queue\n#define MAX 100\n\n// Define PriorityQueue structure\ntypedef struct {\n    int items[MAX];\n    int size;\n} PriorityQueue;\n\n// Define swap function to swap two integers\nvoid swap(int* a, int* b)\n{\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\n// Define heapifyUp function to maintain heap property\n// during insertion\nvoid heapifyUp(PriorityQueue* pq, int index)\n{\n    if (index\n        && pq->items[(index - 1) / 2] > pq->items[index]) {\n        swap(&pq->items[(index - 1) / 2],\n             &pq->items[index]);\n        heapifyUp(pq, (index - 1) / 2);\n    }\n}\n\n// Define enqueue function to add an item to the queue\nvoid enqueue(PriorityQueue* pq, int value)\n{\n    if (pq->size == MAX) {\n        printf(\"Priority queue is full\\n\");\n        return;\n    }\n\n    pq->items[pq->size++] = value;\n    heapifyUp(pq, pq->size - 1);\n}\n\n// Define heapifyDown function to maintain heap property\n// during deletion\nint heapifyDown(PriorityQueue* pq, int index)\n{\n    int smallest = index;\n    int left = 2 * index + 1;\n    int right = 2 * index + 2;\n\n    if (left < pq->size\n        && pq->items[left] < pq->items[smallest])\n        smallest = left;\n\n    if (right < pq->size\n        && pq->items[right] < pq->items[smallest])\n        smallest = right;\n\n    if (smallest != index) {\n        swap(&pq->items[index], &pq->items[smallest]);\n        heapifyDown(pq, smallest);\n    }\n}\n\n// Define dequeue function to remove an item from the queue\nint dequeue(PriorityQueue* pq)\n{\n    if (!pq->size) {\n        printf(\"Priority queue is empty\\n\");\n        return -1;\n    }\n\n    int item = pq->items[0];\n    pq->items[0] = pq->items[--pq->size];\n    heapifyDown(pq, 0);\n    return item;\n}\n\n// Define peek function to get the top item from the queue\nint peek(PriorityQueue* pq)\n{\n    if (!pq->size) {\n        printf(\"Priority queue is empty\\n\");\n        return -1;\n    }\n    return pq->items[0];\n}\n\n// Define main function\nint main()\n{\n    // Initialize priority queue\n    PriorityQueue pq = { { 0 }, 0 };\n    // Add items to the queue\n    enqueue(&pq, 3);\n    enqueue(&pq, 2);\n    enqueue(&pq, 15);\n    enqueue(&pq, 5);\n    enqueue(&pq, 4);\n    enqueue(&pq, 45);\n\n    // Dequeue an item and print it\n    printf(\"%d dequeued from queue\\n\", dequeue(&pq));\n    // Print the top item of the queue\n    printf(\"Top element is %d\\n\", peek(&pq));\n\n    return 0;\n}\n```",
      "excerpt": "> [!NOTE] Def:\n> Priority queue is an abstract data type(ADT) in the computer science which is designed to the operate much like the regular queue except that each element has the certain priority. Th...",
      "createdAt": "1970-01-01T00:00:00.000Z",
      "modifiedAt": "2025-09-05T07:26:27.731Z"
    }
  ]
}